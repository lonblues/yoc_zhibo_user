!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t(exports) : typeof define === 'function' && define.amd ? define(['exports'], t) : t((e = e || self).QNRTC = {}) }(this, function (e) { 'use strict'; var t = function (e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e }; var r = function (e) { for (var r = 1; r < arguments.length; r++) { var n = arguments[r] != null ? arguments[r] : {}; var i = Object.keys(n); typeof Object.getOwnPropertySymbols === 'function' && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (e) { return Object.getOwnPropertyDescriptor(n, e).enumerable }))), i.forEach(function (r) { t(e, r, n[r]) }) } return e }; function n (e) { var t = a([['iOS', /iP(hone|od|ad)/], ['Android OS', /Android/], ['BlackBerry OS', /BlackBerry|BB10/], ['Windows Mobile', /IEMobile/], ['Amazon OS', /Kindle/], ['Windows 3.11', /Win16/], ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/], ['Windows 98', /(Windows 98)|(Win98)/], ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/], ['Windows XP', /(Windows NT 5.1)|(Windows XP)/], ['Windows Server 2003', /(Windows NT 5.2)/], ['Windows Vista', /(Windows NT 6.0)/], ['Windows 7', /(Windows NT 6.1)/], ['Windows 8', /(Windows NT 6.2)/], ['Windows 8.1', /(Windows NT 6.3)/], ['Windows 10', /(Windows NT 10.0)/], ['Windows ME', /Windows ME/], ['Open BSD', /OpenBSD/], ['Sun OS', /SunOS/], ['Linux', /(Linux)|(X11)/], ['Mac OS', /(Mac_PowerPC)|(Macintosh)/], ['QNX', /QNX/], ['BeOS', /BeOS/], ['OS/2', /OS\/2/], ['Search Bot', /(nuhk)|(Googlebot)|(Yammybot)|(Openbot)|(Slurp)|(MSNBot)|(Ask Jeeves\/Teoma)|(ia_archiver)/]]).filter(function (t) { return t.rule && t.rule.test(e) })[0]; return t ? t.name : null } function i () { return typeof process !== 'undefined' && process.version && { name: 'node', version: process.version.slice(1), os: process.platform } } function o (e) { var t = a([['aol', /AOLShield\/([0-9\._]+)/], ['edge', /Edge\/([0-9\._]+)/], ['yandexbrowser', /YaBrowser\/([0-9\._]+)/], ['vivaldi', /Vivaldi\/([0-9\.]+)/], ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/], ['samsung', /SamsungBrowser\/([0-9\.]+)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/], ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/], ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/], ['fxios', /FxiOS\/([0-9\.]+)/], ['opera', /Opera\/([0-9\.]+)(?:\s|$)/], ['opera', /OPR\/([0-9\.]+)(:?\s|$)$/], ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ['ie', /MSIE\s(7\.0)/], ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/], ['android', /Android\s([0-9\.]+)/], ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/], ['safari', /Version\/([0-9\._]+).*Safari/], ['facebook', /FBAV\/([0-9\.]+)/], ['instagram', /Instagram\s([0-9\.]+)/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/]]); if (!e) return null; var r = t.map(function (t) { var r = t.rule.exec(e); var n = r && r[1].split(/[._]/).slice(0, 3); return n && n.length < 3 && (n = n.concat(n.length == 1 ? [0, 0] : [0])), r && { name: t.name, version: n.join('.') } }).filter(Boolean)[0] || null; return r && (r.os = n(e)), /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/i.test(e) && ((r = r || {}).bot = !0), r } function a (e) { return e.map(function (e) { return { name: e[0], rule: e[1] } }) } var s = function () { return typeof navigator !== 'undefined' ? o(navigator.userAgent) : i() }; var c = s; var u = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}; function d () { throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs') } function l (e, t) { return e(t = { exports: {} }, t.exports), t.exports } var h = l(function (e, t) { var r; t = e.exports = J, r = typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () { var e = Array.prototype.slice.call(arguments, 0); e.unshift('SEMVER'), console.log.apply(console, e) } : function () { }, t.SEMVER_SPEC_VERSION = '2.0.0'; var n = 256; var i = Number.MAX_SAFE_INTEGER || 9007199254740991; var o = t.re = []; var a = t.src = []; var s = 0; var c = s++; a[c] = '0|[1-9]\\d*'; var u = s++; a[u] = '[0-9]+'; var d = s++; a[d] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'; var l = s++; a[l] = '(' + a[c] + ')\\.(' + a[c] + ')\\.(' + a[c] + ')'; var h = s++; a[h] = '(' + a[u] + ')\\.(' + a[u] + ')\\.(' + a[u] + ')'; var f = s++; a[f] = '(?:' + a[c] + '|' + a[d] + ')'; var p = s++; a[p] = '(?:' + a[u] + '|' + a[d] + ')'; var m = s++; a[m] = '(?:-(' + a[f] + '(?:\\.' + a[f] + ')*))'; var v = s++; a[v] = '(?:-?(' + a[p] + '(?:\\.' + a[p] + ')*))'; var g = s++; a[g] = '[0-9A-Za-z-]+'; var y = s++; a[y] = '(?:\\+(' + a[g] + '(?:\\.' + a[g] + ')*))'; var b = s++; var k = 'v?' + a[l] + a[m] + '?' + a[y] + '?'; a[b] = '^' + k + '$'; var _ = '[v=\\s]*' + a[h] + a[v] + '?' + a[y] + '?'; var S = s++; a[S] = '^' + _ + '$'; var T = s++; a[T] = '((?:<|>)?=?)'; var w = s++; a[w] = a[u] + '|x|X|\\*'; var C = s++; a[C] = a[c] + '|x|X|\\*'; var E = s++; a[E] = '[v=\\s]*(' + a[C] + ')(?:\\.(' + a[C] + ')(?:\\.(' + a[C] + ')(?:' + a[m] + ')?' + a[y] + '?)?)?'; var R = s++; a[R] = '[v=\\s]*(' + a[w] + ')(?:\\.(' + a[w] + ')(?:\\.(' + a[w] + ')(?:' + a[v] + ')?' + a[y] + '?)?)?'; var I = s++; a[I] = '^' + a[T] + '\\s*' + a[E] + '$'; var P = s++; a[P] = '^' + a[T] + '\\s*' + a[R] + '$'; var A = s++; a[A] = '(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])'; var M = s++; a[M] = '(?:~>?)'; var x = s++; a[x] = '(\\s*)' + a[M] + '\\s+', o[x] = new RegExp(a[x], 'g'); var O = s++; a[O] = '^' + a[M] + a[E] + '$'; var D = s++; a[D] = '^' + a[M] + a[R] + '$'; var L = s++; a[L] = '(?:\\^)'; var j = s++; a[j] = '(\\s*)' + a[L] + '\\s+', o[j] = new RegExp(a[j], 'g'); var N = s++; a[N] = '^' + a[L] + a[E] + '$'; var B = s++; a[B] = '^' + a[L] + a[R] + '$'; var F = s++; a[F] = '^' + a[T] + '\\s*(' + _ + ')$|^$'; var U = s++; a[U] = '^' + a[T] + '\\s*(' + k + ')$|^$'; var $ = s++; a[$] = '(\\s*)' + a[T] + '\\s*(' + _ + '|' + a[E] + ')', o[$] = new RegExp(a[$], 'g'); var V = s++; a[V] = '^\\s*(' + a[E] + ')\\s+-\\s+(' + a[E] + ')\\s*$'; var G = s++; a[G] = '^\\s*(' + a[R] + ')\\s+-\\s+(' + a[R] + ')\\s*$'; var W = s++; a[W] = '(<|>)?=?\\s*\\*'; for (var H = 0; H < 35; H++)r(H, a[H]), o[H] || (o[H] = new RegExp(a[H])); function z (e, t) { if (t && typeof t === 'object' || (t = { loose: !!t, includePrerelease: !1 }), e instanceof J) return e; if (typeof e !== 'string') return null; if (e.length > n) return null; if (!(t.loose ? o[S] : o[b]).test(e)) return null; try { return new J(e, t) } catch (e) { return null } } function J (e, t) { if (t && typeof t === 'object' || (t = { loose: !!t, includePrerelease: !1 }), e instanceof J) { if (e.loose === t.loose) return e; e = e.version } else if (typeof e !== 'string') throw new TypeError('Invalid Version: ' + e); if (e.length > n) throw new TypeError('version is longer than ' + n + ' characters'); if (!(this instanceof J)) return new J(e, t); r('SemVer', e, t), this.options = t, this.loose = !!t.loose; var a = e.trim().match(t.loose ? o[S] : o[b]); if (!a) throw new TypeError('Invalid Version: ' + e); if (this.raw = e, this.major = +a[1], this.minor = +a[2], this.patch = +a[3], this.major > i || this.major < 0) throw new TypeError('Invalid major version'); if (this.minor > i || this.minor < 0) throw new TypeError('Invalid minor version'); if (this.patch > i || this.patch < 0) throw new TypeError('Invalid patch version'); a[4] ? this.prerelease = a[4].split('.').map(function (e) { if (/^[0-9]+$/.test(e)) { var t = +e; if (t >= 0 && t < i) return t } return e }) : this.prerelease = [], this.build = a[5] ? a[5].split('.') : [], this.format() } t.parse = z, t.valid = function (e, t) { var r = z(e, t); return r ? r.version : null }, t.clean = function (e, t) { var r = z(e.trim().replace(/^[=v]+/, ''), t); return r ? r.version : null }, t.SemVer = J, J.prototype.format = function () { return this.version = this.major + '.' + this.minor + '.' + this.patch, this.prerelease.length && (this.version += '-' + this.prerelease.join('.')), this.version }, J.prototype.toString = function () { return this.version }, J.prototype.compare = function (e) { return r('SemVer.compare', this.version, this.options, e), e instanceof J || (e = new J(e, this.options)), this.compareMain(e) || this.comparePre(e) }, J.prototype.compareMain = function (e) { return e instanceof J || (e = new J(e, this.options)), X(this.major, e.major) || X(this.minor, e.minor) || X(this.patch, e.patch) }, J.prototype.comparePre = function (e) { if (e instanceof J || (e = new J(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1; if (!this.prerelease.length && e.prerelease.length) return 1; if (!this.prerelease.length && !e.prerelease.length) return 0; var t = 0; do { var n = this.prerelease[t]; var i = e.prerelease[t]; if (r('prerelease compare', t, n, i), void 0 === n && void 0 === i) return 0; if (void 0 === i) return 1; if (void 0 === n) return -1; if (n !== i) return X(n, i) } while (++t) }, J.prototype.inc = function (e, t) { switch (e) { case 'premajor': this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc('pre', t); break; case 'preminor': this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc('pre', t); break; case 'prepatch': this.prerelease.length = 0, this.inc('patch', t), this.inc('pre', t); break; case 'prerelease': this.prerelease.length === 0 && this.inc('patch', t), this.inc('pre', t); break; case 'major': this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = []; break; case 'minor': this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = []; break; case 'patch': this.prerelease.length === 0 && this.patch++, this.prerelease = []; break; case 'pre': if (this.prerelease.length === 0) this.prerelease = [0]; else { for (var r = this.prerelease.length; --r >= 0;) typeof this.prerelease[r] === 'number' && (this.prerelease[r]++, r = -2); r === -1 && this.prerelease.push(0) } t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]); break; default: throw new Error('invalid increment argument: ' + e) } return this.format(), this.raw = this.version, this }, t.inc = function (e, t, r, n) { typeof r === 'string' && (n = r, r = void 0); try { return new J(e, r).inc(t, n).version } catch (e) { return null } }, t.diff = function (e, t) { if (Y(e, t)) return null; var r = z(e); var n = z(t); if (r.prerelease.length || n.prerelease.length) { for (var i in r) if ((i === 'major' || i === 'minor' || i === 'patch') && r[i] !== n[i]) return 'pre' + i; return 'prerelease' } for (var i in r) if ((i === 'major' || i === 'minor' || i === 'patch') && r[i] !== n[i]) return i }, t.compareIdentifiers = X; var q = /^[0-9]+$/; function X (e, t) { var r = q.test(e); var n = q.test(t); return r && n && (e = +e, t = +t), r && !n ? -1 : n && !r ? 1 : e < t ? -1 : e > t ? 1 : 0 } function Q (e, t, r) { return new J(e, r).compare(new J(t, r)) } function K (e, t, r) { return Q(e, t, r) > 0 } function Z (e, t, r) { return Q(e, t, r) < 0 } function Y (e, t, r) { return Q(e, t, r) === 0 } function ee (e, t, r) { return Q(e, t, r) !== 0 } function te (e, t, r) { return Q(e, t, r) >= 0 } function re (e, t, r) { return Q(e, t, r) <= 0 } function ne (e, t, r, n) { var i; switch (t) { case '===': typeof e === 'object' && (e = e.version), typeof r === 'object' && (r = r.version), i = e === r; break; case '!==': typeof e === 'object' && (e = e.version), typeof r === 'object' && (r = r.version), i = e !== r; break; case '': case '=': case '==': i = Y(e, r, n); break; case '!=': i = ee(e, r, n); break; case '>': i = K(e, r, n); break; case '>=': i = te(e, r, n); break; case '<': i = Z(e, r, n); break; case '<=': i = re(e, r, n); break; default: throw new TypeError('Invalid operator: ' + t) } return i } function ie (e, t) { if (t && typeof t === 'object' || (t = { loose: !!t, includePrerelease: !1 }), e instanceof ie) { if (e.loose === !!t.loose) return e; e = e.value } if (!(this instanceof ie)) return new ie(e, t); r('comparator', e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === oe ? this.value = '' : this.value = this.operator + this.semver.version, r('comp', this) } t.rcompareIdentifiers = function (e, t) { return X(t, e) }, t.major = function (e, t) { return new J(e, t).major }, t.minor = function (e, t) { return new J(e, t).minor }, t.patch = function (e, t) { return new J(e, t).patch }, t.compare = Q, t.compareLoose = function (e, t) { return Q(e, t, !0) }, t.rcompare = function (e, t, r) { return Q(t, e, r) }, t.sort = function (e, r) { return e.sort(function (e, n) { return t.compare(e, n, r) }) }, t.rsort = function (e, r) { return e.sort(function (e, n) { return t.rcompare(e, n, r) }) }, t.gt = K, t.lt = Z, t.eq = Y, t.neq = ee, t.gte = te, t.lte = re, t.cmp = ne, t.Comparator = ie; var oe = {}; function ae (e, t) { if (t && typeof t === 'object' || (t = { loose: !!t, includePrerelease: !1 }), e instanceof ae) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new ae(e.raw, t); if (e instanceof ie) return new ae(e.value, t); if (!(this instanceof ae)) return new ae(e, t); if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map(function (e) { return this.parseRange(e.trim()) }, this).filter(function (e) { return e.length }), !this.set.length) throw new TypeError('Invalid SemVer Range: ' + e); this.format() } function se (e) { return !e || e.toLowerCase() === 'x' || e === '*' } function ce (e, t, r, n, i, o, a, s, c, u, d, l, h) { return ((t = se(r) ? '' : se(n) ? '>=' + r + '.0.0' : se(i) ? '>=' + r + '.' + n + '.0' : '>=' + t) + ' ' + (s = se(c) ? '' : se(u) ? '<' + (+c + 1) + '.0.0' : se(d) ? '<' + c + '.' + (+u + 1) + '.0' : l ? '<=' + c + '.' + u + '.' + d + '-' + l : '<=' + s)).trim() } function ue (e, t, n) { for (var i = 0; i < e.length; i++) if (!e[i].test(t)) return !1; if (n || (n = {}), t.prerelease.length && !n.includePrerelease) { for (i = 0; i < e.length; i++) if (r(e[i].semver), e[i].semver !== oe && e[i].semver.prerelease.length > 0) { var o = e[i].semver; if (o.major === t.major && o.minor === t.minor && o.patch === t.patch) return !0 } return !1 } return !0 } function de (e, t, r) { try { t = new ae(t, r) } catch (e) { return !1 } return t.test(e) } function le (e, t, r, n) { var i, o, a, s, c; switch (e = new J(e, n), t = new ae(t, n), r) { case '>': i = K, o = re, a = Z, s = '>', c = '>='; break; case '<': i = Z, o = te, a = K, s = '<', c = '<='; break; default: throw new TypeError('Must provide a hilo val of "<" or ">"') } if (de(e, t, n)) return !1; for (var u = 0; u < t.set.length; ++u) { var d = t.set[u]; var l = null; var h = null; if (d.forEach(function (e) { e.semver === oe && (e = new ie('>=0.0.0')), l = l || e, h = h || e, i(e.semver, l.semver, n) ? l = e : a(e.semver, h.semver, n) && (h = e) }), l.operator === s || l.operator === c) return !1; if ((!h.operator || h.operator === s) && o(e, h.semver)) return !1; if (h.operator === c && a(e, h.semver)) return !1 } return !0 } ie.prototype.parse = function (e) { var t = this.options.loose ? o[F] : o[U]; var r = e.match(t); if (!r) throw new TypeError('Invalid comparator: ' + e); this.operator = r[1], this.operator === '=' && (this.operator = ''), r[2] ? this.semver = new J(r[2], this.options.loose) : this.semver = oe }, ie.prototype.toString = function () { return this.value }, ie.prototype.test = function (e) { return r('Comparator.test', e, this.options.loose), this.semver === oe || (typeof e === 'string' && (e = new J(e, this.options)), ne(e, this.operator, this.semver, this.options)) }, ie.prototype.intersects = function (e, t) { if (!(e instanceof ie)) throw new TypeError('a Comparator is required'); var r; if (t && typeof t === 'object' || (t = { loose: !!t, includePrerelease: !1 }), this.operator === '') return r = new ae(e.value, t), de(this.value, r, t); if (e.operator === '') return r = new ae(this.value, t), de(e.semver, r, t); var n = !(this.operator !== '>=' && this.operator !== '>' || e.operator !== '>=' && e.operator !== '>'); var i = !(this.operator !== '<=' && this.operator !== '<' || e.operator !== '<=' && e.operator !== '<'); var o = this.semver.version === e.semver.version; var a = !(this.operator !== '>=' && this.operator !== '<=' || e.operator !== '>=' && e.operator !== '<='); var s = ne(this.semver, '<', e.semver, t) && (this.operator === '>=' || this.operator === '>') && (e.operator === '<=' || e.operator === '<'); var c = ne(this.semver, '>', e.semver, t) && (this.operator === '<=' || this.operator === '<') && (e.operator === '>=' || e.operator === '>'); return n || i || o && a || s || c }, t.Range = ae, ae.prototype.format = function () { return this.range = this.set.map(function (e) { return e.join(' ').trim() }).join('||').trim(), this.range }, ae.prototype.toString = function () { return this.range }, ae.prototype.parseRange = function (e) { var t = this.options.loose; e = e.trim(); var n = t ? o[G] : o[V]; e = e.replace(n, ce), r('hyphen replace', e), e = e.replace(o[$], '$1$2$3'), r('comparator trim', e, o[$]), e = (e = (e = e.replace(o[x], '$1~')).replace(o[j], '$1^')).split(/\s+/).join(' '); var i = t ? o[F] : o[U]; var a = e.split(' ').map(function (e) { return (function (e, t) { return r('comp', e, t), e = (function (e, t) { return e.trim().split(/\s+/).map(function (e) { return (function (e, t) { r('caret', e, t), t && typeof t === 'object' || (t = { loose: !!t, includePrerelease: !1 }); var n = t.loose ? o[B] : o[N]; return e.replace(n, function (t, n, i, o, a) { var s; return r('caret', e, t, n, i, o, a), se(n) ? s = '' : se(i) ? s = '>=' + n + '.0.0 <' + (+n + 1) + '.0.0' : se(o) ? s = n === '0' ? '>=' + n + '.' + i + '.0 <' + n + '.' + (+i + 1) + '.0' : '>=' + n + '.' + i + '.0 <' + (+n + 1) + '.0.0' : a ? (r('replaceCaret pr', a), a.charAt(0) !== '-' && (a = '-' + a), s = n === '0' ? i === '0' ? '>=' + n + '.' + i + '.' + o + a + ' <' + n + '.' + i + '.' + (+o + 1) : '>=' + n + '.' + i + '.' + o + a + ' <' + n + '.' + (+i + 1) + '.0' : '>=' + n + '.' + i + '.' + o + a + ' <' + (+n + 1) + '.0.0') : (r('no pr'), s = n === '0' ? i === '0' ? '>=' + n + '.' + i + '.' + o + ' <' + n + '.' + i + '.' + (+o + 1) : '>=' + n + '.' + i + '.' + o + ' <' + n + '.' + (+i + 1) + '.0' : '>=' + n + '.' + i + '.' + o + ' <' + (+n + 1) + '.0.0'), r('caret return', s), s }) }(e, t)) }).join(' ') }(e, t)), r('caret', e), e = (function (e, t) { return e.trim().split(/\s+/).map(function (e) { return (function (e, t) { t && typeof t === 'object' || (t = { loose: !!t, includePrerelease: !1 }); var n = t.loose ? o[D] : o[O]; return e.replace(n, function (t, n, i, o, a) { var s; return r('tilde', e, t, n, i, o, a), se(n) ? s = '' : se(i) ? s = '>=' + n + '.0.0 <' + (+n + 1) + '.0.0' : se(o) ? s = '>=' + n + '.' + i + '.0 <' + n + '.' + (+i + 1) + '.0' : a ? (r('replaceTilde pr', a), a.charAt(0) !== '-' && (a = '-' + a), s = '>=' + n + '.' + i + '.' + o + a + ' <' + n + '.' + (+i + 1) + '.0') : s = '>=' + n + '.' + i + '.' + o + ' <' + n + '.' + (+i + 1) + '.0', r('tilde return', s), s }) }(e, t)) }).join(' ') }(e, t)), r('tildes', e), e = (function (e, t) { return r('replaceXRanges', e, t), e.split(/\s+/).map(function (e) { return (function (e, t) { e = e.trim(), t && typeof t === 'object' || (t = { loose: !!t, includePrerelease: !1 }); var n = t.loose ? o[P] : o[I]; return e.replace(n, function (t, n, i, o, a, s) { r('xRange', e, t, n, i, o, a, s); var c = se(i); var u = c || se(o); var d = u || se(a); var l = d; return n === '=' && l && (n = ''), c ? t = n === '>' || n === '<' ? '<0.0.0' : '*' : n && l ? (u && (o = 0), d && (a = 0), n === '>' ? (n = '>=', u ? (i = +i + 1, o = 0, a = 0) : d && (o = +o + 1, a = 0)) : n === '<=' && (n = '<', u ? i = +i + 1 : o = +o + 1), t = n + i + '.' + o + '.' + a) : u ? t = '>=' + i + '.0.0 <' + (+i + 1) + '.0.0' : d && (t = '>=' + i + '.' + o + '.0 <' + i + '.' + (+o + 1) + '.0'), r('xRange return', t), t }) }(e, t)) }).join(' ') }(e, t)), r('xrange', e), e = (function (e, t) { return r('replaceStars', e, t), e.trim().replace(o[W], '') }(e, t)), r('stars', e), e }(e, this.options)) }, this).join(' ').split(/\s+/); return this.options.loose && (a = a.filter(function (e) { return !!e.match(i) })), a = a.map(function (e) { return new ie(e, this.options) }, this) }, ae.prototype.intersects = function (e, t) { if (!(e instanceof ae)) throw new TypeError('a Range is required'); return this.set.some(function (r) { return r.every(function (r) { return e.set.some(function (e) { return e.every(function (e) { return r.intersects(e, t) }) }) }) }) }, t.toComparators = function (e, t) { return new ae(e, t).set.map(function (e) { return e.map(function (e) { return e.value }).join(' ').trim().split(' ') }) }, ae.prototype.test = function (e) { if (!e) return !1; typeof e === 'string' && (e = new J(e, this.options)); for (var t = 0; t < this.set.length; t++) if (ue(this.set[t], e, this.options)) return !0; return !1 }, t.satisfies = de, t.maxSatisfying = function (e, t, r) { var n = null; var i = null; try { var o = new ae(t, r) } catch (e) { return null } return e.forEach(function (e) { o.test(e) && (n && i.compare(e) !== -1 || (i = new J(n = e, r))) }), n }, t.minSatisfying = function (e, t, r) { var n = null; var i = null; try { var o = new ae(t, r) } catch (e) { return null } return e.forEach(function (e) { o.test(e) && (n && i.compare(e) !== 1 || (i = new J(n = e, r))) }), n }, t.validRange = function (e, t) { try { return new ae(e, t).range || '*' } catch (e) { return null } }, t.ltr = function (e, t, r) { return le(e, t, '<', r) }, t.gtr = function (e, t, r) { return le(e, t, '>', r) }, t.outside = le, t.prerelease = function (e, t) { var r = z(e, t); return r && r.prerelease.length ? r.prerelease : null }, t.intersects = function (e, t, r) { return e = new ae(e, r), t = new ae(t, r), e.intersects(t) }, t.coerce = function (e) { if (e instanceof J) return e; if (typeof e !== 'string') return null; var t = e.match(o[A]); return t == null ? null : z((t[1] || '0') + '.' + (t[2] || '0') + '.' + (t[3] || '0')) } }); var f = (h.SEMVER_SPEC_VERSION, h.re, h.src, h.parse, h.valid, h.clean, h.SemVer, h.inc, h.diff, h.compareIdentifiers, h.rcompareIdentifiers, h.major, h.minor, h.patch, h.compare, h.compareLoose, h.rcompare, h.sort, h.rsort, h.gt); var p = h.lt; var m = (h.eq, h.neq, h.gte); var v = h.lte; h.cmp, h.Comparator, h.Range, h.toComparators, h.satisfies, h.maxSatisfying, h.minSatisfying, h.validRange, h.ltr, h.gtr, h.outside, h.prerelease, h.intersects, h.coerce; const g = navigator.userAgent.toLowerCase().indexOf('firefox') > -1; const y = !!window.chrome; const b = navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPhone/i); const k = (function () { const e = c(); if (!navigator || !navigator.appVersion || !e) return e; const t = /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/.exec(window.navigator.appVersion); return t && t[1] ? r({}, e, { chromeVersion: t[1] }) : e }()) || {}; function _ () { try { return !!RTCPeerConnection && (!!WebSocket && !!navigator.mediaDevices.getUserMedia) } catch (e) { return !1 } } function S () { const e = navigator && navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia; const t = navigator && navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().displaySurface; return g ? !!e && !!t : !!e } const T = (function () { if (!k) return { support: _(), supportRestartICE: !0, getDisplayMedia: S(), disconnectAudioNode: !0 }; switch (k.name) { case 'chrome': return { support: m(k.version, '52.0.0'), mediaStreamDest: m(k.version, '55.0.0'), replaceTrack: m(k.version, '65.0.0'), screenSharing: m(k.version, '55.0.0'), connectionState: !1, stats: m(k.version, '67.0.0'), ondevicechange: m(k.version, '57.0.0'), minMaxWithIdeal: m(k.version, '56.0.0'), unifiedPlan: !1, supportTransceivers: !0, supportRestartICE: !0, getReceivers: m(k.version, '55.0.0'), needH264FmtpLine: v(k.version, '51.0.0'), audioContextOptions: !0, getDisplayMedia: S(), disconnectAudioNode: !0 }; case 'ios': case 'safari': return { support: m(k.version, '11.0.0'), replaceTrack: m(k.version, '11.0.0'), stats: !1, ondevicechange: !1, connectionState: !0, mediaStreamDest: m(k.version, '12.0.0'), screenSharing: !1, unifiedPlan: m(k.version, '12.1.0'), supportTransceivers: !0, minMaxWithIdeal: !1, supportRestartICE: !0, getReceivers: !0, audioContextOptions: !0, getDisplayMedia: S(), disconnectAudioNode: !1 }; case 'firefox': return { support: _() && m(k.version, '52.0.0'), replaceTrack: !0, stats: !0, ondevicechange: m(k.version, '52.0.0'), connectionState: !0, mediaStreamDest: !0, screenSharing: !0, minMaxWithIdeal: !0, unifiedPlan: !0, supportTransceivers: m(k.version, '59.0.0'), supportRestartICE: !1, getReceivers: !0, audioContextOptions: m(k.version, '55.0.0'), getDisplayMedia: S(), disconnectAudioNode: !0 }; default: return { support: _(), supportRestartICE: !0, getDisplayMedia: S(), disconnectAudioNode: !0 } } }()); k.name === 'chrome' && (function () { const e = function (e) { if (typeof e !== 'object' || e.mandatory || e.optional) return e; const t = {}; return Object.keys(e).forEach(r => { if (r === 'require' || r === 'advanced' || r === 'mediaSource') return; const n = typeof e[r] === 'object' ? e[r] : { ideal: e[r] }; void 0 !== n.exact && typeof n.exact === 'number' && (n.min = n.max = n.exact); const i = function (e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : t === 'deviceId' ? 'sourceId' : t }; if (void 0 !== n.ideal) { t.optional = t.optional || []; let e = {}; typeof n.ideal === 'number' ? (e[i('min', r)] = n.ideal, t.optional.push(e), (e = {})[i('max', r)] = n.ideal, t.optional.push(e)) : (e[i('', r)] = n.ideal, t.optional.push(e)) } void 0 !== n.exact && typeof n.exact !== 'number' ? (t.mandatory = t.mandatory || {}, t.mandatory[i('', r)] = n.exact) : ['min', 'max'].forEach(e => { void 0 !== n[e] && (t.mandatory = t.mandatory || {}, t.mandatory[i(e, r)] = n[e]) }) }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t }; const t = function (e) { return new Promise((t, r) => { navigator.getUserMedia(e, t, r) }) }; if (navigator.mediaDevices || (navigator.mediaDevices = { getUserMedia: t, enumerateDevices: () => new Promise(e => { const t = { audio: 'audioinput', video: 'videoinput' }; return window.MediaStreamTrack.getSources(r => { e(r.map(e => ({ label: e.label, kind: t[e.kind], deviceId: e.id, groupId: '' }))) }) }) }), navigator.mediaDevices.getSupportedConstraints || (navigator.mediaDevices.getSupportedConstraints = () => ({ deviceId: !0, echoCancellation: !0, facingMode: !0, frameRate: !0, height: !0, width: !0 })), navigator.mediaDevices.getUserMedia) { const t = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function (r) { return (function (t, r) { if (f(k.version, '61.0.0')) return r(t); if ((t = JSON.parse(JSON.stringify(t))) && typeof t.audio === 'object') { const r = function (e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]) }; r((t = JSON.parse(JSON.stringify(t))).audio, 'autoGainControl', 'googAutoGainControl'), r(t.audio, 'noiseSuppression', 'googNoiseSuppression'), t.audio = e(t.audio) } if (t && typeof t.video === 'object') { let n = t.video.facingMode; n = n && (typeof n === 'object' ? n : { ideal: n }); const i = p(k.version, '66.0.0'); if (n && (n.exact === 'user' || n.exact === 'environment' || n.ideal === 'user' || n.ideal === 'environment') && (!navigator.mediaDevices.getSupportedConstraints || !navigator.mediaDevices.getSupportedConstraints().facingMode || i)) { delete t.video.facingMode; let i = void 0; if (n.exact === 'environment' || n.ideal === 'environment' ? i = ['back', 'rear'] : n.exact !== 'user' && n.ideal !== 'user' || (i = ['front']), i) return navigator.mediaDevices.enumerateDevices().then(o => { let a = (o = o.filter(e => e.kind === 'videoinput')).find(e => i.some(t => e.label.toLowerCase().includes(t))); return !a && o.length && i.includes('back') && (a = o[o.length - 1]), a && (t.video.deviceId = n.exact ? { exact: a.deviceId } : { ideal: a.deviceId }), t.video = e(t.video), r(t) }) } t.video = e(t.video) } return r(t) }(r, e => t(e).then(t => { if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach(e => { e.stop() }), new DOMException('', 'NotFoundError'); return t }, e => Promise.reject(e)))) } } else navigator.mediaDevices.getUserMedia = function (e) { return t(e) } }()), k.name === 'firefox' && (function () { const e = function (e) { return new Promise((t, r) => { !(function (e, t, r) { e = JSON.parse(JSON.stringify(e)), navigator.mozGetUserMedia(e, t, e => { r(e) }) }(e, t, r)) }) }; navigator.mediaDevices || (navigator.mediaDevices = { getUserMedia: e, addEventListener () { }, removeEventListener () { } }), navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function () { return new Promise(e => { e([{ kind: 'audioinput', deviceId: 'default', label: '', groupId: '' }, { kind: 'videoinput', deviceId: 'default', label: '', groupId: '' }]) }) } }()); var w; var C = l(function (e) { !(function () { return function e (t, r, n) { function i (a, s) { if (!r[a]) { if (!t[a]) { if (!s && d) return d(); if (o) return o(a, !0); var c = new Error("Cannot find module '" + a + "'"); throw c.code = 'MODULE_NOT_FOUND', c } var u = r[a] = { exports: {} }; t[a][0].call(u.exports, function (e) { return i(t[a][1][e] || e) }, u, u.exports, e, t, r, n) } return r[a].exports } for (var o = d, a = 0; a < n.length; a++)i(n[a]); return i } }())({ 1: [function (e, t, r) { var n = (0, e('./adapter_factory.js').adapterFactory)({ window: window }); t.exports = n }, { './adapter_factory.js': 2 }], 2: [function (e, t, r) { Object.defineProperty(r, '__esModule', { value: !0 }), r.adapterFactory = function () { var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).window; var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: !0, shimFirefox: !0, shimEdge: !0, shimSafari: !0 }; var r = n.log; var u = n.detectBrowser(e); var d = { browserDetails: u, commonShim: c, extractVersion: n.extractVersion, disableLog: n.disableLog, disableWarnings: n.disableWarnings }; switch (u.browser) { case 'chrome': if (!i || !i.shimPeerConnection || !t.shimChrome) return r('Chrome shim is not included in this adapter release.'), d; r('adapter.js shimming chrome.'), d.browserShim = i, i.shimGetUserMedia(e), i.shimMediaStream(e), i.shimPeerConnection(e), i.shimOnTrack(e), i.shimAddTrackRemoveTrack(e), i.shimGetSendersWithDtmf(e), i.shimSenderReceiverGetStats(e), i.fixNegotiationNeeded(e), c.shimRTCIceCandidate(e), c.shimConnectionState(e), c.shimMaxMessageSize(e), c.shimSendThrowTypeError(e), c.removeAllowExtmapMixed(e); break; case 'firefox': if (!a || !a.shimPeerConnection || !t.shimFirefox) return r('Firefox shim is not included in this adapter release.'), d; r('adapter.js shimming firefox.'), d.browserShim = a, a.shimGetUserMedia(e), a.shimPeerConnection(e), a.shimOnTrack(e), a.shimRemoveStream(e), a.shimSenderGetStats(e), a.shimReceiverGetStats(e), a.shimRTCDataChannel(e), c.shimRTCIceCandidate(e), c.shimConnectionState(e), c.shimMaxMessageSize(e), c.shimSendThrowTypeError(e); break; case 'edge': if (!o || !o.shimPeerConnection || !t.shimEdge) return r('MS edge shim is not included in this adapter release.'), d; r('adapter.js shimming edge.'), d.browserShim = o, o.shimGetUserMedia(e), o.shimGetDisplayMedia(e), o.shimPeerConnection(e), o.shimReplaceTrack(e), c.shimMaxMessageSize(e), c.shimSendThrowTypeError(e); break; case 'safari': if (!s || !t.shimSafari) return r('Safari shim is not included in this adapter release.'), d; r('adapter.js shimming safari.'), d.browserShim = s, s.shimRTCIceServerUrls(e), s.shimCreateOfferLegacy(e), s.shimCallbacksAPI(e), s.shimLocalStreamsAPI(e), s.shimRemoteStreamsAPI(e), s.shimTrackEventTransceiver(e), s.shimGetUserMedia(e), c.shimRTCIceCandidate(e), c.shimMaxMessageSize(e), c.shimSendThrowTypeError(e), c.removeAllowExtmapMixed(e); break; default: r('Unsupported browser!') } return d }; var n = u(e('./utils')); var i = u(e('./chrome/chrome_shim')); var o = u(e('./edge/edge_shim')); var a = u(e('./firefox/firefox_shim')); var s = u(e('./safari/safari_shim')); var c = u(e('./common_shim')); function u (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t } }, { './chrome/chrome_shim': 3, './common_shim': 6, './edge/edge_shim': 12, './firefox/firefox_shim': 7, './safari/safari_shim': 10, './utils': 11 }], 3: [function (e, t, r) { Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = r.shimGetUserMedia = void 0; var n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; var i = e('./getusermedia'); Object.defineProperty(r, 'shimGetUserMedia', { enumerable: !0, get: function () { return i.shimGetUserMedia } }); var o = e('./getdisplaymedia'); Object.defineProperty(r, 'shimGetDisplayMedia', { enumerable: !0, get: function () { return o.shimGetDisplayMedia } }), r.shimMediaStream = function (e) { e.MediaStream = e.MediaStream || e.webkitMediaStream }, r.shimOnTrack = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection || 'ontrack' in e.RTCPeerConnection.prototype) a.wrapPeerConnectionEvent(e, 'track', function (e) { return e.transceiver || Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } }), e }); else { Object.defineProperty(e.RTCPeerConnection.prototype, 'ontrack', { get: function () { return this._ontrack }, set: function (e) { this._ontrack && this.removeEventListener('track', this._ontrack), this.addEventListener('track', this._ontrack = e) }, enumerable: !0, configurable: !0 }); var t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { var r = this; return this._ontrackpoly || (this._ontrackpoly = function (t) { t.stream.addEventListener('addtrack', function (n) { var i = void 0; i = e.RTCPeerConnection.prototype.getReceivers ? r.getReceivers().find(function (e) { return e.track && e.track.id === n.track.id }) : { track: n.track }; var o = new Event('track'); o.track = n.track, o.receiver = i, o.transceiver = { receiver: i }, o.streams = [t.stream], r.dispatchEvent(o) }), t.stream.getTracks().forEach(function (n) { var i = void 0; i = e.RTCPeerConnection.prototype.getReceivers ? r.getReceivers().find(function (e) { return e.track && e.track.id === n.id }) : { track: n }; var o = new Event('track'); o.track = n, o.receiver = i, o.transceiver = { receiver: i }, o.streams = [t.stream], r.dispatchEvent(o) }) }, this.addEventListener('addstream', this._ontrackpoly)), t.apply(this, arguments) } } }, r.shimGetSendersWithDtmf = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && !('getSenders' in e.RTCPeerConnection.prototype) && 'createDTMFSender' in e.RTCPeerConnection.prototype) { var t = function (e, t) { return { track: t, get dtmf () { return void 0 === this._dtmf && (t.kind === 'audio' ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf }, _pc: e } }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; var r = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, n) { var i = r.apply(this, arguments); return i || (i = t(this, e), this._senders.push(i)), i }; var i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { i.apply(this, arguments); var t = this._senders.indexOf(e); t !== -1 && this._senders.splice(t, 1) } } var o = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { var r = this; this._senders = this._senders || [], o.apply(this, [e]), e.getTracks().forEach(function (e) { r._senders.push(t(r, e)) }) }; var a = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { var t = this; this._senders = this._senders || [], a.apply(this, [e]), e.getTracks().forEach(function (e) { var r = t._senders.find(function (t) { return t.track === e }); r && t._senders.splice(t._senders.indexOf(r), 1) }) } } else if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && 'getSenders' in e.RTCPeerConnection.prototype && 'createDTMFSender' in e.RTCPeerConnection.prototype && e.RTCRtpSender && !('dtmf' in e.RTCRtpSender.prototype)) { var s = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { var e = this; var t = s.apply(this, []); return t.forEach(function (t) { return t._pc = e }), t }, Object.defineProperty(e.RTCRtpSender.prototype, 'dtmf', { get: function () { return void 0 === this._dtmf && (this.track.kind === 'audio' ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } }, r.shimSenderReceiverGetStats = function (e) { if (!((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return; if (!('getStats' in e.RTCRtpSender.prototype)) { var t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { var e = this; var r = t.apply(this, []); return r.forEach(function (t) { return t._pc = e }), r }); var r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { var e = r.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { var e = this; return this._pc.getStats().then(function (t) { return s(t, e.track, !0) }) } } if (!('getStats' in e.RTCRtpReceiver.prototype)) { var i = e.RTCPeerConnection.prototype.getReceivers; i && (e.RTCPeerConnection.prototype.getReceivers = function () { var e = this; var t = i.apply(this, []); return t.forEach(function (t) { return t._pc = e }), t }), a.wrapPeerConnectionEvent(e, 'track', function (e) { return e.receiver._pc = e.srcElement, e }), e.RTCRtpReceiver.prototype.getStats = function () { var e = this; return this._pc.getStats().then(function (t) { return s(t, e.track, !1) }) } } if (!('getStats' in e.RTCRtpSender.prototype && 'getStats' in e.RTCRtpReceiver.prototype)) return; var o = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { var t = arguments[0]; var r = void 0; var n = void 0; var i = void 0; return this.getSenders().forEach(function (e) { e.track === t && (r ? i = !0 : r = e) }), this.getReceivers().forEach(function (e) { return e.track === t && (n ? i = !0 : n = e), e.track === t }), i || r && n ? Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError')) : r ? r.getStats() : n ? n.getStats() : Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError')) } return o.apply(this, arguments) } }, r.shimAddTrackRemoveTrackWithNative = c, r.shimAddTrackRemoveTrack = function (e) { if (!e.RTCPeerConnection) return; var t = a.detectBrowser(e); if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return c(e); var r = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { var e = this; var t = r.apply(this); return this._reverseStreams = this._reverseStreams || {}, t.map(function (t) { return e._reverseStreams[t.id] }) }; var n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (t) { var r = this; if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(function (e) { var t = r.getSenders().find(function (t) { return t.track === e }); if (t) throw new DOMException('Track already exists.', 'InvalidAccessError') }), !this._reverseStreams[t.id]) { var i = new e.MediaStream(t.getTracks()); this._streams[t.id] = i, this._reverseStreams[i.id] = t, t = i } n.apply(this, [t]) }; var i = e.RTCPeerConnection.prototype.removeStream; function o (e, t) { var r = t.sdp; return Object.keys(e._reverseStreams || []).forEach(function (t) { var n = e._reverseStreams[t]; var i = e._streams[n.id]; r = r.replace(new RegExp(i.id, 'g'), n.id) }), new RTCSessionDescription({ type: t.type, sdp: r }) } e.RTCPeerConnection.prototype.removeStream = function (e) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, i.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id] }, e.RTCPeerConnection.prototype.addTrack = function (t, r) { var n = this; if (this.signalingState === 'closed') throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", 'InvalidStateError'); var i = [].slice.call(arguments, 1); if (i.length !== 1 || !i[0].getTracks().find(function (e) { return e === t })) throw new DOMException('The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.', 'NotSupportedError'); var o = this.getSenders().find(function (e) { return e.track === t }); if (o) throw new DOMException('Track already exists.', 'InvalidAccessError'); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; var a = this._streams[r.id]; if (a) a.addTrack(t), Promise.resolve().then(function () { n.dispatchEvent(new Event('negotiationneeded')) }); else { var s = new e.MediaStream([t]); this._streams[r.id] = s, this._reverseStreams[s.id] = r, this.addStream(s) } return this.getSenders().find(function (e) { return e.track === t }) }, ['createOffer', 'createAnswer'].forEach(function (t) { var r = e.RTCPeerConnection.prototype[t]; e.RTCPeerConnection.prototype[t] = function () { var e = this; var t = arguments; var n = arguments.length && typeof arguments[0] === 'function'; return n ? r.apply(this, [function (r) { var n = o(e, r); t[0].apply(null, [n]) }, function (e) { t[1] && t[1].apply(null, e) }, arguments[2]]) : r.apply(this, arguments).then(function (t) { return o(e, t) }) } }); var s = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return arguments.length && arguments[0].type ? (arguments[0] = (e = this, t = arguments[0], r = t.sdp, Object.keys(e._reverseStreams || []).forEach(function (t) { var n = e._reverseStreams[t]; var i = e._streams[n.id]; r = r.replace(new RegExp(n.id, 'g'), i.id) }), new RTCSessionDescription({ type: t.type, sdp: r })), s.apply(this, arguments)) : s.apply(this, arguments); var e, t, r }; var u = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, 'localDescription'); Object.defineProperty(e.RTCPeerConnection.prototype, 'localDescription', { get: function () { var e = u.get.apply(this); return e.type === '' ? e : o(this, e) } }), e.RTCPeerConnection.prototype.removeTrack = function (e) { var t = this; if (this.signalingState === 'closed') throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", 'InvalidStateError'); if (!e._pc) throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.', 'TypeError'); var r = e._pc === this; if (!r) throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError'); this._streams = this._streams || {}; var n = void 0; Object.keys(this._streams).forEach(function (r) { var i = t._streams[r].getTracks().find(function (t) { return e.track === t }); i && (n = t._streams[r]) }), n && (n.getTracks().length === 1 ? this.removeStream(this._reverseStreams[n.id]) : n.removeTrack(e.track), this.dispatchEvent(new Event('negotiationneeded'))) } }, r.shimPeerConnection = function (e) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection); if (!e.RTCPeerConnection) return; var t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function (e, r, n) { var i = this; var o = arguments; if (arguments.length > 0 && typeof e === 'function') return t.apply(this, arguments); if (t.length === 0 && (arguments.length === 0 || typeof arguments[0] !== 'function')) return t.apply(this, []); var a = function (e) { var t = {}; var r = e.result(); return r.forEach(function (e) { var r = { id: e.id, timestamp: e.timestamp, type: { localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[e.type] || e.type }; e.names().forEach(function (t) { r[t] = e.stat(t) }), t[r.id] = r }), t }; var s = function (e) { return new Map(Object.keys(e).map(function (t) { return [t, e[t]] })) }; if (arguments.length >= 2) { return t.apply(this, [function (e) { o[1](s(a(e))) }, arguments[0]]) } return new Promise(function (e, r) { t.apply(i, [function (t) { e(s(a(t))) }, r]) }).then(r, n) }, ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (t) { var r = e.RTCPeerConnection.prototype[t]; e.RTCPeerConnection.prototype[t] = function () { return arguments[0] = new (t === 'addIceCandidate' ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), r.apply(this, arguments) } }); var r = e.RTCPeerConnection.prototype.addIceCandidate; e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) } }, r.fixNegotiationNeeded = function (e) { a.wrapPeerConnectionEvent(e, 'negotiationneeded', function (e) { var t = e.target; if (t.signalingState === 'stable') return e }) }; var a = (function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e('../utils.js'))); function s (e, t, r) { var n = r ? 'outbound-rtp' : 'inbound-rtp'; var i = new Map(); if (t === null) return i; var o = []; return e.forEach(function (e) { e.type === 'track' && e.trackIdentifier === t.id && o.push(e) }), o.forEach(function (t) { e.forEach(function (r) { r.type === n && r.trackId === t.id && (function e (t, r, n) { r && !n.has(r.id) && (n.set(r.id, r), Object.keys(r).forEach(function (i) { i.endsWith('Id') ? e(t, t.get(r[i]), n) : i.endsWith('Ids') && r[i].forEach(function (r) { e(t, t.get(r), n) }) })) }(e, r, i)) }) }), i } function c (e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { var e = this; return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(function (t) { return e._shimmedLocalStreams[t][0] }) }; var t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, r) { if (!r) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; var n = t.apply(this, arguments); return this._shimmedLocalStreams[r.id] ? this._shimmedLocalStreams[r.id].indexOf(n) === -1 && this._shimmedLocalStreams[r.id].push(n) : this._shimmedLocalStreams[r.id] = [r, n], n }; var r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { var t = this; this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(function (e) { if (t.getSenders().find(function (t) { return t.track === e })) throw new DOMException('Track already exists.', 'InvalidAccessError') }); var n = this.getSenders(); r.apply(this, arguments); var i = this.getSenders().filter(function (e) { return n.indexOf(e) === -1 }); this._shimmedLocalStreams[e.id] = [e].concat(i) }; var n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], n.apply(this, arguments) }; var i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { var t = this; return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(function (r) { var n = t._shimmedLocalStreams[r].indexOf(e); n !== -1 && t._shimmedLocalStreams[r].splice(n, 1), t._shimmedLocalStreams[r].length === 1 && delete t._shimmedLocalStreams[r] }), i.apply(this, arguments) } } }, { '../utils.js': 11, './getdisplaymedia': 4, './getusermedia': 5 }], 4: [function (e, t, r) { Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = function (e, t) { if (e.navigator.mediaDevices && 'getDisplayMedia' in e.navigator.mediaDevices) return; if (!e.navigator.mediaDevices) return; if (typeof t !== 'function') return void console.error('shimGetDisplayMedia: getSourceId argument is not a function'); e.navigator.mediaDevices.getDisplayMedia = function (r) { return t(r).then(function (t) { var n = r.video && r.video.width; var i = r.video && r.video.height; var o = r.video && r.video.frameRate; return r.video = { mandatory: { chromeMediaSource: 'desktop', chromeMediaSourceId: t, maxFrameRate: o || 3 } }, n && (r.video.mandatory.maxWidth = n), i && (r.video.mandatory.maxHeight = i), e.navigator.mediaDevices.getUserMedia(r) }) } } }, {}], 5: [function (e, t, r) { Object.defineProperty(r, '__esModule', { value: !0 }); var n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; r.shimGetUserMedia = function (e) { var t = e && e.navigator; if (!t.mediaDevices) return; var r = i.detectBrowser(e); var a = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || e.mandatory || e.optional) return e; var t = {}; return Object.keys(e).forEach(function (r) { if (r !== 'require' && r !== 'advanced' && r !== 'mediaSource') { var i = n(e[r]) === 'object' ? e[r] : { ideal: e[r] }; void 0 !== i.exact && typeof i.exact === 'number' && (i.min = i.max = i.exact); var o = function (e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : t === 'deviceId' ? 'sourceId' : t }; if (void 0 !== i.ideal) { t.optional = t.optional || []; var a = {}; typeof i.ideal === 'number' ? (a[o('min', r)] = i.ideal, t.optional.push(a), (a = {})[o('max', r)] = i.ideal, t.optional.push(a)) : (a[o('', r)] = i.ideal, t.optional.push(a)) } void 0 !== i.exact && typeof i.exact !== 'number' ? (t.mandatory = t.mandatory || {}, t.mandatory[o('', r)] = i.exact) : ['min', 'max'].forEach(function (e) { void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[o(e, r)] = i[e]) }) } }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t }; var s = function (e, i) { if (r.version >= 61) return i(e); if ((e = JSON.parse(JSON.stringify(e))) && n(e.audio) === 'object') { var s = function (e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]) }; e = JSON.parse(JSON.stringify(e)), s(e.audio, 'autoGainControl', 'googAutoGainControl'), s(e.audio, 'noiseSuppression', 'googNoiseSuppression'), e.audio = a(e.audio) } if (e && n(e.video) === 'object') { var c = e.video.facingMode; c = c && ((void 0 === c ? 'undefined' : n(c)) === 'object' ? c : { ideal: c }); var u = r.version < 66; if (c && (c.exact === 'user' || c.exact === 'environment' || c.ideal === 'user' || c.ideal === 'environment') && (!t.mediaDevices.getSupportedConstraints || !t.mediaDevices.getSupportedConstraints().facingMode || u)) { delete e.video.facingMode; var d = void 0; if (c.exact === 'environment' || c.ideal === 'environment' ? d = ['back', 'rear'] : c.exact !== 'user' && c.ideal !== 'user' || (d = ['front']), d) return t.mediaDevices.enumerateDevices().then(function (t) { var r = (t = t.filter(function (e) { return e.kind === 'videoinput' })).find(function (e) { return d.some(function (t) { return e.label.toLowerCase().includes(t) }) }); return !r && t.length && d.includes('back') && (r = t[t.length - 1]), r && (e.video.deviceId = c.exact ? { exact: r.deviceId } : { ideal: r.deviceId }), e.video = a(e.video), o('chrome: ' + JSON.stringify(e)), i(e) }) } e.video = a(e.video) } return o('chrome: ' + JSON.stringify(e)), i(e) }; var c = function (e) { return r.version >= 64 ? e : { name: { PermissionDeniedError: 'NotAllowedError', PermissionDismissedError: 'NotAllowedError', InvalidStateError: 'NotAllowedError', DevicesNotFoundError: 'NotFoundError', ConstraintNotSatisfiedError: 'OverconstrainedError', TrackStartError: 'NotReadableError', MediaDeviceFailedDueToShutdown: 'NotAllowedError', MediaDeviceKillSwitchOn: 'NotAllowedError', TabCaptureError: 'AbortError', ScreenCaptureError: 'AbortError', DeviceCaptureError: 'AbortError' }[e.name] || e.name, message: e.message, constraint: e.constraint || e.constraintName, toString: function () { return this.name + (this.message && ': ') + this.message } } }; t.getUserMedia = function (e, r, n) { s(e, function (e) { t.webkitGetUserMedia(e, r, function (e) { n && n(c(e)) }) }) }; var u = t.mediaDevices.getUserMedia.bind(t.mediaDevices); t.mediaDevices.getUserMedia = function (e) { return s(e, function (e) { return u(e).then(function (t) { if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach(function (e) { e.stop() }), new DOMException('', 'NotFoundError'); return t }, function (e) { return Promise.reject(c(e)) }) }) } }; var i = (function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e('../utils.js'))); var o = i.log }, { '../utils.js': 11 }], 6: [function (e, t, r) { Object.defineProperty(r, '__esModule', { value: !0 }); var n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; r.shimRTCIceCandidate = function (e) { if (!e.RTCIceCandidate || e.RTCIceCandidate && 'foundation' in e.RTCIceCandidate.prototype) return; var t = e.RTCIceCandidate; e.RTCIceCandidate = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.candidate && e.candidate.indexOf('a=') === 0 && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) { var r = new t(e); var i = a.default.parseCandidate(e.candidate); var o = Object.assign(r, i); return o.toJSON = function () { return { candidate: o.candidate, sdpMid: o.sdpMid, sdpMLineIndex: o.sdpMLineIndex, usernameFragment: o.usernameFragment } }, o } return new t(e) }, e.RTCIceCandidate.prototype = t.prototype, s.wrapPeerConnectionEvent(e, 'icecandidate', function (t) { return t.candidate && Object.defineProperty(t, 'candidate', { value: new e.RTCIceCandidate(t.candidate), writable: 'false' }), t }) }, r.shimMaxMessageSize = function (e) { if (e.RTCSctpTransport || !e.RTCPeerConnection) return; var t = s.detectBrowser(e); 'sctp' in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, 'sctp', { get: function () { return void 0 === this._sctp ? null : this._sctp } }); var r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, c = arguments[0], (u = a.default.splitSections(c.sdp)).shift(), u.some(function (e) { var t = a.default.parseMLine(e); return t && t.kind === 'application' && t.protocol.indexOf('SCTP') !== -1 })) { var e = (function (e) { var t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (t === null || t.length < 2) return -1; var r = parseInt(t[1], 10); return r != r ? -1 : r }(arguments[0])); var n = (function (e) { var r = 65536; t.browser === 'firefox' && (r = t.version < 57 ? e === -1 ? 16384 : 2147483637 : t.version < 60 ? t.version === 57 ? 65535 : 65536 : 2147483637); return r }(e)); var i = (function (e, r) { var n = 65536; t.browser === 'firefox' && t.version === 57 && (n = 65535); var i = a.default.matchPrefix(e.sdp, 'a=max-message-size:'); i.length > 0 ? n = parseInt(i[0].substr(19), 10) : t.browser === 'firefox' && r !== -1 && (n = 2147483637); return n }(arguments[0], e)); var o = void 0; o = n === 0 && i === 0 ? Number.POSITIVE_INFINITY : n === 0 || i === 0 ? Math.max(n, i) : Math.min(n, i); var s = {}; Object.defineProperty(s, 'maxMessageSize', { get: function () { return o } }), this._sctp = s } var c, u; return r.apply(this, arguments) } }, r.shimSendThrowTypeError = function (e) { if (!(e.RTCPeerConnection && 'createDataChannel' in e.RTCPeerConnection.prototype)) return; function t (e, t) { var r = e.send; e.send = function () { var n = arguments[0]; var i = n.length || n.size || n.byteLength; if (e.readyState === 'open' && t.sctp && i > t.sctp.maxMessageSize) throw new TypeError('Message too large (can send a maximum of ' + t.sctp.maxMessageSize + ' bytes)'); return r.apply(e, arguments) } } var r = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { var e = r.apply(this, arguments); return t(e, this), e }, s.wrapPeerConnectionEvent(e, 'datachannel', function (e) { return t(e.channel, e.target), e }) }, r.shimConnectionState = function (e) { if (!e.RTCPeerConnection || 'connectionState' in e.RTCPeerConnection.prototype) return; var t = e.RTCPeerConnection.prototype; Object.defineProperty(t, 'connectionState', { get: function () { return { completed: 'connected', checking: 'connecting' }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, 'onconnectionstatechange', { get: function () { return this._onconnectionstatechange || null }, set: function (e) { this._onconnectionstatechange && (this.removeEventListener('connectionstatechange', this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener('connectionstatechange', this._onconnectionstatechange = e) }, enumerable: !0, configurable: !0 }), ['setLocalDescription', 'setRemoteDescription'].forEach(function (e) { var r = t[e]; t[e] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = function (e) { var t = e.target; if (t._lastConnectionState !== t.connectionState) { t._lastConnectionState = t.connectionState; var r = new Event('connectionstatechange', e); t.dispatchEvent(r) } return e }, this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly)), r.apply(this, arguments) } }) }, r.removeAllowExtmapMixed = function (e) { if (!e.RTCPeerConnection) return; var t = s.detectBrowser(e); if (t.browser === 'chrome' && t.version >= 71) return; var r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (e) { return e && e.sdp && e.sdp.indexOf('\na=extmap-allow-mixed') !== -1 && (e.sdp = e.sdp.split('\n').filter(function (e) { return e.trim() !== 'a=extmap-allow-mixed' }).join('\n')), r.apply(this, arguments) } }; var i; var o = e('sdp'); var a = (i = o) && i.__esModule ? i : { default: i }; var s = (function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e('./utils'))) }, { './utils': 11, sdp: 13 }], 7: [function (e, t, r) { Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = r.shimGetUserMedia = void 0; var n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; var i = e('./getusermedia'); Object.defineProperty(r, 'shimGetUserMedia', { enumerable: !0, get: function () { return i.shimGetUserMedia } }); var o = e('./getdisplaymedia'); Object.defineProperty(r, 'shimGetDisplayMedia', { enumerable: !0, get: function () { return o.shimGetDisplayMedia } }), r.shimOnTrack = function (e) { (void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCTrackEvent && 'receiver' in e.RTCTrackEvent.prototype && !('transceiver' in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, 'transceiver', { get: function () { return { receiver: this.receiver } } }) }, r.shimPeerConnection = function (e) { var t = a.detectBrowser(e); if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return; !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection); ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (t) { var r = e.RTCPeerConnection.prototype[t]; e.RTCPeerConnection.prototype[t] = function () { return arguments[0] = new (t === 'addIceCandidate' ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), r.apply(this, arguments) } }); var r = e.RTCPeerConnection.prototype.addIceCandidate; e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }; var i = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }; var o = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function (e, r, n) { return o.apply(this, [e || null]).then(function (e) { if (t.version < 53 && !r) try { e.forEach(function (e) { e.type = i[e.type] || e.type }) } catch (t) { if (t.name !== 'TypeError') throw t; e.forEach(function (t, r) { e.set(r, Object.assign({}, t, { type: i[t.type] || t.type })) }) } return e }).then(r, n) } }, r.shimSenderGetStats = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection || !e.RTCRtpSender) return; if (e.RTCRtpSender && 'getStats' in e.RTCRtpSender.prototype) return; var t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { var e = this; var r = t.apply(this, []); return r.forEach(function (t) { return t._pc = e }), r }); var r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { var e = r.apply(this, arguments); return e._pc = this, e }); e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map()) } }, r.shimReceiverGetStats = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection || !e.RTCRtpSender) return; if (e.RTCRtpSender && 'getStats' in e.RTCRtpReceiver.prototype) return; var t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { var e = this; var r = t.apply(this, []); return r.forEach(function (t) { return t._pc = e }), r }); a.wrapPeerConnectionEvent(e, 'track', function (e) { return e.receiver._pc = e.srcElement, e }), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } }, r.shimRemoveStream = function (e) { if (!e.RTCPeerConnection || 'removeStream' in e.RTCPeerConnection.prototype) return; e.RTCPeerConnection.prototype.removeStream = function (e) { var t = this; a.deprecated('removeStream', 'removeTrack'), this.getSenders().forEach(function (r) { r.track && e.getTracks().includes(r.track) && t.removeTrack(r) }) } }, r.shimRTCDataChannel = function (e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel) }; var a = (function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e('../utils'))) }, { '../utils': 11, './getdisplaymedia': 8, './getusermedia': 9 }], 8: [function (e, t, r) { Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = function (e, t) { if (e.navigator.mediaDevices && 'getDisplayMedia' in e.navigator.mediaDevices) return; if (!e.navigator.mediaDevices) return; e.navigator.mediaDevices.getDisplayMedia = function (r) { if (!r || !r.video) { var n = new DOMException('getDisplayMedia without video constraints is undefined'); return n.name = 'NotFoundError', n.code = 8, Promise.reject(n) } return !0 === r.video ? r.video = { mediaSource: t } : r.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(r) } } }, {}], 9: [function (e, t, r) { Object.defineProperty(r, '__esModule', { value: !0 }); var n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; r.shimGetUserMedia = function (e) { var t = i.detectBrowser(e); var r = e && e.navigator; var o = e && e.MediaStreamTrack; if (r.getUserMedia = function (e, t, n) { i.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia'), r.mediaDevices.getUserMedia(e).then(t, n) }, !(t.version > 55 && 'autoGainControl' in r.mediaDevices.getSupportedConstraints())) { var a = function (e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]) }; var s = r.mediaDevices.getUserMedia.bind(r.mediaDevices); if (r.mediaDevices.getUserMedia = function (e) { return (void 0 === e ? 'undefined' : n(e)) === 'object' && n(e.audio) === 'object' && (e = JSON.parse(JSON.stringify(e)), a(e.audio, 'autoGainControl', 'mozAutoGainControl'), a(e.audio, 'noiseSuppression', 'mozNoiseSuppression')), s(e) }, o && o.prototype.getSettings) { var c = o.prototype.getSettings; o.prototype.getSettings = function () { var e = c.apply(this, arguments); return a(e, 'mozAutoGainControl', 'autoGainControl'), a(e, 'mozNoiseSuppression', 'noiseSuppression'), e } } if (o && o.prototype.applyConstraints) { var u = o.prototype.applyConstraints; o.prototype.applyConstraints = function (e) { return this.kind === 'audio' && (void 0 === e ? 'undefined' : n(e)) === 'object' && (e = JSON.parse(JSON.stringify(e)), a(e, 'autoGainControl', 'mozAutoGainControl'), a(e, 'noiseSuppression', 'mozNoiseSuppression')), u.apply(this, [e]) } } } }; var i = (function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e('../utils'))) }, { '../utils': 11 }], 10: [function (e, t, r) { Object.defineProperty(r, '__esModule', { value: !0 }); var n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; r.shimLocalStreamsAPI = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection) return; 'getLocalStreams' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }); if (!('addStream' in e.RTCPeerConnection.prototype)) { var t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (e) { var r = this; this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getTracks().forEach(function (n) { return t.call(r, n, e) }) }, e.RTCPeerConnection.prototype.addTrack = function (e, r) { return r && (this._localStreams ? this._localStreams.includes(r) || this._localStreams.push(r) : this._localStreams = [r]), t.call(this, e, r) } } 'removeStream' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) { var t = this; this._localStreams || (this._localStreams = []); var r = this._localStreams.indexOf(e); if (r !== -1) { this._localStreams.splice(r, 1); var n = e.getTracks(); this.getSenders().forEach(function (e) { n.includes(e.track) && t.removeTrack(e) }) } }) }, r.shimRemoteStreamsAPI = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection) return; 'getRemoteStreams' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }); if (!('onaddstream' in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, 'onaddstream', { get: function () { return this._onaddstream }, set: function (e) { var t = this; this._onaddstream && (this.removeEventListener('addstream', this._onaddstream), this.removeEventListener('track', this._onaddstreampoly)), this.addEventListener('addstream', this._onaddstream = e), this.addEventListener('track', this._onaddstreampoly = function (e) { e.streams.forEach(function (e) { if (t._remoteStreams || (t._remoteStreams = []), !t._remoteStreams.includes(e)) { t._remoteStreams.push(e); var r = new Event('addstream'); r.stream = e, t.dispatchEvent(r) } }) }) } }); var t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { var e = this; return this._onaddstreampoly || this.addEventListener('track', this._onaddstreampoly = function (t) { t.streams.forEach(function (t) { if (e._remoteStreams || (e._remoteStreams = []), !(e._remoteStreams.indexOf(t) >= 0)) { e._remoteStreams.push(t); var r = new Event('addstream'); r.stream = t, e.dispatchEvent(r) } }) }), t.apply(e, arguments) } } }, r.shimCallbacksAPI = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection) return; var t = e.RTCPeerConnection.prototype; var r = t.createOffer; var i = t.createAnswer; var o = t.setLocalDescription; var a = t.setRemoteDescription; var s = t.addIceCandidate; t.createOffer = function (e, t) { var n = arguments.length >= 2 ? arguments[2] : arguments[0]; var i = r.apply(this, [n]); return t ? (i.then(e, t), Promise.resolve()) : i }, t.createAnswer = function (e, t) { var r = arguments.length >= 2 ? arguments[2] : arguments[0]; var n = i.apply(this, [r]); return t ? (n.then(e, t), Promise.resolve()) : n }; var c = function (e, t, r) { var n = o.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n }; t.setLocalDescription = c, c = function (e, t, r) { var n = a.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n }, t.setRemoteDescription = c, c = function (e, t, r) { var n = s.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n }, t.addIceCandidate = c }, r.shimGetUserMedia = function (e) { var t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { var r = t.mediaDevices; var n = r.getUserMedia.bind(r); t.mediaDevices.getUserMedia = function (e) { return n(o(e)) } } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, r, n) { t.mediaDevices.getUserMedia(e).then(r, n) }) }, r.shimConstraints = o, r.shimRTCIceServerUrls = function (e) { var t = e.RTCPeerConnection; e.RTCPeerConnection = function (e, r) { if (e && e.iceServers) { for (var n = [], o = 0; o < e.iceServers.length; o++) { var a = e.iceServers[o]; !a.hasOwnProperty('urls') && a.hasOwnProperty('url') ? (i.deprecated('RTCIceServer.url', 'RTCIceServer.urls'), (a = JSON.parse(JSON.stringify(a))).urls = a.url, delete a.url, n.push(a)) : n.push(e.iceServers[o]) } e.iceServers = n } return new t(e, r) }, e.RTCPeerConnection.prototype = t.prototype, 'generateCertificate' in e.RTCPeerConnection && Object.defineProperty(e.RTCPeerConnection, 'generateCertificate', { get: function () { return t.generateCertificate } }) }, r.shimTrackEventTransceiver = function (e) { (void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && 'receiver' in e.RTCTrackEvent.prototype && !e.RTCTransceiver && Object.defineProperty(e.RTCTrackEvent.prototype, 'transceiver', { get: function () { return { receiver: this.receiver } } }) }, r.shimCreateOfferLegacy = function (e) { var t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (e) { if (e) { void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio); var r = this.getTransceivers().find(function (e) { return e.sender.track && e.sender.track.kind === 'audio' }); !1 === e.offerToReceiveAudio && r ? r.direction === 'sendrecv' ? r.setDirection ? r.setDirection('sendonly') : r.direction = 'sendonly' : r.direction === 'recvonly' && (r.setDirection ? r.setDirection('inactive') : r.direction = 'inactive') : !0 !== e.offerToReceiveAudio || r || this.addTransceiver('audio'), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo); var n = this.getTransceivers().find(function (e) { return e.sender.track && e.sender.track.kind === 'video' }); !1 === e.offerToReceiveVideo && n ? n.direction === 'sendrecv' ? n.setDirection ? n.setDirection('sendonly') : n.direction = 'sendonly' : n.direction === 'recvonly' && (n.setDirection ? n.setDirection('inactive') : n.direction = 'inactive') : !0 !== e.offerToReceiveVideo || n || this.addTransceiver('video') } return t.apply(this, arguments) } }; var i = (function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e('../utils'))); function o (e) { return e && void 0 !== e.video ? Object.assign({}, e, { video: i.compactObject(e.video) }) : e } }, { '../utils': 11 }], 11: [function (e, t, r) { Object.defineProperty(r, '__esModule', { value: !0 }); var n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; r.extractVersion = a, r.wrapPeerConnectionEvent = function (e, t, r) { if (!e.RTCPeerConnection) return; var n = e.RTCPeerConnection.prototype; var i = n.addEventListener; n.addEventListener = function (e, n) { if (e !== t) return i.apply(this, arguments); var o = function (e) { var t = r(e); t && n(t) }; return this._eventMap = this._eventMap || {}, this._eventMap[n] = o, i.apply(this, [e, o]) }; var o = n.removeEventListener; n.removeEventListener = function (e, r) { if (e !== t || !this._eventMap || !this._eventMap[r]) return o.apply(this, arguments); var n = this._eventMap[r]; return delete this._eventMap[r], o.apply(this, [e, n]) }, Object.defineProperty(n, 'on' + t, { get: function () { return this['_on' + t] }, set: function (e) { this['_on' + t] && (this.removeEventListener(t, this['_on' + t]), delete this['_on' + t]), e && this.addEventListener(t, this['_on' + t] = e) }, enumerable: !0, configurable: !0 }) }, r.disableLog = function (e) { if (typeof e !== 'boolean') return new Error('Argument type: ' + (void 0 === e ? 'undefined' : n(e)) + '. Please use a boolean.'); return i = e, e ? 'adapter.js logging disabled' : 'adapter.js logging enabled' }, r.disableWarnings = function (e) { if (typeof e !== 'boolean') return new Error('Argument type: ' + (void 0 === e ? 'undefined' : n(e)) + '. Please use a boolean.'); return o = !e, 'adapter.js deprecation warnings ' + (e ? 'disabled' : 'enabled') }, r.log = function () { if ((typeof window === 'undefined' ? 'undefined' : n(window)) === 'object') { if (i) return; typeof console !== 'undefined' && typeof console.log === 'function' && console.log.apply(console, arguments) } }, r.deprecated = function (e, t) { if (!o) return; console.warn(e + ' is deprecated, please use ' + t + ' instead.') }, r.detectBrowser = function (e) { var t = e.navigator; var r = { browser: null, version: null }; if (void 0 === e || !e.navigator) return r.browser = 'Not a browser.', r; if (t.mozGetUserMedia) r.browser = 'firefox', r.version = a(t.userAgent, /Firefox\/(\d+)\./, 1); else if (t.webkitGetUserMedia) r.browser = 'chrome', r.version = a(t.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else if (t.mediaDevices && t.userAgent.match(/Edge\/(\d+).(\d+)$/)) r.browser = 'edge', r.version = a(t.userAgent, /Edge\/(\d+).(\d+)$/, 2); else { if (!e.RTCPeerConnection || !t.userAgent.match(/AppleWebKit\/(\d+)\./)) return r.browser = 'Not a supported browser.', r; r.browser = 'safari', r.version = a(t.userAgent, /AppleWebKit\/(\d+)\./, 1) } return r }, r.compactObject = function e (t) { if ((void 0 === t ? 'undefined' : n(t)) !== 'object') return t; return Object.keys(t).reduce(function (r, i) { var o = n(t[i]) === 'object'; var a = o ? e(t[i]) : t[i]; var s = o && !Object.keys(a).length; return void 0 === a || s ? r : Object.assign(r, (function (e, t, r) { t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r; return e }({}, i, a))) }, {}) }; var i = !0; var o = !0; function a (e, t, r) { var n = e.match(t); return n && n.length >= r && parseInt(n[r], 10) } }, {}], 12: [function (e, t, r) { }, {}], 13: [function (e, t, r) { var n = { generateIdentifier: function () { return Math.random().toString(36).substr(2, 10) } }; n.localCName = n.generateIdentifier(), n.splitLines = function (e) { return e.trim().split('\n').map(function (e) { return e.trim() }) }, n.splitSections = function (e) { return e.split('\nm=').map(function (e, t) { return (t > 0 ? 'm=' + e : e).trim() + '\r\n' }) }, n.getDescription = function (e) { var t = n.splitSections(e); return t && t[0] }, n.getMediaSections = function (e) { var t = n.splitSections(e); return t.shift(), t }, n.matchPrefix = function (e, t) { return n.splitLines(e).filter(function (e) { return e.indexOf(t) === 0 }) }, n.parseCandidate = function (e) { for (var t, r = { foundation: (t = e.indexOf('a=candidate:') === 0 ? e.substring(12).split(' ') : e.substring(10).split(' '))[0], component: parseInt(t[1], 10), protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], address: t[4], port: parseInt(t[5], 10), type: t[7] }, n = 8; n < t.length; n += 2) switch (t[n]) { case 'raddr': r.relatedAddress = t[n + 1]; break; case 'rport': r.relatedPort = parseInt(t[n + 1], 10); break; case 'tcptype': r.tcpType = t[n + 1]; break; case 'ufrag': r.ufrag = t[n + 1], r.usernameFragment = t[n + 1]; break; default: r[t[n]] = t[n + 1] } return r }, n.writeCandidate = function (e) { var t = []; t.push(e.foundation), t.push(e.component), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port); var r = e.type; return t.push('typ'), t.push(r), r !== 'host' && e.relatedAddress && e.relatedPort && (t.push('raddr'), t.push(e.relatedAddress), t.push('rport'), t.push(e.relatedPort)), e.tcpType && e.protocol.toLowerCase() === 'tcp' && (t.push('tcptype'), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push('ufrag'), t.push(e.usernameFragment || e.ufrag)), 'candidate:' + t.join(' ') }, n.parseIceOptions = function (e) { return e.substr(14).split(' ') }, n.parseRtpMap = function (e) { var t = e.substr(9).split(' '); var r = { payloadType: parseInt(t.shift(), 10) }; return t = t[0].split('/'), r.name = t[0], r.clockRate = parseInt(t[1], 10), r.channels = t.length === 3 ? parseInt(t[2], 10) : 1, r.numChannels = r.channels, r }, n.writeRtpMap = function (e) { var t = e.payloadType; void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType); var r = e.channels || e.numChannels || 1; return 'a=rtpmap:' + t + ' ' + e.name + '/' + e.clockRate + (r !== 1 ? '/' + r : '') + '\r\n' }, n.parseExtmap = function (e) { var t = e.substr(9).split(' '); return { id: parseInt(t[0], 10), direction: t[0].indexOf('/') > 0 ? t[0].split('/')[1] : 'sendrecv', uri: t[1] } }, n.writeExtmap = function (e) { return 'a=extmap:' + (e.id || e.preferredId) + (e.direction && e.direction !== 'sendrecv' ? '/' + e.direction : '') + ' ' + e.uri + '\r\n' }, n.parseFmtp = function (e) { for (var t, r = {}, n = e.substr(e.indexOf(' ') + 1).split(';'), i = 0; i < n.length; i++)r[(t = n[i].trim().split('='))[0].trim()] = t[1]; return r }, n.writeFmtp = function (e) { var t = ''; var r = e.payloadType; if (void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) { var n = []; Object.keys(e.parameters).forEach(function (t) { e.parameters[t] ? n.push(t + '=' + e.parameters[t]) : n.push(t) }), t += 'a=fmtp:' + r + ' ' + n.join(';') + '\r\n' } return t }, n.parseRtcpFb = function (e) { var t = e.substr(e.indexOf(' ') + 1).split(' '); return { type: t.shift(), parameter: t.join(' ') } }, n.writeRtcpFb = function (e) { var t = ''; var r = e.payloadType; return void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(function (e) { t += 'a=rtcp-fb:' + r + ' ' + e.type + (e.parameter && e.parameter.length ? ' ' + e.parameter : '') + '\r\n' }), t }, n.parseSsrcMedia = function (e) { var t = e.indexOf(' '); var r = { ssrc: parseInt(e.substr(7, t - 7), 10) }; var n = e.indexOf(':', t); return n > -1 ? (r.attribute = e.substr(t + 1, n - t - 1), r.value = e.substr(n + 1)) : r.attribute = e.substr(t + 1), r }, n.parseSsrcGroup = function (e) { var t = e.substr(13).split(' '); return { semantics: t.shift(), ssrcs: t.map(function (e) { return parseInt(e, 10) }) } }, n.getMid = function (e) { var t = n.matchPrefix(e, 'a=mid:')[0]; if (t) return t.substr(6) }, n.parseFingerprint = function (e) { var t = e.substr(14).split(' '); return { algorithm: t[0].toLowerCase(), value: t[1] } }, n.getDtlsParameters = function (e, t) { return { role: 'auto', fingerprints: n.matchPrefix(e + t, 'a=fingerprint:').map(n.parseFingerprint) } }, n.writeDtlsParameters = function (e, t) { var r = 'a=setup:' + t + '\r\n'; return e.fingerprints.forEach(function (e) { r += 'a=fingerprint:' + e.algorithm + ' ' + e.value + '\r\n' }), r }, n.getIceParameters = function (e, t) { var r = n.splitLines(e); return { usernameFragment: (r = r.concat(n.splitLines(t))).filter(function (e) { return e.indexOf('a=ice-ufrag:') === 0 })[0].substr(12), password: r.filter(function (e) { return e.indexOf('a=ice-pwd:') === 0 })[0].substr(10) } }, n.writeIceParameters = function (e) { return 'a=ice-ufrag:' + e.usernameFragment + '\r\na=ice-pwd:' + e.password + '\r\n' }, n.parseRtpParameters = function (e) { for (var t = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r = n.splitLines(e)[0].split(' '), i = 3; i < r.length; i++) { var o = r[i]; var a = n.matchPrefix(e, 'a=rtpmap:' + o + ' ')[0]; if (a) { var s = n.parseRtpMap(a); var c = n.matchPrefix(e, 'a=fmtp:' + o + ' '); switch (s.parameters = c.length ? n.parseFmtp(c[0]) : {}, s.rtcpFeedback = n.matchPrefix(e, 'a=rtcp-fb:' + o + ' ').map(n.parseRtcpFb), t.codecs.push(s), s.name.toUpperCase()) { case 'RED': case 'ULPFEC': t.fecMechanisms.push(s.name.toUpperCase()) } } } return n.matchPrefix(e, 'a=extmap:').forEach(function (e) { t.headerExtensions.push(n.parseExtmap(e)) }), t }, n.writeRtpDescription = function (e, t) { var r = ''; r += 'm=' + e + ' ', r += t.codecs.length > 0 ? '9' : '0', r += ' UDP/TLS/RTP/SAVPF ', r += t.codecs.map(function (e) { return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType }).join(' ') + '\r\n', r += 'c=IN IP4 0.0.0.0\r\n', r += 'a=rtcp:9 IN IP4 0.0.0.0\r\n', t.codecs.forEach(function (e) { r += n.writeRtpMap(e), r += n.writeFmtp(e), r += n.writeRtcpFb(e) }); var i = 0; return t.codecs.forEach(function (e) { e.maxptime > i && (i = e.maxptime) }), i > 0 && (r += 'a=maxptime:' + i + '\r\n'), r += 'a=rtcp-mux\r\n', t.headerExtensions && t.headerExtensions.forEach(function (e) { r += n.writeExtmap(e) }), r }, n.parseRtpEncodingParameters = function (e) { var t; var r = []; var i = n.parseRtpParameters(e); var o = i.fecMechanisms.indexOf('RED') !== -1; var a = i.fecMechanisms.indexOf('ULPFEC') !== -1; var s = n.matchPrefix(e, 'a=ssrc:').map(function (e) { return n.parseSsrcMedia(e) }).filter(function (e) { return e.attribute === 'cname' }); var c = s.length > 0 && s[0].ssrc; var u = n.matchPrefix(e, 'a=ssrc-group:FID').map(function (e) { return e.substr(17).split(' ').map(function (e) { return parseInt(e, 10) }) }); u.length > 0 && u[0].length > 1 && u[0][0] === c && (t = u[0][1]), i.codecs.forEach(function (e) { if (e.name.toUpperCase() === 'RTX' && e.parameters.apt) { var n = { ssrc: c, codecPayloadType: parseInt(e.parameters.apt, 10) }; c && t && (n.rtx = { ssrc: t }), r.push(n), o && ((n = JSON.parse(JSON.stringify(n))).fec = { ssrc: c, mechanism: a ? 'red+ulpfec' : 'red' }, r.push(n)) } }), r.length === 0 && c && r.push({ ssrc: c }); var d = n.matchPrefix(e, 'b='); return d.length && (d = d[0].indexOf('b=TIAS:') === 0 ? parseInt(d[0].substr(7), 10) : d[0].indexOf('b=AS:') === 0 ? 1e3 * parseInt(d[0].substr(5), 10) * 0.95 - 16e3 : void 0, r.forEach(function (e) { e.maxBitrate = d })), r }, n.parseRtcpParameters = function (e) { var t = {}; var r = n.matchPrefix(e, 'a=ssrc:').map(function (e) { return n.parseSsrcMedia(e) }).filter(function (e) { return e.attribute === 'cname' })[0]; r && (t.cname = r.value, t.ssrc = r.ssrc); var i = n.matchPrefix(e, 'a=rtcp-rsize'); t.reducedSize = i.length > 0, t.compound = i.length === 0; var o = n.matchPrefix(e, 'a=rtcp-mux'); return t.mux = o.length > 0, t }, n.parseMsid = function (e) { var t; var r = n.matchPrefix(e, 'a=msid:'); if (r.length === 1) return { stream: (t = r[0].substr(7).split(' '))[0], track: t[1] }; var i = n.matchPrefix(e, 'a=ssrc:').map(function (e) { return n.parseSsrcMedia(e) }).filter(function (e) { return e.attribute === 'msid' }); return i.length > 0 ? { stream: (t = i[0].value.split(' '))[0], track: t[1] } : void 0 }, n.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, n.writeSessionBoilerplate = function (e, t, r) { var i = void 0 !== t ? t : 2; return 'v=0\r\no=' + (r || 'thisisadapterortc') + ' ' + (e || n.generateSessionId()) + ' ' + i + ' IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n' }, n.writeMediaSection = function (e, t, r, i) { var o = n.writeRtpDescription(e.kind, t); if (o += n.writeIceParameters(e.iceGatherer.getLocalParameters()), o += n.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), r === 'offer' ? 'actpass' : 'active'), o += 'a=mid:' + e.mid + '\r\n', e.direction ? o += 'a=' + e.direction + '\r\n' : e.rtpSender && e.rtpReceiver ? o += 'a=sendrecv\r\n' : e.rtpSender ? o += 'a=sendonly\r\n' : e.rtpReceiver ? o += 'a=recvonly\r\n' : o += 'a=inactive\r\n', e.rtpSender) { var a = 'msid:' + i.id + ' ' + e.rtpSender.track.id + '\r\n'; o += 'a=' + a, o += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' ' + a, e.sendEncodingParameters[0].rtx && (o += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' ' + a, o += 'a=ssrc-group:FID ' + e.sendEncodingParameters[0].ssrc + ' ' + e.sendEncodingParameters[0].rtx.ssrc + '\r\n') } return o += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' cname:' + n.localCName + '\r\n', e.rtpSender && e.sendEncodingParameters[0].rtx && (o += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' cname:' + n.localCName + '\r\n'), o }, n.getDirection = function (e, t) { for (var r = n.splitLines(e), i = 0; i < r.length; i++) switch (r[i]) { case 'a=sendrecv': case 'a=sendonly': case 'a=recvonly': case 'a=inactive': return r[i].substr(2) } return t ? n.getDirection(t) : 'sendrecv' }, n.getKind = function (e) { return n.splitLines(e)[0].split(' ')[0].substr(2) }, n.isRejected = function (e) { return e.split(' ', 2)[1] === '0' }, n.parseMLine = function (e) { var t = n.splitLines(e)[0].substr(2).split(' '); return { kind: t[0], port: parseInt(t[1], 10), protocol: t[2], fmt: t.slice(3).join(' ') } }, n.parseOLine = function (e) { var t = n.matchPrefix(e, 'o=')[0].substr(2).split(' '); return { username: t[0], sessionId: t[1], sessionVersion: parseInt(t[2], 10), netType: t[3], addressType: t[4], address: t[5] } }, n.isValidSDP = function (e) { if (typeof e !== 'string' || e.length === 0) return !1; for (var t = n.splitLines(e), r = 0; r < t.length; r++) if (t[r].length < 2 || t[r].charAt(1) !== '=') return !1; return !0 }, typeof t === 'object' && (t.exports = n) }, {}] }, {}, [1]) }); (w = C) && w.__esModule && Object.prototype.hasOwnProperty.call(w, 'default') && w.default; var E = l(function (e) { !(function (t) { function r () { } var n = r.prototype; var i = t.EventEmitter; function o (e, t) { for (var r = e.length; r--;) if (e[r].listener === t) return r; return -1 } function a (e) { return function () { return this[e].apply(this, arguments) } } n.getListeners = function (e) { var t; var r; var n = this._getEvents(); if (e instanceof RegExp) for (r in t = {}, n) n.hasOwnProperty(r) && e.test(r) && (t[r] = n[r]); else t = n[e] || (n[e] = []); return t }, n.flattenListeners = function (e) { var t; var r = []; for (t = 0; t < e.length; t += 1)r.push(e[t].listener); return r }, n.getListenersAsObject = function (e) { var t; var r = this.getListeners(e); return r instanceof Array && ((t = {})[e] = r), t || r }, n.addListener = function (e, t) { if (!(function e (t) { return typeof t === 'function' || t instanceof RegExp || !(!t || typeof t !== 'object') && e(t.listener) }(t))) throw new TypeError('listener must be a function'); var r; var n = this.getListenersAsObject(e); var i = typeof t === 'object'; for (r in n) n.hasOwnProperty(r) && o(n[r], t) === -1 && n[r].push(i ? t : { listener: t, once: !1 }); return this }, n.on = a('addListener'), n.addOnceListener = function (e, t) { return this.addListener(e, { listener: t, once: !0 }) }, n.once = a('addOnceListener'), n.defineEvent = function (e) { return this.getListeners(e), this }, n.defineEvents = function (e) { for (var t = 0; t < e.length; t += 1) this.defineEvent(e[t]); return this }, n.removeListener = function (e, t) { var r; var n; var i = this.getListenersAsObject(e); for (n in i) i.hasOwnProperty(n) && (r = o(i[n], t)) !== -1 && i[n].splice(r, 1); return this }, n.off = a('removeListener'), n.addListeners = function (e, t) { return this.manipulateListeners(!1, e, t) }, n.removeListeners = function (e, t) { return this.manipulateListeners(!0, e, t) }, n.manipulateListeners = function (e, t, r) { var n; var i; var o = e ? this.removeListener : this.addListener; var a = e ? this.removeListeners : this.addListeners; if (typeof t !== 'object' || t instanceof RegExp) for (n = r.length; n--;)o.call(this, t, r[n]); else for (n in t) t.hasOwnProperty(n) && (i = t[n]) && (typeof i === 'function' ? o.call(this, n, i) : a.call(this, n, i)); return this }, n.removeEvent = function (e) { var t; var r = typeof e; var n = this._getEvents(); if (r === 'string') delete n[e]; else if (e instanceof RegExp) for (t in n) n.hasOwnProperty(t) && e.test(t) && delete n[t]; else delete this._events; return this }, n.removeAllListeners = a('removeEvent'), n.emitEvent = function (e, t) { var r; var n; var i; var o; var a = this.getListenersAsObject(e); for (o in a) if (a.hasOwnProperty(o)) for (r = a[o].slice(0), i = 0; i < r.length; i++)!0 === (n = r[i]).once && this.removeListener(e, n.listener), n.listener.apply(this, t || []) === this._getOnceReturnValue() && this.removeListener(e, n.listener); return this }, n.trigger = a('emitEvent'), n.emit = function (e) { var t = Array.prototype.slice.call(arguments, 1); return this.emitEvent(e, t) }, n.setOnceReturnValue = function (e) { return this._onceReturnValue = e, this }, n._getOnceReturnValue = function () { return !this.hasOwnProperty('_onceReturnValue') || this._onceReturnValue }, n._getEvents = function () { return this._events || (this._events = {}) }, r.noConflict = function () { return t.EventEmitter = i, r }, e.exports ? e.exports = r : t.EventEmitter = r }(typeof window !== 'undefined' ? window : u || {})) }); var R = l(function (e, t) { var r = 200; var n = 'Expected a function'; var i = '__lodash_hash_undefined__'; var o = 1; var a = 2; var s = 1 / 0; var c = 9007199254740991; var d = '[object Arguments]'; var l = '[object Array]'; var h = '[object Boolean]'; var f = '[object Date]'; var p = '[object Error]'; var m = '[object Function]'; var v = '[object GeneratorFunction]'; var g = '[object Map]'; var y = '[object Number]'; var b = '[object Object]'; var k = '[object RegExp]'; var _ = '[object Set]'; var S = '[object String]'; var T = '[object Symbol]'; var w = '[object ArrayBuffer]'; var C = '[object DataView]'; var E = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/; var R = /^\w*$/; var I = /^\./; var P = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g; var A = /\\(\\)?/g; var M = /^\[object .+?Constructor\]$/; var x = /^(?:0|[1-9]\d*)$/; var O = {}; O['[object Float32Array]'] = O['[object Float64Array]'] = O['[object Int8Array]'] = O['[object Int16Array]'] = O['[object Int32Array]'] = O['[object Uint8Array]'] = O['[object Uint8ClampedArray]'] = O['[object Uint16Array]'] = O['[object Uint32Array]'] = !0, O[d] = O[l] = O[w] = O[h] = O[C] = O[f] = O[p] = O[m] = O[g] = O[y] = O[b] = O[k] = O[_] = O[S] = O['[object WeakMap]'] = !1; var D = typeof u === 'object' && u && u.Object === Object && u; var L = typeof self === 'object' && self && self.Object === Object && self; var j = D || L || Function('return this')(); var N = t && !t.nodeType && t; var B = N && e && !e.nodeType && e; var F = B && B.exports === N && D.process; var U = (function () { try { return F && F.binding('util') } catch (e) { } }()); var $ = U && U.isTypedArray; function V (e, t) { return !!(e ? e.length : 0) && (function (e, t, r) { if (t != t) return (function (e, t, r, n) { var i = e.length; var o = r + (n ? 1 : -1); for (; n ? o-- : ++o < i;) if (t(e[o], o, e)) return o; return -1 }(e, H, r)); var n = r - 1; var i = e.length; for (; ++n < i;) if (e[n] === t) return n; return -1 }(e, t, 0)) > -1 } function G (e, t, r) { for (var n = -1, i = e ? e.length : 0; ++n < i;) if (r(t, e[n])) return !0; return !1 } function W (e, t) { for (var r = -1, n = e ? e.length : 0; ++r < n;) if (t(e[r], r, e)) return !0; return !1 } function H (e) { return e != e } function z (e, t) { return e.has(t) } function J (e) { var t = !1; if (e != null && typeof e.toString !== 'function') try { t = !!(e + '') } catch (e) { } return t } function q (e) { var t = -1; var r = Array(e.size); return e.forEach(function (e, n) { r[++t] = [n, e] }), r } function X (e) { var t = -1; var r = Array(e.size); return e.forEach(function (e) { r[++t] = e }), r } var Q; var K; var Z; var Y = Array.prototype; var ee = Function.prototype; var te = Object.prototype; var re = j['__core-js_shared__']; var ne = (Q = /[^.]+$/.exec(re && re.keys && re.keys.IE_PROTO || '')) ? 'Symbol(src)_1.' + Q : ''; var ie = ee.toString; var oe = te.hasOwnProperty; var ae = te.toString; var se = RegExp('^' + ie.call(oe).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'); var ce = j.Symbol; var ue = j.Uint8Array; var de = te.propertyIsEnumerable; var le = Y.splice; var he = (K = Object.keys, Z = Object, function (e) { return K(Z(e)) }); var fe = We(j, 'DataView'); var pe = We(j, 'Map'); var me = We(j, 'Promise'); var ve = We(j, 'Set'); var ge = We(j, 'WeakMap'); var ye = We(Object, 'create'); var be = Ze(fe); var ke = Ze(pe); var _e = Ze(me); var Se = Ze(ve); var Te = Ze(ge); var we = ce ? ce.prototype : void 0; var Ce = we ? we.valueOf : void 0; var Ee = we ? we.toString : void 0; function Re (e) { var t = -1; var r = e ? e.length : 0; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function Ie (e) { var t = -1; var r = e ? e.length : 0; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function Pe (e) { var t = -1; var r = e ? e.length : 0; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function Ae (e) { var t = -1; var r = e ? e.length : 0; for (this.__data__ = new Pe(); ++t < r;) this.add(e[t]) } function Me (e) { this.__data__ = new Ie(e) } function xe (e, t) { var r = rt(e) || tt(e) ? (function (e, t) { for (var r = -1, n = Array(e); ++r < e;)n[r] = t(r); return n }(e.length, String)) : []; var n = r.length; var i = !!n; for (var o in e) !t && !oe.call(e, o) || i && (o == 'length' || ze(o, n)) || r.push(o); return r } function Oe (e, t) { for (var r = e.length; r--;) if (et(e[r][0], t)) return r; return -1 } function De (e, t) { for (var r = 0, n = (t = Je(t, e) ? [t] : Ue(t)).length; e != null && r < n;)e = e[Ke(t[r++])]; return r && r == n ? e : void 0 } function Le (e, t) { return e != null && t in Object(e) } function je (e, t, r, n, i) { return e === t || (e == null || t == null || !at(e) && !st(t) ? e != e && t != t : (function (e, t, r, n, i, s) { var c = rt(e); var u = rt(t); var m = l; var v = l; c || (m = (m = He(e)) == d ? b : m); u || (v = (v = He(t)) == d ? b : v); var E = m == b && !J(e); var R = v == b && !J(t); var I = m == v; if (I && !E) return s || (s = new Me()), c || ut(e) ? Ve(e, t, r, n, i, s) : (function (e, t, r, n, i, s, c) { switch (r) { case C: if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1; e = e.buffer, t = t.buffer; case w: return !(e.byteLength != t.byteLength || !n(new ue(e), new ue(t))); case h: case f: case y: return et(+e, +t); case p: return e.name == t.name && e.message == t.message; case k: case S: return e == t + ''; case g: var u = q; case _: var d = s & a; if (u || (u = X), e.size != t.size && !d) return !1; var l = c.get(e); if (l) return l == t; s |= o, c.set(e, t); var m = Ve(u(e), u(t), n, i, s, c); return c.delete(e), m; case T: if (Ce) return Ce.call(e) == Ce.call(t) } return !1 }(e, t, m, r, n, i, s)); if (!(i & a)) { var P = E && oe.call(e, '__wrapped__'); var A = R && oe.call(t, '__wrapped__'); if (P || A) { var M = P ? e.value() : e; var x = A ? t.value() : t; return s || (s = new Me()), r(M, x, n, i, s) } } if (!I) return !1; return s || (s = new Me()), (function (e, t, r, n, i, o) { var s = i & a; var c = dt(e); var u = c.length; var d = dt(t).length; if (u != d && !s) return !1; for (var l = u; l--;) { var h = c[l]; if (!(s ? h in t : oe.call(t, h))) return !1 } var f = o.get(e); if (f && o.get(t)) return f == t; var p = !0; o.set(e, t), o.set(t, e); for (var m = s; ++l < u;) { h = c[l]; var v = e[h]; var g = t[h]; if (n) var y = s ? n(g, v, h, t, e, o) : n(v, g, h, e, t, o); if (!(void 0 === y ? v === g || r(v, g, n, i, o) : y)) { p = !1; break } m || (m = h == 'constructor') } if (p && !m) { var b = e.constructor; var k = t.constructor; b != k && 'constructor' in e && 'constructor' in t && !(typeof b === 'function' && b instanceof b && typeof k === 'function' && k instanceof k) && (p = !1) } return o.delete(e), o.delete(t), p }(e, t, r, n, i, s)) }(e, t, je, r, n, i))) } function Ne (e) { return !(!at(e) || (t = e, ne && ne in t)) && (it(e) || J(e) ? se : M).test(Ze(e)); var t } function Be (e) { return typeof e === 'function' ? e : e == null ? lt : typeof e === 'object' ? rt(e) ? (function (e, t) { if (Je(e) && qe(t)) return Xe(Ke(e), t); return function (r) { var n = (function (e, t, r) { var n = e == null ? void 0 : De(e, t); return void 0 === n ? r : n }(r, e)); return void 0 === n && n === t ? (function (e, t) { return e != null && (function (e, t, r) { t = Je(t, e) ? [t] : Ue(t); var n; var i = -1; var o = t.length; for (; ++i < o;) { var a = Ke(t[i]); if (!(n = e != null && r(e, a))) break; e = e[a] } if (n) return n; return !!(o = e ? e.length : 0) && ot(o) && ze(a, o) && (rt(e) || tt(e)) }(e, t, Le)) }(r, e)) : je(t, n, void 0, o | a) } }(e[0], e[1])) : (function (e) { var t = (function (e) { var t = dt(e); var r = t.length; for (; r--;) { var n = t[r]; var i = e[n]; t[r] = [n, i, qe(i)] } return t }(e)); if (t.length == 1 && t[0][2]) return Xe(t[0][0], t[0][1]); return function (r) { return r === e || (function (e, t, r, n) { var i = r.length; var s = i; var c = !n; if (e == null) return !s; for (e = Object(e); i--;) { var u = r[i]; if (c && u[2] ? u[1] !== e[u[0]] : !(u[0] in e)) return !1 } for (; ++i < s;) { var d = (u = r[i])[0]; var l = e[d]; var h = u[1]; if (c && u[2]) { if (void 0 === l && !(d in e)) return !1 } else { var f = new Me(); if (n) var p = n(l, h, d, e, t, f); if (!(void 0 === p ? je(h, l, n, o | a, f) : p)) return !1 } } return !0 }(r, e, t)) } }(e)) : Je(t = e) ? (r = Ke(t), function (e) { return e == null ? void 0 : e[r] }) : (function (e) { return function (t) { return De(t, e) } }(t)); var t, r } function Fe (e) { if (r = (t = e) && t.constructor, n = typeof r === 'function' && r.prototype || te, t !== n) return he(e); var t; var r; var n; var i = []; for (var o in Object(e)) oe.call(e, o) && o != 'constructor' && i.push(o); return i } function Ue (e) { return rt(e) ? e : Qe(e) } Re.prototype.clear = function () { this.__data__ = ye ? ye(null) : {} }, Re.prototype.delete = function (e) { return this.has(e) && delete this.__data__[e] }, Re.prototype.get = function (e) { var t = this.__data__; if (ye) { var r = t[e]; return r === i ? void 0 : r } return oe.call(t, e) ? t[e] : void 0 }, Re.prototype.has = function (e) { var t = this.__data__; return ye ? void 0 !== t[e] : oe.call(t, e) }, Re.prototype.set = function (e, t) { return this.__data__[e] = ye && void 0 === t ? i : t, this }, Ie.prototype.clear = function () { this.__data__ = [] }, Ie.prototype.delete = function (e) { var t = this.__data__; var r = Oe(t, e); return !(r < 0 || (r == t.length - 1 ? t.pop() : le.call(t, r, 1), 0)) }, Ie.prototype.get = function (e) { var t = this.__data__; var r = Oe(t, e); return r < 0 ? void 0 : t[r][1] }, Ie.prototype.has = function (e) { return Oe(this.__data__, e) > -1 }, Ie.prototype.set = function (e, t) { var r = this.__data__; var n = Oe(r, e); return n < 0 ? r.push([e, t]) : r[n][1] = t, this }, Pe.prototype.clear = function () { this.__data__ = { hash: new Re(), map: new (pe || Ie)(), string: new Re() } }, Pe.prototype.delete = function (e) { return Ge(this, e).delete(e) }, Pe.prototype.get = function (e) { return Ge(this, e).get(e) }, Pe.prototype.has = function (e) { return Ge(this, e).has(e) }, Pe.prototype.set = function (e, t) { return Ge(this, e).set(e, t), this }, Ae.prototype.add = Ae.prototype.push = function (e) { return this.__data__.set(e, i), this }, Ae.prototype.has = function (e) { return this.__data__.has(e) }, Me.prototype.clear = function () { this.__data__ = new Ie() }, Me.prototype.delete = function (e) { return this.__data__.delete(e) }, Me.prototype.get = function (e) { return this.__data__.get(e) }, Me.prototype.has = function (e) { return this.__data__.has(e) }, Me.prototype.set = function (e, t) { var n = this.__data__; if (n instanceof Ie) { var i = n.__data__; if (!pe || i.length < r - 1) return i.push([e, t]), this; n = this.__data__ = new Pe(i) } return n.set(e, t), this }; var $e = ve && 1 / X(new ve([, -0]))[1] == s ? function (e) { return new ve(e) } : function () { }; function Ve (e, t, r, n, i, s) { var c = i & a; var u = e.length; var d = t.length; if (u != d && !(c && d > u)) return !1; var l = s.get(e); if (l && s.get(t)) return l == t; var h = -1; var f = !0; var p = i & o ? new Ae() : void 0; for (s.set(e, t), s.set(t, e); ++h < u;) { var m = e[h]; var v = t[h]; if (n) var g = c ? n(v, m, h, t, e, s) : n(m, v, h, e, t, s); if (void 0 !== g) { if (g) continue; f = !1; break } if (p) { if (!W(t, function (e, t) { if (!p.has(t) && (m === e || r(m, e, n, i, s))) return p.add(t) })) { f = !1; break } } else if (m !== v && !r(m, v, n, i, s)) { f = !1; break } } return s.delete(e), s.delete(t), f } function Ge (e, t) { var r; var n; var i = e.__data__; return ((n = typeof (r = t)) == 'string' || n == 'number' || n == 'symbol' || n == 'boolean' ? r !== '__proto__' : r === null) ? i[typeof t === 'string' ? 'string' : 'hash'] : i.map } function We (e, t) { var r = (function (e, t) { return e == null ? void 0 : e[t] }(e, t)); return Ne(r) ? r : void 0 } var He = function (e) { return ae.call(e) }; function ze (e, t) { return !!(t = t == null ? c : t) && (typeof e === 'number' || x.test(e)) && e > -1 && e % 1 == 0 && e < t } function Je (e, t) { if (rt(e)) return !1; var r = typeof e; return !(r != 'number' && r != 'symbol' && r != 'boolean' && e != null && !ct(e)) || (R.test(e) || !E.test(e) || t != null && e in Object(t)) } function qe (e) { return e == e && !at(e) } function Xe (e, t) { return function (r) { return r != null && (r[e] === t && (void 0 !== t || e in Object(r))) } } (fe && He(new fe(new ArrayBuffer(1))) != C || pe && He(new pe()) != g || me && He(me.resolve()) != '[object Promise]' || ve && He(new ve()) != _ || ge && He(new ge()) != '[object WeakMap]') && (He = function (e) { var t = ae.call(e); var r = t == b ? e.constructor : void 0; var n = r ? Ze(r) : void 0; if (n) switch (n) { case be: return C; case ke: return g; case _e: return '[object Promise]'; case Se: return _; case Te: return '[object WeakMap]' } return t }); var Qe = Ye(function (e) { var t; e = (t = e) == null ? '' : (function (e) { if (typeof e === 'string') return e; if (ct(e)) return Ee ? Ee.call(e) : ''; var t = e + ''; return t == '0' && 1 / e == -s ? '-0' : t }(t)); var r = []; return I.test(e) && r.push(''), e.replace(P, function (e, t, n, i) { r.push(n ? i.replace(A, '$1') : t || e) }), r }); function Ke (e) { if (typeof e === 'string' || ct(e)) return e; var t = e + ''; return t == '0' && 1 / e == -s ? '-0' : t } function Ze (e) { if (e != null) { try { return ie.call(e) } catch (e) { } try { return e + '' } catch (e) { } } return '' } function Ye (e, t) { if (typeof e !== 'function' || t && typeof t !== 'function') throw new TypeError(n); var r = function () { var n = arguments; var i = t ? t.apply(this, n) : n[0]; var o = r.cache; if (o.has(i)) return o.get(i); var a = e.apply(this, n); return r.cache = o.set(i, a), a }; return r.cache = new (Ye.Cache || Pe)(), r } function et (e, t) { return e === t || e != e && t != t } function tt (e) { return (function (e) { return st(e) && nt(e) }(e)) && oe.call(e, 'callee') && (!de.call(e, 'callee') || ae.call(e) == d) } Ye.Cache = Pe; var rt = Array.isArray; function nt (e) { return e != null && ot(e.length) && !it(e) } function it (e) { var t = at(e) ? ae.call(e) : ''; return t == m || t == v } function ot (e) { return typeof e === 'number' && e > -1 && e % 1 == 0 && e <= c } function at (e) { var t = typeof e; return !!e && (t == 'object' || t == 'function') } function st (e) { return !!e && typeof e === 'object' } function ct (e) { return typeof e === 'symbol' || st(e) && ae.call(e) == T } var ut = $ ? (function (e) { return function (t) { return e(t) } }($)) : function (e) { return st(e) && ot(e.length) && !!O[ae.call(e)] }; function dt (e) { return nt(e) ? xe(e) : Fe(e) } function lt (e) { return e } e.exports = function (e, t) { return e && e.length ? (function (e, t, n) { var i = -1; var o = V; var a = e.length; var s = !0; var c = []; var u = c; if (n) s = !1, o = G; else if (a >= r) { var d = t ? null : $e(e); if (d) return X(d); s = !1, o = z, u = new Ae() } else u = t ? [] : c; e: for (; ++i < a;) { var l = e[i]; var h = t ? t(l) : l; if (l = n || l !== 0 ? l : 0, s && h == h) { for (var f = u.length; f--;) if (u[f] === h) continue e; t && u.push(h), c.push(l) } else o(u, h, n) || (u !== c && u.push(h), c.push(l)) } return c }(e, Be(t))) : [] } }); var I = l(function (e, t) { var r = 200; var n = 'Expected a function'; var i = '__lodash_hash_undefined__'; var o = 1; var a = 2; var s = 1 / 0; var c = 9007199254740991; var d = '[object Arguments]'; var l = '[object Array]'; var h = '[object Boolean]'; var f = '[object Date]'; var p = '[object Error]'; var m = '[object Function]'; var v = '[object GeneratorFunction]'; var g = '[object Map]'; var y = '[object Number]'; var b = '[object Object]'; var k = '[object RegExp]'; var _ = '[object Set]'; var S = '[object String]'; var T = '[object Symbol]'; var w = '[object ArrayBuffer]'; var C = '[object DataView]'; var E = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/; var R = /^\w*$/; var I = /^\./; var P = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g; var A = /\\(\\)?/g; var M = /^\[object .+?Constructor\]$/; var x = /^(?:0|[1-9]\d*)$/; var O = {}; O['[object Float32Array]'] = O['[object Float64Array]'] = O['[object Int8Array]'] = O['[object Int16Array]'] = O['[object Int32Array]'] = O['[object Uint8Array]'] = O['[object Uint8ClampedArray]'] = O['[object Uint16Array]'] = O['[object Uint32Array]'] = !0, O[d] = O[l] = O[w] = O[h] = O[C] = O[f] = O[p] = O[m] = O[g] = O[y] = O[b] = O[k] = O[_] = O[S] = O['[object WeakMap]'] = !1; var D = typeof u === 'object' && u && u.Object === Object && u; var L = typeof self === 'object' && self && self.Object === Object && self; var j = D || L || Function('return this')(); var N = t && !t.nodeType && t; var B = N && e && !e.nodeType && e; var F = B && B.exports === N && D.process; var U = (function () { try { return F && F.binding('util') } catch (e) { } }()); var $ = U && U.isTypedArray; function V (e, t) { for (var r = -1, n = e ? e.length : 0; ++r < n;) if (t(e[r], r, e)) return !0; return !1 } function G (e) { var t = !1; if (e != null && typeof e.toString !== 'function') try { t = !!(e + '') } catch (e) { } return t } function W (e) { var t = -1; var r = Array(e.size); return e.forEach(function (e, n) { r[++t] = [n, e] }), r } function H (e) { var t = -1; var r = Array(e.size); return e.forEach(function (e) { r[++t] = e }), r } var z; var J; var q; var X = Array.prototype; var Q = Function.prototype; var K = Object.prototype; var Z = j['__core-js_shared__']; var Y = (z = /[^.]+$/.exec(Z && Z.keys && Z.keys.IE_PROTO || '')) ? 'Symbol(src)_1.' + z : ''; var ee = Q.toString; var te = K.hasOwnProperty; var re = K.toString; var ne = RegExp('^' + ee.call(te).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'); var ie = j.Symbol; var oe = j.Uint8Array; var ae = K.propertyIsEnumerable; var se = X.splice; var ce = (J = Object.keys, q = Object, function (e) { return J(q(e)) }); var ue = Fe(j, 'DataView'); var de = Fe(j, 'Map'); var le = Fe(j, 'Promise'); var he = Fe(j, 'Set'); var fe = Fe(j, 'WeakMap'); var pe = Fe(Object, 'create'); var me = qe(ue); var ve = qe(de); var ge = qe(le); var ye = qe(he); var be = qe(fe); var ke = ie ? ie.prototype : void 0; var _e = ke ? ke.valueOf : void 0; var Se = ke ? ke.toString : void 0; function Te (e) { var t = -1; var r = e ? e.length : 0; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function we (e) { var t = -1; var r = e ? e.length : 0; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function Ce (e) { var t = -1; var r = e ? e.length : 0; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function Ee (e) { var t = -1; var r = e ? e.length : 0; for (this.__data__ = new Ce(); ++t < r;) this.add(e[t]) } function Re (e) { this.__data__ = new we(e) } function Ie (e, t) { var r = Ye(e) || Ze(e) ? (function (e, t) { for (var r = -1, n = Array(e); ++r < e;)n[r] = t(r); return n }(e.length, String)) : []; var n = r.length; var i = !!n; for (var o in e) !t && !te.call(e, o) || i && (o == 'length' || $e(o, n)) || r.push(o); return r } function Pe (e, t) { for (var r = e.length; r--;) if (Ke(e[r][0], t)) return r; return -1 } function Ae (e, t) { for (var r = 0, n = (t = Ve(t, e) ? [t] : je(t)).length; e != null && r < n;)e = e[Je(t[r++])]; return r && r == n ? e : void 0 } function Me (e, t) { return e != null && t in Object(e) } function xe (e, t, r, n, i) { return e === t || (e == null || t == null || !nt(e) && !it(t) ? e != e && t != t : (function (e, t, r, n, i, s) { var c = Ye(e); var u = Ye(t); var m = l; var v = l; c || (m = (m = Ue(e)) == d ? b : m); u || (v = (v = Ue(t)) == d ? b : v); var E = m == b && !G(e); var R = v == b && !G(t); var I = m == v; if (I && !E) return s || (s = new Re()), c || at(e) ? Ne(e, t, r, n, i, s) : (function (e, t, r, n, i, s, c) { switch (r) { case C: if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1; e = e.buffer, t = t.buffer; case w: return !(e.byteLength != t.byteLength || !n(new oe(e), new oe(t))); case h: case f: case y: return Ke(+e, +t); case p: return e.name == t.name && e.message == t.message; case k: case S: return e == t + ''; case g: var u = W; case _: var d = s & a; if (u || (u = H), e.size != t.size && !d) return !1; var l = c.get(e); if (l) return l == t; s |= o, c.set(e, t); var m = Ne(u(e), u(t), n, i, s, c); return c.delete(e), m; case T: if (_e) return _e.call(e) == _e.call(t) } return !1 }(e, t, m, r, n, i, s)); if (!(i & a)) { var P = E && te.call(e, '__wrapped__'); var A = R && te.call(t, '__wrapped__'); if (P || A) { var M = P ? e.value() : e; var x = A ? t.value() : t; return s || (s = new Re()), r(M, x, n, i, s) } } if (!I) return !1; return s || (s = new Re()), (function (e, t, r, n, i, o) { var s = i & a; var c = st(e); var u = c.length; var d = st(t).length; if (u != d && !s) return !1; for (var l = u; l--;) { var h = c[l]; if (!(s ? h in t : te.call(t, h))) return !1 } var f = o.get(e); if (f && o.get(t)) return f == t; var p = !0; o.set(e, t), o.set(t, e); for (var m = s; ++l < u;) { h = c[l]; var v = e[h]; var g = t[h]; if (n) var y = s ? n(g, v, h, t, e, o) : n(v, g, h, e, t, o); if (!(void 0 === y ? v === g || r(v, g, n, i, o) : y)) { p = !1; break } m || (m = h == 'constructor') } if (p && !m) { var b = e.constructor; var k = t.constructor; b != k && 'constructor' in e && 'constructor' in t && !(typeof b === 'function' && b instanceof b && typeof k === 'function' && k instanceof k) && (p = !1) } return o.delete(e), o.delete(t), p }(e, t, r, n, i, s)) }(e, t, xe, r, n, i))) } function Oe (e) { return !(!nt(e) || (t = e, Y && Y in t)) && (tt(e) || G(e) ? ne : M).test(qe(e)); var t } function De (e) { return typeof e === 'function' ? e : e == null ? ct : typeof e === 'object' ? Ye(e) ? (function (e, t) { if (Ve(e) && Ge(t)) return We(Je(e), t); return function (r) { var n = (function (e, t, r) { var n = e == null ? void 0 : Ae(e, t); return void 0 === n ? r : n }(r, e)); return void 0 === n && n === t ? (function (e, t) { return e != null && (function (e, t, r) { t = Ve(t, e) ? [t] : je(t); var n; var i = -1; var o = t.length; for (; ++i < o;) { var a = Je(t[i]); if (!(n = e != null && r(e, a))) break; e = e[a] } if (n) return n; return !!(o = e ? e.length : 0) && rt(o) && $e(a, o) && (Ye(e) || Ze(e)) }(e, t, Me)) }(r, e)) : xe(t, n, void 0, o | a) } }(e[0], e[1])) : (function (e) { var t = (function (e) { var t = st(e); var r = t.length; for (; r--;) { var n = t[r]; var i = e[n]; t[r] = [n, i, Ge(i)] } return t }(e)); if (t.length == 1 && t[0][2]) return We(t[0][0], t[0][1]); return function (r) { return r === e || (function (e, t, r, n) { var i = r.length; var s = i; var c = !n; if (e == null) return !s; for (e = Object(e); i--;) { var u = r[i]; if (c && u[2] ? u[1] !== e[u[0]] : !(u[0] in e)) return !1 } for (; ++i < s;) { var d = (u = r[i])[0]; var l = e[d]; var h = u[1]; if (c && u[2]) { if (void 0 === l && !(d in e)) return !1 } else { var f = new Re(); if (n) var p = n(l, h, d, e, t, f); if (!(void 0 === p ? xe(h, l, n, o | a, f) : p)) return !1 } } return !0 }(r, e, t)) } }(e)) : Ve(t = e) ? (r = Je(t), function (e) { return e == null ? void 0 : e[r] }) : (function (e) { return function (t) { return Ae(t, e) } }(t)); var t, r } function Le (e) { if (r = (t = e) && t.constructor, n = typeof r === 'function' && r.prototype || K, t !== n) return ce(e); var t; var r; var n; var i = []; for (var o in Object(e)) te.call(e, o) && o != 'constructor' && i.push(o); return i } function je (e) { return Ye(e) ? e : ze(e) } function Ne (e, t, r, n, i, s) { var c = i & a; var u = e.length; var d = t.length; if (u != d && !(c && d > u)) return !1; var l = s.get(e); if (l && s.get(t)) return l == t; var h = -1; var f = !0; var p = i & o ? new Ee() : void 0; for (s.set(e, t), s.set(t, e); ++h < u;) { var m = e[h]; var v = t[h]; if (n) var g = c ? n(v, m, h, t, e, s) : n(m, v, h, e, t, s); if (void 0 !== g) { if (g) continue; f = !1; break } if (p) { if (!V(t, function (e, t) { if (!p.has(t) && (m === e || r(m, e, n, i, s))) return p.add(t) })) { f = !1; break } } else if (m !== v && !r(m, v, n, i, s)) { f = !1; break } } return s.delete(e), s.delete(t), f } function Be (e, t) { var r; var n; var i = e.__data__; return ((n = typeof (r = t)) == 'string' || n == 'number' || n == 'symbol' || n == 'boolean' ? r !== '__proto__' : r === null) ? i[typeof t === 'string' ? 'string' : 'hash'] : i.map } function Fe (e, t) { var r = (function (e, t) { return e == null ? void 0 : e[t] }(e, t)); return Oe(r) ? r : void 0 } Te.prototype.clear = function () { this.__data__ = pe ? pe(null) : {} }, Te.prototype.delete = function (e) { return this.has(e) && delete this.__data__[e] }, Te.prototype.get = function (e) { var t = this.__data__; if (pe) { var r = t[e]; return r === i ? void 0 : r } return te.call(t, e) ? t[e] : void 0 }, Te.prototype.has = function (e) { var t = this.__data__; return pe ? void 0 !== t[e] : te.call(t, e) }, Te.prototype.set = function (e, t) { return this.__data__[e] = pe && void 0 === t ? i : t, this }, we.prototype.clear = function () { this.__data__ = [] }, we.prototype.delete = function (e) { var t = this.__data__; var r = Pe(t, e); return !(r < 0 || (r == t.length - 1 ? t.pop() : se.call(t, r, 1), 0)) }, we.prototype.get = function (e) { var t = this.__data__; var r = Pe(t, e); return r < 0 ? void 0 : t[r][1] }, we.prototype.has = function (e) { return Pe(this.__data__, e) > -1 }, we.prototype.set = function (e, t) { var r = this.__data__; var n = Pe(r, e); return n < 0 ? r.push([e, t]) : r[n][1] = t, this }, Ce.prototype.clear = function () { this.__data__ = { hash: new Te(), map: new (de || we)(), string: new Te() } }, Ce.prototype.delete = function (e) { return Be(this, e).delete(e) }, Ce.prototype.get = function (e) { return Be(this, e).get(e) }, Ce.prototype.has = function (e) { return Be(this, e).has(e) }, Ce.prototype.set = function (e, t) { return Be(this, e).set(e, t), this }, Ee.prototype.add = Ee.prototype.push = function (e) { return this.__data__.set(e, i), this }, Ee.prototype.has = function (e) { return this.__data__.has(e) }, Re.prototype.clear = function () { this.__data__ = new we() }, Re.prototype.delete = function (e) { return this.__data__.delete(e) }, Re.prototype.get = function (e) { return this.__data__.get(e) }, Re.prototype.has = function (e) { return this.__data__.has(e) }, Re.prototype.set = function (e, t) { var n = this.__data__; if (n instanceof we) { var i = n.__data__; if (!de || i.length < r - 1) return i.push([e, t]), this; n = this.__data__ = new Ce(i) } return n.set(e, t), this }; var Ue = function (e) { return re.call(e) }; function $e (e, t) { return !!(t = t == null ? c : t) && (typeof e === 'number' || x.test(e)) && e > -1 && e % 1 == 0 && e < t } function Ve (e, t) { if (Ye(e)) return !1; var r = typeof e; return !(r != 'number' && r != 'symbol' && r != 'boolean' && e != null && !ot(e)) || (R.test(e) || !E.test(e) || t != null && e in Object(t)) } function Ge (e) { return e == e && !nt(e) } function We (e, t) { return function (r) { return r != null && (r[e] === t && (void 0 !== t || e in Object(r))) } } function He (e, t) { return t.length == 1 ? e : Ae(e, (function (e, t, r) { var n = -1; var i = e.length; t < 0 && (t = -t > i ? 0 : i + t), (r = r > i ? i : r) < 0 && (r += i), i = t > r ? 0 : r - t >>> 0, t >>>= 0; for (var o = Array(i); ++n < i;)o[n] = e[n + t]; return o }(t, 0, -1))) } (ue && Ue(new ue(new ArrayBuffer(1))) != C || de && Ue(new de()) != g || le && Ue(le.resolve()) != '[object Promise]' || he && Ue(new he()) != _ || fe && Ue(new fe()) != '[object WeakMap]') && (Ue = function (e) { var t = re.call(e); var r = t == b ? e.constructor : void 0; var n = r ? qe(r) : void 0; if (n) switch (n) { case me: return C; case ve: return g; case ge: return '[object Promise]'; case ye: return _; case be: return '[object WeakMap]' } return t }); var ze = Qe(function (e) { var t; e = (t = e) == null ? '' : (function (e) { if (typeof e === 'string') return e; if (ot(e)) return Se ? Se.call(e) : ''; var t = e + ''; return t == '0' && 1 / e == -s ? '-0' : t }(t)); var r = []; return I.test(e) && r.push(''), e.replace(P, function (e, t, n, i) { r.push(n ? i.replace(A, '$1') : t || e) }), r }); function Je (e) { if (typeof e === 'string' || ot(e)) return e; var t = e + ''; return t == '0' && 1 / e == -s ? '-0' : t } function qe (e) { if (e != null) { try { return ee.call(e) } catch (e) { } try { return e + '' } catch (e) { } } return '' } function Xe (e) { var t = e ? e.length : 0; return t ? e[t - 1] : void 0 } function Qe (e, t) { if (typeof e !== 'function' || t && typeof t !== 'function') throw new TypeError(n); var r = function () { var n = arguments; var i = t ? t.apply(this, n) : n[0]; var o = r.cache; if (o.has(i)) return o.get(i); var a = e.apply(this, n); return r.cache = o.set(i, a), a }; return r.cache = new (Qe.Cache || Ce)(), r } function Ke (e, t) { return e === t || e != e && t != t } function Ze (e) { return (function (e) { return it(e) && et(e) }(e)) && te.call(e, 'callee') && (!ae.call(e, 'callee') || re.call(e) == d) } Qe.Cache = Ce; var Ye = Array.isArray; function et (e) { return e != null && rt(e.length) && !tt(e) } function tt (e) { var t = nt(e) ? re.call(e) : ''; return t == m || t == v } function rt (e) { return typeof e === 'number' && e > -1 && e % 1 == 0 && e <= c } function nt (e) { var t = typeof e; return !!e && (t == 'object' || t == 'function') } function it (e) { return !!e && typeof e === 'object' } function ot (e) { return typeof e === 'symbol' || it(e) && re.call(e) == T } var at = $ ? (function (e) { return function (t) { return e(t) } }($)) : function (e) { return it(e) && rt(e.length) && !!O[re.call(e)] }; function st (e) { return et(e) ? Ie(e) : Le(e) } function ct (e) { return e } e.exports = function (e, t) { var r = []; if (!e || !e.length) return r; var n = -1; var i = []; var o = e.length; for (t = De(t); ++n < o;) { var a = e[n]; t(a, n, e) && (r.push(a), i.push(n)) } return (function (e, t) { for (var r = e ? t.length : 0, n = r - 1; r--;) { var i = t[r]; if (r == n || i !== o) { var o = i; if ($e(i)) se.call(e, i, 1); else if (Ve(i, e)) delete e[Je(i)]; else { var a = je(i); var s = He(e, a); s != null && delete s[Je(Xe(a))] } } } }(e, i)), r } }); var P = function (e, t) { if (e == null) return {}; var r; var n; var i = {}; var o = Object.keys(e); for (n = 0; n < o.length; n++)r = o[n], t.indexOf(r) >= 0 || (i[r] = e[r]); return i }; var A = function (e, t) { if (e == null) return {}; var r; var n; var i = P(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (n = 0; n < o.length; n++)r = o[n], t.indexOf(r) >= 0 || Object.prototype.propertyIsEnumerable.call(e, r) && (i[r] = e[r]) } return i }; const M = e => !!e && !!e.audio && e.audio.enabled; const x = e => !!e && !!e.video && e.video.enabled; const O = e => !!e && !!e.screen && e.screen.enabled; var D, L, j, N, B; (D = e.PermissionNameCode || (e.PermissionNameCode = {}))[D.camera = 0] = 'camera', D[D.microphone = 1] = 'microphone', (L = e.PermissionStateCode || (e.PermissionStateCode = {}))[L.prompt = 1] = 'prompt', L[L.denied = 2] = 'denied', L[L.granted = 3] = 'granted', (j = e.NetworkGrade || (e.NetworkGrade = {}))[j.INVALID = -1] = 'INVALID', j[j.EXCELLENT = 1] = 'EXCELLENT', j[j.GOOD = 2] = 'GOOD', j[j.FAIR = 3] = 'FAIR', j[j.POOR = 4] = 'POOR', (N = e.TrackConnectStatus || (e.TrackConnectStatus = {}))[N.Idle = 0] = 'Idle', N[N.Connecting = 1] = 'Connecting', N[N.Connect = 2] = 'Connect', (B = e.TrackSourceType || (e.TrackSourceType = {}))[B.NORMAL = 0] = 'NORMAL', B[B.EXTERNAL = 1] = 'EXTERNAL', B[B.MIXING = 2] = 'MIXING'; const F = { publishUrl: '', height: 720, width: 1080, fps: 25, kbps: 1e3, audioOnly: !1, stretchMode: 'aspectFill' }; var U; (U = e.AudioSourceState || (e.AudioSourceState = {})).IDLE = 'idle', U.LOADING = 'loading', U.PLAY = 'play', U.PAUSE = 'pause', U.END = 'end'; const $ = { Init: 1, UnInit: 2, JoinRoom: 3, MCSAuth: 4, SignalAuth: 5, LeaveRoom: 6, PublisherPC: 7, PublishTracks: 8, UnPublishTracks: 9, SubscriberPC: 10, SubscribeTracks: 11, UnSubscribeTracks: 13, MuteTracks: 14, ICEConnectionState: 15, CallbackStatistics: 16, KickoutUser: 17, RoomStateChanged: 18, AudioDeviceInOut: 19, VideoDeviceInOut: 20, SDKError: 21, ApplicationState: 22, CreateMergeJob: 24, UpdateMergeTracks: 25, StopMerge: 26, AuthorizationStatus: 27, DeviceChanged: 28, DefaultSetting: 29, MediaStatistics: 30, AbnormalDisconnect: 31 }; var V = l(function (e) { var t, r; t = u, r = function () { var e = function (e, t) { e = [e[0] >>> 16, 65535 & e[0], e[1] >>> 16, 65535 & e[1]], t = [t[0] >>> 16, 65535 & t[0], t[1] >>> 16, 65535 & t[1]]; var r = [0, 0, 0, 0]; return r[3] += e[3] + t[3], r[2] += r[3] >>> 16, r[3] &= 65535, r[2] += e[2] + t[2], r[1] += r[2] >>> 16, r[2] &= 65535, r[1] += e[1] + t[1], r[0] += r[1] >>> 16, r[1] &= 65535, r[0] += e[0] + t[0], r[0] &= 65535, [r[0] << 16 | r[1], r[2] << 16 | r[3]] }; var t = function (e, t) { e = [e[0] >>> 16, 65535 & e[0], e[1] >>> 16, 65535 & e[1]], t = [t[0] >>> 16, 65535 & t[0], t[1] >>> 16, 65535 & t[1]]; var r = [0, 0, 0, 0]; return r[3] += e[3] * t[3], r[2] += r[3] >>> 16, r[3] &= 65535, r[2] += e[2] * t[3], r[1] += r[2] >>> 16, r[2] &= 65535, r[2] += e[3] * t[2], r[1] += r[2] >>> 16, r[2] &= 65535, r[1] += e[1] * t[3], r[0] += r[1] >>> 16, r[1] &= 65535, r[1] += e[2] * t[2], r[0] += r[1] >>> 16, r[1] &= 65535, r[1] += e[3] * t[1], r[0] += r[1] >>> 16, r[1] &= 65535, r[0] += e[0] * t[3] + e[1] * t[2] + e[2] * t[1] + e[3] * t[0], r[0] &= 65535, [r[0] << 16 | r[1], r[2] << 16 | r[3]] }; var r = function (e, t) { return (t %= 64) === 32 ? [e[1], e[0]] : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t | e[0] >>> 32 - t] : (t -= 32, [e[1] << t | e[0] >>> 32 - t, e[0] << t | e[1] >>> 32 - t]) }; var n = function (e, t) { return (t %= 64) === 0 ? e : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t] : [e[1] << t - 32, 0] }; var i = function (e, t) { return [e[0] ^ t[0], e[1] ^ t[1]] }; var o = function (e) { return e = i(e, [0, e[0] >>> 1]), e = t(e, [4283543511, 3981806797]), e = i(e, [0, e[0] >>> 1]), e = t(e, [3301882366, 444984403]), e = i(e, [0, e[0] >>> 1]) }; var a = function (a, s) { s = s || 0; for (var c = (a = a || '').length % 16, u = a.length - c, d = [0, s], l = [0, s], h = [0, 0], f = [0, 0], p = [2277735313, 289559509], m = [1291169091, 658871167], v = 0; v < u; v += 16)h = [255 & a.charCodeAt(v + 4) | (255 & a.charCodeAt(v + 5)) << 8 | (255 & a.charCodeAt(v + 6)) << 16 | (255 & a.charCodeAt(v + 7)) << 24, 255 & a.charCodeAt(v) | (255 & a.charCodeAt(v + 1)) << 8 | (255 & a.charCodeAt(v + 2)) << 16 | (255 & a.charCodeAt(v + 3)) << 24], f = [255 & a.charCodeAt(v + 12) | (255 & a.charCodeAt(v + 13)) << 8 | (255 & a.charCodeAt(v + 14)) << 16 | (255 & a.charCodeAt(v + 15)) << 24, 255 & a.charCodeAt(v + 8) | (255 & a.charCodeAt(v + 9)) << 8 | (255 & a.charCodeAt(v + 10)) << 16 | (255 & a.charCodeAt(v + 11)) << 24], h = t(h, p), h = r(h, 31), h = t(h, m), d = i(d, h), d = r(d, 27), d = e(d, l), d = e(t(d, [0, 5]), [0, 1390208809]), f = t(f, m), f = r(f, 33), f = t(f, p), l = i(l, f), l = r(l, 31), l = e(l, d), l = e(t(l, [0, 5]), [0, 944331445]); switch (h = [0, 0], f = [0, 0], c) { case 15: f = i(f, n([0, a.charCodeAt(v + 14)], 48)); case 14: f = i(f, n([0, a.charCodeAt(v + 13)], 40)); case 13: f = i(f, n([0, a.charCodeAt(v + 12)], 32)); case 12: f = i(f, n([0, a.charCodeAt(v + 11)], 24)); case 11: f = i(f, n([0, a.charCodeAt(v + 10)], 16)); case 10: f = i(f, n([0, a.charCodeAt(v + 9)], 8)); case 9: f = i(f, [0, a.charCodeAt(v + 8)]), f = t(f, m), f = r(f, 33), f = t(f, p), l = i(l, f); case 8: h = i(h, n([0, a.charCodeAt(v + 7)], 56)); case 7: h = i(h, n([0, a.charCodeAt(v + 6)], 48)); case 6: h = i(h, n([0, a.charCodeAt(v + 5)], 40)); case 5: h = i(h, n([0, a.charCodeAt(v + 4)], 32)); case 4: h = i(h, n([0, a.charCodeAt(v + 3)], 24)); case 3: h = i(h, n([0, a.charCodeAt(v + 2)], 16)); case 2: h = i(h, n([0, a.charCodeAt(v + 1)], 8)); case 1: h = i(h, [0, a.charCodeAt(v)]), h = t(h, p), h = r(h, 31), h = t(h, m), d = i(d, h) } return d = i(d, [0, a.length]), l = i(l, [0, a.length]), d = e(d, l), l = e(l, d), d = o(d), l = o(l), d = e(d, l), l = e(l, d), ('00000000' + (d[0] >>> 0).toString(16)).slice(-8) + ('00000000' + (d[1] >>> 0).toString(16)).slice(-8) + ('00000000' + (l[0] >>> 0).toString(16)).slice(-8) + ('00000000' + (l[1] >>> 0).toString(16)).slice(-8) }; var s = { preprocessor: null, audio: { timeout: 1e3, excludeIOS11: !0 }, fonts: { swfContainerId: 'fingerprintjs2', swfPath: 'flash/compiled/FontList.swf', userDefinedFonts: [], extendedJsFonts: !1 }, screen: { detectScreenOrientation: !0 }, plugins: { sortPluginsFor: [/palemoon/i], excludeIE: !1 }, extraComponents: [], excludes: { enumerateDevices: !0, pixelRatio: !0, doNotTrack: !0, fontsFlash: !0 }, NOT_AVAILABLE: 'not available', ERROR: 'error', EXCLUDED: 'excluded' }; var c = function (e, t) { if (Array.prototype.forEach && e.forEach === Array.prototype.forEach) e.forEach(t); else if (e.length === +e.length) for (var r = 0, n = e.length; r < n; r++)t(e[r], r, e); else for (var i in e) e.hasOwnProperty(i) && t(e[i], i, e) }; var u = function (e, t) { var r = []; return e == null ? r : Array.prototype.map && e.map === Array.prototype.map ? e.map(t) : (c(e, function (e, n, i) { r.push(t(e, n, i)) }), r) }; var d = function () { return navigator.mediaDevices && navigator.mediaDevices.enumerateDevices }; var l = function (e) { var t = [window.screen.width, window.screen.height]; return e.screen.detectScreenOrientation && t.sort().reverse(), t }; var h = function (e) { if (window.screen.availWidth && window.screen.availHeight) { var t = [window.screen.availHeight, window.screen.availWidth]; return e.screen.detectScreenOrientation && t.sort().reverse(), t } return e.NOT_AVAILABLE }; var f = function (e) { if (navigator.plugins == null) return e.NOT_AVAILABLE; for (var t = [], r = 0, n = navigator.plugins.length; r < n; r++)navigator.plugins[r] && t.push(navigator.plugins[r]); return m(e) && (t = t.sort(function (e, t) { return e.name > t.name ? 1 : e.name < t.name ? -1 : 0 })), u(t, function (e) { var t = u(e, function (e) { return [e.type, e.suffixes] }); return [e.name, e.description, t] }) }; var p = function (e) { var t = []; if (Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(window, 'ActiveXObject') || 'ActiveXObject' in window) { t = u(['AcroPDF.PDF', 'Adodb.Stream', 'AgControl.AgControl', 'DevalVRXCtrl.DevalVRXCtrl.1', 'MacromediaFlashPaper.MacromediaFlashPaper', 'Msxml2.DOMDocument', 'Msxml2.XMLHTTP', 'PDF.PdfCtrl', 'QuickTime.QuickTime', 'QuickTimeCheckObject.QuickTimeCheck.1', 'RealPlayer', 'RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)', 'RealVideo.RealVideo(tm) ActiveX Control (32-bit)', 'Scripting.Dictionary', 'SWCtl.SWCtl', 'Shell.UIHelper', 'ShockwaveFlash.ShockwaveFlash', 'Skype.Detection', 'TDCCtl.TDCCtl', 'WMPlayer.OCX', 'rmocx.RealPlayer G2 Control', 'rmocx.RealPlayer G2 Control.1'], function (t) { try { return new window.ActiveXObject(t), t } catch (t) { return e.ERROR } }) } else t.push(e.NOT_AVAILABLE); return navigator.plugins && (t = t.concat(f(e))), t }; var m = function (e) { for (var t = !1, r = 0, n = e.plugins.sortPluginsFor.length; r < n; r++) { var i = e.plugins.sortPluginsFor[r]; if (navigator.userAgent.match(i)) { t = !0; break } } return t }; var v = function (e) { try { return !!window.sessionStorage } catch (t) { return e.ERROR } }; var g = function (e) { try { return !!window.localStorage } catch (t) { return e.ERROR } }; var y = function (e) { try { return !!window.indexedDB } catch (t) { return e.ERROR } }; var b = function (e) { return navigator.hardwareConcurrency ? navigator.hardwareConcurrency : e.NOT_AVAILABLE }; var k = function (e) { return navigator.cpuClass || e.NOT_AVAILABLE }; var _ = function (e) { return navigator.platform ? navigator.platform : e.NOT_AVAILABLE }; var S = function (e) { return navigator.doNotTrack ? navigator.doNotTrack : navigator.msDoNotTrack ? navigator.msDoNotTrack : window.doNotTrack ? window.doNotTrack : e.NOT_AVAILABLE }; var T = function () { var e; var t = 0; void 0 !== navigator.maxTouchPoints ? t = navigator.maxTouchPoints : void 0 !== navigator.msMaxTouchPoints && (t = navigator.msMaxTouchPoints); try { document.createEvent('TouchEvent'), e = !0 } catch (t) { e = !1 } return [t, e, 'ontouchstart' in window] }; var w = function (e) { var t = []; var r = document.createElement('canvas'); r.width = 2e3, r.height = 200, r.style.display = 'inline'; var n = r.getContext('2d'); return n.rect(0, 0, 10, 10), n.rect(2, 2, 6, 6), t.push('canvas winding:' + (!1 === n.isPointInPath(5, 5, 'evenodd') ? 'yes' : 'no')), n.textBaseline = 'alphabetic', n.fillStyle = '#f60', n.fillRect(125, 1, 62, 20), n.fillStyle = '#069', e.dontUseFakeFontInCanvas ? n.font = '11pt Arial' : n.font = '11pt no-real-font-123', n.fillText('Cwm fjordbank glyphs vext quiz, ', 2, 15), n.fillStyle = 'rgba(102, 204, 0, 0.2)', n.font = '18pt Arial', n.fillText('Cwm fjordbank glyphs vext quiz, ', 4, 45), n.globalCompositeOperation = 'multiply', n.fillStyle = 'rgb(255,0,255)', n.beginPath(), n.arc(50, 50, 50, 0, 2 * Math.PI, !0), n.closePath(), n.fill(), n.fillStyle = 'rgb(0,255,255)', n.beginPath(), n.arc(100, 50, 50, 0, 2 * Math.PI, !0), n.closePath(), n.fill(), n.fillStyle = 'rgb(255,255,0)', n.beginPath(), n.arc(75, 100, 50, 0, 2 * Math.PI, !0), n.closePath(), n.fill(), n.fillStyle = 'rgb(255,0,255)', n.arc(75, 75, 75, 0, 2 * Math.PI, !0), n.arc(75, 75, 25, 0, 2 * Math.PI, !0), n.fill('evenodd'), r.toDataURL && t.push('canvas fp:' + r.toDataURL()), t }; var C = function () { var e; var t = function (t) { return e.clearColor(0, 0, 0, 1), e.enable(e.DEPTH_TEST), e.depthFunc(e.LEQUAL), e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT), '[' + t[0] + ', ' + t[1] + ']' }; if (!(e = B())) return null; var r = []; var n = e.createBuffer(); e.bindBuffer(e.ARRAY_BUFFER, n); var i = new Float32Array([-0.2, -0.9, 0, 0.4, -0.26, 0, 0, 0.732134444, 0]); e.bufferData(e.ARRAY_BUFFER, i, e.STATIC_DRAW), n.itemSize = 3, n.numItems = 3; var o = e.createProgram(); var a = e.createShader(e.VERTEX_SHADER); e.shaderSource(a, 'attribute vec2 attrVertex;varying vec2 varyinTexCoordinate;uniform vec2 uniformOffset;void main(){varyinTexCoordinate=attrVertex+uniformOffset;gl_Position=vec4(attrVertex,0,1);}'), e.compileShader(a); var s = e.createShader(e.FRAGMENT_SHADER); e.shaderSource(s, 'precision mediump float;varying vec2 varyinTexCoordinate;void main() {gl_FragColor=vec4(varyinTexCoordinate,0,1);}'), e.compileShader(s), e.attachShader(o, a), e.attachShader(o, s), e.linkProgram(o), e.useProgram(o), o.vertexPosAttrib = e.getAttribLocation(o, 'attrVertex'), o.offsetUniform = e.getUniformLocation(o, 'uniformOffset'), e.enableVertexAttribArray(o.vertexPosArray), e.vertexAttribPointer(o.vertexPosAttrib, n.itemSize, e.FLOAT, !1, 0, 0), e.uniform2f(o.offsetUniform, 1, 1), e.drawArrays(e.TRIANGLE_STRIP, 0, n.numItems); try { r.push(e.canvas.toDataURL()) } catch (e) { } r.push('extensions:' + (e.getSupportedExtensions() || []).join(';')), r.push('webgl aliased line width range:' + t(e.getParameter(e.ALIASED_LINE_WIDTH_RANGE))), r.push('webgl aliased point size range:' + t(e.getParameter(e.ALIASED_POINT_SIZE_RANGE))), r.push('webgl alpha bits:' + e.getParameter(e.ALPHA_BITS)), r.push('webgl antialiasing:' + (e.getContextAttributes().antialias ? 'yes' : 'no')), r.push('webgl blue bits:' + e.getParameter(e.BLUE_BITS)), r.push('webgl depth bits:' + e.getParameter(e.DEPTH_BITS)), r.push('webgl green bits:' + e.getParameter(e.GREEN_BITS)), r.push('webgl max anisotropy:' + (function (e) { var t = e.getExtension('EXT_texture_filter_anisotropic') || e.getExtension('WEBKIT_EXT_texture_filter_anisotropic') || e.getExtension('MOZ_EXT_texture_filter_anisotropic'); if (t) { var r = e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT); return r === 0 && (r = 2), r } return null }(e))), r.push('webgl max combined texture image units:' + e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS)), r.push('webgl max cube map texture size:' + e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE)), r.push('webgl max fragment uniform vectors:' + e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)), r.push('webgl max render buffer size:' + e.getParameter(e.MAX_RENDERBUFFER_SIZE)), r.push('webgl max texture image units:' + e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)), r.push('webgl max texture size:' + e.getParameter(e.MAX_TEXTURE_SIZE)), r.push('webgl max varying vectors:' + e.getParameter(e.MAX_VARYING_VECTORS)), r.push('webgl max vertex attribs:' + e.getParameter(e.MAX_VERTEX_ATTRIBS)), r.push('webgl max vertex texture image units:' + e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)), r.push('webgl max vertex uniform vectors:' + e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)), r.push('webgl max viewport dims:' + t(e.getParameter(e.MAX_VIEWPORT_DIMS))), r.push('webgl red bits:' + e.getParameter(e.RED_BITS)), r.push('webgl renderer:' + e.getParameter(e.RENDERER)), r.push('webgl shading language version:' + e.getParameter(e.SHADING_LANGUAGE_VERSION)), r.push('webgl stencil bits:' + e.getParameter(e.STENCIL_BITS)), r.push('webgl vendor:' + e.getParameter(e.VENDOR)), r.push('webgl version:' + e.getParameter(e.VERSION)); try { var u = e.getExtension('WEBGL_debug_renderer_info'); u && (r.push('webgl unmasked vendor:' + e.getParameter(u.UNMASKED_VENDOR_WEBGL)), r.push('webgl unmasked renderer:' + e.getParameter(u.UNMASKED_RENDERER_WEBGL))) } catch (e) { } return e.getShaderPrecisionFormat ? (c(['FLOAT', 'INT'], function (t) { c(['VERTEX', 'FRAGMENT'], function (n) { c(['HIGH', 'MEDIUM', 'LOW'], function (i) { c(['precision', 'rangeMin', 'rangeMax'], function (o) { var a = e.getShaderPrecisionFormat(e[n + '_SHADER'], e[i + '_' + t])[o]; o !== 'precision' && (o = 'precision ' + o); var s = ['webgl ', n.toLowerCase(), ' shader ', i.toLowerCase(), ' ', t.toLowerCase(), ' ', o, ':', a].join(''); r.push(s) }) }) }) }), r) : r }; var E = function () { try { var e = B(); var t = e.getExtension('WEBGL_debug_renderer_info'); return e.getParameter(t.UNMASKED_VENDOR_WEBGL) + '~' + e.getParameter(t.UNMASKED_RENDERER_WEBGL) } catch (e) { return null } }; var R = function () { var e = document.createElement('div'); e.innerHTML = '&nbsp;', e.className = 'adsbox'; var t = !1; try { document.body.appendChild(e), t = document.getElementsByClassName('adsbox')[0].offsetHeight === 0, document.body.removeChild(e) } catch (e) { t = !1 } return t }; var I = function () { if (void 0 !== navigator.languages) try { if (navigator.languages[0].substr(0, 2) !== navigator.language.substr(0, 2)) return !0 } catch (e) { return !0 } return !1 }; var P = function () { return window.screen.width < window.screen.availWidth || window.screen.height < window.screen.availHeight }; var A = function () { var e; var t = navigator.userAgent.toLowerCase(); var r = navigator.oscpu; var n = navigator.platform.toLowerCase(); if (e = t.indexOf('windows phone') >= 0 ? 'Windows Phone' : t.indexOf('win') >= 0 ? 'Windows' : t.indexOf('android') >= 0 ? 'Android' : t.indexOf('linux') >= 0 ? 'Linux' : t.indexOf('iphone') >= 0 || t.indexOf('ipad') >= 0 ? 'iOS' : t.indexOf('mac') >= 0 ? 'Mac' : 'Other', ('ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0) && e !== 'Windows Phone' && e !== 'Android' && e !== 'iOS' && e !== 'Other') return !0; if (void 0 !== r) { if ((r = r.toLowerCase()).indexOf('win') >= 0 && e !== 'Windows' && e !== 'Windows Phone') return !0; if (r.indexOf('linux') >= 0 && e !== 'Linux' && e !== 'Android') return !0; if (r.indexOf('mac') >= 0 && e !== 'Mac' && e !== 'iOS') return !0; if ((r.indexOf('win') === -1 && r.indexOf('linux') === -1 && r.indexOf('mac') === -1) != (e === 'Other')) return !0 } return n.indexOf('win') >= 0 && e !== 'Windows' && e !== 'Windows Phone' || ((n.indexOf('linux') >= 0 || n.indexOf('android') >= 0 || n.indexOf('pike') >= 0) && e !== 'Linux' && e !== 'Android' || ((n.indexOf('mac') >= 0 || n.indexOf('ipad') >= 0 || n.indexOf('ipod') >= 0 || n.indexOf('iphone') >= 0) && e !== 'Mac' && e !== 'iOS' || ((n.indexOf('win') === -1 && n.indexOf('linux') === -1 && n.indexOf('mac') === -1) != (e === 'Other') || void 0 === navigator.plugins && e !== 'Windows' && e !== 'Windows Phone'))) }; var M = function () { var e; var t = navigator.userAgent.toLowerCase(); var r = navigator.productSub; if (((e = t.indexOf('firefox') >= 0 ? 'Firefox' : t.indexOf('opera') >= 0 || t.indexOf('opr') >= 0 ? 'Opera' : t.indexOf('chrome') >= 0 ? 'Chrome' : t.indexOf('safari') >= 0 ? 'Safari' : t.indexOf('trident') >= 0 ? 'Internet Explorer' : 'Other') === 'Chrome' || e === 'Safari' || e === 'Opera') && r !== '20030107') return !0; var n; var i = eval.toString().length; if (i === 37 && e !== 'Safari' && e !== 'Firefox' && e !== 'Other') return !0; if (i === 39 && e !== 'Internet Explorer' && e !== 'Other') return !0; if (i === 33 && e !== 'Chrome' && e !== 'Opera' && e !== 'Other') return !0; try { throw 'a' } catch (e) { try { e.toSource(), n = !0 } catch (e) { n = !1 } } return n && e !== 'Firefox' && e !== 'Other' }; var x = function () { var e = document.createElement('canvas'); return !(!e.getContext || !e.getContext('2d')) }; var O = function () { if (!x()) return !1; var e = B(); return !!window.WebGLRenderingContext && !!e }; var D = function () { return navigator.appName === 'Microsoft Internet Explorer' || !(navigator.appName !== 'Netscape' || !/Trident/.test(navigator.userAgent)) }; var L = function () { return void 0 !== window.swfobject }; var j = function () { return window.swfobject.hasFlashPlayerVersion('9.0.0') }; var N = function (e, t) { window.___fp_swf_loaded = function (t) { e(t) }; var r = t.fonts.swfContainerId; !(function (e) { var t = document.createElement('div'); t.setAttribute('id', e.fonts.swfContainerId), document.body.appendChild(t) }()); var n = { onReady: '___fp_swf_loaded' }; window.swfobject.embedSWF(t.fonts.swfPath, r, '1', '1', '9.0.0', !1, n, { allowScriptAccess: 'always', menu: 'false' }, {}) }; var B = function () { var e = document.createElement('canvas'); var t = null; try { t = e.getContext('webgl') || e.getContext('experimental-webgl') } catch (e) { } return t || (t = null), t }; var F = [{ key: 'userAgent', getData: function (e) { e(navigator.userAgent) } }, { key: 'language', getData: function (e, t) { e(navigator.language || navigator.userLanguage || navigator.browserLanguage || navigator.systemLanguage || t.NOT_AVAILABLE) } }, { key: 'colorDepth', getData: function (e, t) { e(window.screen.colorDepth || t.NOT_AVAILABLE) } }, { key: 'deviceMemory', getData: function (e, t) { e(navigator.deviceMemory || t.NOT_AVAILABLE) } }, { key: 'pixelRatio', getData: function (e, t) { e(window.devicePixelRatio || t.NOT_AVAILABLE) } }, { key: 'hardwareConcurrency', getData: function (e, t) { e(b(t)) } }, { key: 'screenResolution', getData: function (e, t) { e(l(t)) } }, { key: 'availableScreenResolution', getData: function (e, t) { e(h(t)) } }, { key: 'timezoneOffset', getData: function (e) { e((new Date()).getTimezoneOffset()) } }, { key: 'timezone', getData: function (e, t) { window.Intl && window.Intl.DateTimeFormat ? e((new window.Intl.DateTimeFormat()).resolvedOptions().timeZone) : e(t.NOT_AVAILABLE) } }, { key: 'sessionStorage', getData: function (e, t) { e(v(t)) } }, { key: 'localStorage', getData: function (e, t) { e(g(t)) } }, { key: 'indexedDb', getData: function (e, t) { e(y(t)) } }, { key: 'addBehavior', getData: function (e) { e(!(!document.body || !document.body.addBehavior)) } }, { key: 'openDatabase', getData: function (e) { e(!!window.openDatabase) } }, { key: 'cpuClass', getData: function (e, t) { e(k(t)) } }, { key: 'platform', getData: function (e, t) { e(_(t)) } }, { key: 'doNotTrack', getData: function (e, t) { e(S(t)) } }, { key: 'plugins', getData: function (e, t) { D() ? t.plugins.excludeIE ? e(t.EXCLUDED) : e(p(t)) : e(f(t)) } }, { key: 'canvas', getData: function (e, t) { x() ? e(w(t)) : e(t.NOT_AVAILABLE) } }, { key: 'webgl', getData: function (e, t) { O() ? e(C()) : e(t.NOT_AVAILABLE) } }, { key: 'webglVendorAndRenderer', getData: function (e) { O() ? e(E()) : e() } }, { key: 'adBlock', getData: function (e) { e(R()) } }, { key: 'hasLiedLanguages', getData: function (e) { e(I()) } }, { key: 'hasLiedResolution', getData: function (e) { e(P()) } }, { key: 'hasLiedOs', getData: function (e) { e(A()) } }, { key: 'hasLiedBrowser', getData: function (e) { e(M()) } }, { key: 'touchSupport', getData: function (e) { e(T()) } }, { key: 'fonts', getData: function (e, t) { var r = ['monospace', 'sans-serif', 'serif']; var n = ['Andale Mono', 'Arial', 'Arial Black', 'Arial Hebrew', 'Arial MT', 'Arial Narrow', 'Arial Rounded MT Bold', 'Arial Unicode MS', 'Bitstream Vera Sans Mono', 'Book Antiqua', 'Bookman Old Style', 'Calibri', 'Cambria', 'Cambria Math', 'Century', 'Century Gothic', 'Century Schoolbook', 'Comic Sans', 'Comic Sans MS', 'Consolas', 'Courier', 'Courier New', 'Geneva', 'Georgia', 'Helvetica', 'Helvetica Neue', 'Impact', 'Lucida Bright', 'Lucida Calligraphy', 'Lucida Console', 'Lucida Fax', 'LUCIDA GRANDE', 'Lucida Handwriting', 'Lucida Sans', 'Lucida Sans Typewriter', 'Lucida Sans Unicode', 'Microsoft Sans Serif', 'Monaco', 'Monotype Corsiva', 'MS Gothic', 'MS Outlook', 'MS PGothic', 'MS Reference Sans Serif', 'MS Sans Serif', 'MS Serif', 'MYRIAD', 'MYRIAD PRO', 'Palatino', 'Palatino Linotype', 'Segoe Print', 'Segoe Script', 'Segoe UI', 'Segoe UI Light', 'Segoe UI Semibold', 'Segoe UI Symbol', 'Tahoma', 'Times', 'Times New Roman', 'Times New Roman PS', 'Trebuchet MS', 'Verdana', 'Wingdings', 'Wingdings 2', 'Wingdings 3']; t.fonts.extendedJsFonts && (n = n.concat(['Abadi MT Condensed Light', 'Academy Engraved LET', 'ADOBE CASLON PRO', 'Adobe Garamond', 'ADOBE GARAMOND PRO', 'Agency FB', 'Aharoni', 'Albertus Extra Bold', 'Albertus Medium', 'Algerian', 'Amazone BT', 'American Typewriter', 'American Typewriter Condensed', 'AmerType Md BT', 'Andalus', 'Angsana New', 'AngsanaUPC', 'Antique Olive', 'Aparajita', 'Apple Chancery', 'Apple Color Emoji', 'Apple SD Gothic Neo', 'Arabic Typesetting', 'ARCHER', 'ARNO PRO', 'Arrus BT', 'Aurora Cn BT', 'AvantGarde Bk BT', 'AvantGarde Md BT', 'AVENIR', 'Ayuthaya', 'Bandy', 'Bangla Sangam MN', 'Bank Gothic', 'BankGothic Md BT', 'Baskerville', 'Baskerville Old Face', 'Batang', 'BatangChe', 'Bauer Bodoni', 'Bauhaus 93', 'Bazooka', 'Bell MT', 'Bembo', 'Benguiat Bk BT', 'Berlin Sans FB', 'Berlin Sans FB Demi', 'Bernard MT Condensed', 'BernhardFashion BT', 'BernhardMod BT', 'Big Caslon', 'BinnerD', 'Blackadder ITC', 'BlairMdITC TT', 'Bodoni 72', 'Bodoni 72 Oldstyle', 'Bodoni 72 Smallcaps', 'Bodoni MT', 'Bodoni MT Black', 'Bodoni MT Condensed', 'Bodoni MT Poster Compressed', 'Bookshelf Symbol 7', 'Boulder', 'Bradley Hand', 'Bradley Hand ITC', 'Bremen Bd BT', 'Britannic Bold', 'Broadway', 'Browallia New', 'BrowalliaUPC', 'Brush Script MT', 'Californian FB', 'Calisto MT', 'Calligrapher', 'Candara', 'CaslonOpnface BT', 'Castellar', 'Centaur', 'Cezanne', 'CG Omega', 'CG Times', 'Chalkboard', 'Chalkboard SE', 'Chalkduster', 'Charlesworth', 'Charter Bd BT', 'Charter BT', 'Chaucer', 'ChelthmITC Bk BT', 'Chiller', 'Clarendon', 'Clarendon Condensed', 'CloisterBlack BT', 'Cochin', 'Colonna MT', 'Constantia', 'Cooper Black', 'Copperplate', 'Copperplate Gothic', 'Copperplate Gothic Bold', 'Copperplate Gothic Light', 'CopperplGoth Bd BT', 'Corbel', 'Cordia New', 'CordiaUPC', 'Cornerstone', 'Coronet', 'Cuckoo', 'Curlz MT', 'DaunPenh', 'Dauphin', 'David', 'DB LCD Temp', 'DELICIOUS', 'Denmark', 'DFKai-SB', 'Didot', 'DilleniaUPC', 'DIN', 'DokChampa', 'Dotum', 'DotumChe', 'Ebrima', 'Edwardian Script ITC', 'Elephant', 'English 111 Vivace BT', 'Engravers MT', 'EngraversGothic BT', 'Eras Bold ITC', 'Eras Demi ITC', 'Eras Light ITC', 'Eras Medium ITC', 'EucrosiaUPC', 'Euphemia', 'Euphemia UCAS', 'EUROSTILE', 'Exotc350 Bd BT', 'FangSong', 'Felix Titling', 'Fixedsys', 'FONTIN', 'Footlight MT Light', 'Forte', 'FrankRuehl', 'Fransiscan', 'Freefrm721 Blk BT', 'FreesiaUPC', 'Freestyle Script', 'French Script MT', 'FrnkGothITC Bk BT', 'Fruitger', 'FRUTIGER', 'Futura', 'Futura Bk BT', 'Futura Lt BT', 'Futura Md BT', 'Futura ZBlk BT', 'FuturaBlack BT', 'Gabriola', 'Galliard BT', 'Gautami', 'Geeza Pro', 'Geometr231 BT', 'Geometr231 Hv BT', 'Geometr231 Lt BT', 'GeoSlab 703 Lt BT', 'GeoSlab 703 XBd BT', 'Gigi', 'Gill Sans', 'Gill Sans MT', 'Gill Sans MT Condensed', 'Gill Sans MT Ext Condensed Bold', 'Gill Sans Ultra Bold', 'Gill Sans Ultra Bold Condensed', 'Gisha', 'Gloucester MT Extra Condensed', 'GOTHAM', 'GOTHAM BOLD', 'Goudy Old Style', 'Goudy Stout', 'GoudyHandtooled BT', 'GoudyOLSt BT', 'Gujarati Sangam MN', 'Gulim', 'GulimChe', 'Gungsuh', 'GungsuhChe', 'Gurmukhi MN', 'Haettenschweiler', 'Harlow Solid Italic', 'Harrington', 'Heather', 'Heiti SC', 'Heiti TC', 'HELV', 'Herald', 'High Tower Text', 'Hiragino Kaku Gothic ProN', 'Hiragino Mincho ProN', 'Hoefler Text', 'Humanst 521 Cn BT', 'Humanst521 BT', 'Humanst521 Lt BT', 'Imprint MT Shadow', 'Incised901 Bd BT', 'Incised901 BT', 'Incised901 Lt BT', 'INCONSOLATA', 'Informal Roman', 'Informal011 BT', 'INTERSTATE', 'IrisUPC', 'Iskoola Pota', 'JasmineUPC', 'Jazz LET', 'Jenson', 'Jester', 'Jokerman', 'Juice ITC', 'Kabel Bk BT', 'Kabel Ult BT', 'Kailasa', 'KaiTi', 'Kalinga', 'Kannada Sangam MN', 'Kartika', 'Kaufmann Bd BT', 'Kaufmann BT', 'Khmer UI', 'KodchiangUPC', 'Kokila', 'Korinna BT', 'Kristen ITC', 'Krungthep', 'Kunstler Script', 'Lao UI', 'Latha', 'Leelawadee', 'Letter Gothic', 'Levenim MT', 'LilyUPC', 'Lithograph', 'Lithograph Light', 'Long Island', 'Lydian BT', 'Magneto', 'Maiandra GD', 'Malayalam Sangam MN', 'Malgun Gothic', 'Mangal', 'Marigold', 'Marion', 'Marker Felt', 'Market', 'Marlett', 'Matisse ITC', 'Matura MT Script Capitals', 'Meiryo', 'Meiryo UI', 'Microsoft Himalaya', 'Microsoft JhengHei', 'Microsoft New Tai Lue', 'Microsoft PhagsPa', 'Microsoft Tai Le', 'Microsoft Uighur', 'Microsoft YaHei', 'Microsoft Yi Baiti', 'MingLiU', 'MingLiU_HKSCS', 'MingLiU_HKSCS-ExtB', 'MingLiU-ExtB', 'Minion', 'Minion Pro', 'Miriam', 'Miriam Fixed', 'Mistral', 'Modern', 'Modern No. 20', 'Mona Lisa Solid ITC TT', 'Mongolian Baiti', 'MONO', 'MoolBoran', 'Mrs Eaves', 'MS LineDraw', 'MS Mincho', 'MS PMincho', 'MS Reference Specialty', 'MS UI Gothic', 'MT Extra', 'MUSEO', 'MV Boli', 'Nadeem', 'Narkisim', 'NEVIS', 'News Gothic', 'News GothicMT', 'NewsGoth BT', 'Niagara Engraved', 'Niagara Solid', 'Noteworthy', 'NSimSun', 'Nyala', 'OCR A Extended', 'Old Century', 'Old English Text MT', 'Onyx', 'Onyx BT', 'OPTIMA', 'Oriya Sangam MN', 'OSAKA', 'OzHandicraft BT', 'Palace Script MT', 'Papyrus', 'Parchment', 'Party LET', 'Pegasus', 'Perpetua', 'Perpetua Titling MT', 'PetitaBold', 'Pickwick', 'Plantagenet Cherokee', 'Playbill', 'PMingLiU', 'PMingLiU-ExtB', 'Poor Richard', 'Poster', 'PosterBodoni BT', 'PRINCETOWN LET', 'Pristina', 'PTBarnum BT', 'Pythagoras', 'Raavi', 'Rage Italic', 'Ravie', 'Ribbon131 Bd BT', 'Rockwell', 'Rockwell Condensed', 'Rockwell Extra Bold', 'Rod', 'Roman', 'Sakkal Majalla', 'Santa Fe LET', 'Savoye LET', 'Sceptre', 'Script', 'Script MT Bold', 'SCRIPTINA', 'Serifa', 'Serifa BT', 'Serifa Th BT', 'ShelleyVolante BT', 'Sherwood', 'Shonar Bangla', 'Showcard Gothic', 'Shruti', 'Signboard', 'SILKSCREEN', 'SimHei', 'Simplified Arabic', 'Simplified Arabic Fixed', 'SimSun', 'SimSun-ExtB', 'Sinhala Sangam MN', 'Sketch Rockwell', 'Skia', 'Small Fonts', 'Snap ITC', 'Snell Roundhand', 'Socket', 'Souvenir Lt BT', 'Staccato222 BT', 'Steamer', 'Stencil', 'Storybook', 'Styllo', 'Subway', 'Swis721 BlkEx BT', 'Swiss911 XCm BT', 'Sylfaen', 'Synchro LET', 'System', 'Tamil Sangam MN', 'Technical', 'Teletype', 'Telugu Sangam MN', 'Tempus Sans ITC', 'Terminal', 'Thonburi', 'Traditional Arabic', 'Trajan', 'TRAJAN PRO', 'Tristan', 'Tubular', 'Tunga', 'Tw Cen MT', 'Tw Cen MT Condensed', 'Tw Cen MT Condensed Extra Bold', 'TypoUpright BT', 'Unicorn', 'Univers', 'Univers CE 55 Medium', 'Univers Condensed', 'Utsaah', 'Vagabond', 'Vani', 'Vijaya', 'Viner Hand ITC', 'VisualUI', 'Vivaldi', 'Vladimir Script', 'Vrinda', 'Westminster', 'WHITNEY', 'Wide Latin', 'ZapfEllipt BT', 'ZapfHumnst BT', 'ZapfHumnst Dm BT', 'Zapfino', 'Zurich BlkEx BT', 'Zurich Ex BT', 'ZWAdobeF'])); n = (n = n.concat(t.fonts.userDefinedFonts)).filter(function (e, t) { return n.indexOf(e) === t }); var i = document.getElementsByTagName('body')[0]; var o = document.createElement('div'); var a = document.createElement('div'); var s = {}; var c = {}; var u = function () { var e = document.createElement('span'); return e.style.position = 'absolute', e.style.left = '-9999px', e.style.fontSize = '72px', e.style.fontStyle = 'normal', e.style.fontWeight = 'normal', e.style.letterSpacing = 'normal', e.style.lineBreak = 'auto', e.style.lineHeight = 'normal', e.style.textTransform = 'none', e.style.textAlign = 'left', e.style.textDecoration = 'none', e.style.textShadow = 'none', e.style.whiteSpace = 'normal', e.style.wordBreak = 'normal', e.style.wordSpacing = 'normal', e.innerHTML = 'mmmmmmmmmmlli', e }; var d = function (e, t) { var r = u(); return r.style.fontFamily = "'" + e + "'," + t, r }; var l = function (e) { for (var t = !1, n = 0; n < r.length; n++) if (t = e[n].offsetWidth !== s[r[n]] || e[n].offsetHeight !== c[r[n]]) return t; return t }; var h = (function () { for (var e = [], t = 0, n = r.length; t < n; t++) { var i = u(); i.style.fontFamily = r[t], o.appendChild(i), e.push(i) } return e }()); i.appendChild(o); for (var f = 0, p = r.length; f < p; f++)s[r[f]] = h[f].offsetWidth, c[r[f]] = h[f].offsetHeight; var m = (function () { for (var e = {}, t = 0, i = n.length; t < i; t++) { for (var o = [], s = 0, c = r.length; s < c; s++) { var u = d(n[t], r[s]); a.appendChild(u), o.push(u) } e[n[t]] = o } return e }()); i.appendChild(a); for (var v = [], g = 0, y = n.length; g < y; g++)l(m[n[g]]) && v.push(n[g]); i.removeChild(a), i.removeChild(o), e(v) }, pauseBefore: !0 }, { key: 'fontsFlash', getData: function (e, t) { return L() ? j() ? t.fonts.swfPath ? void N(function (t) { e(t) }, t) : e('missing options.fonts.swfPath') : e('flash not installed') : e('swf object not loaded') }, pauseBefore: !0 }, { key: 'audio', getData: function (e, t) { var r = t.audio; if (r.excludeIOS11 && navigator.userAgent.match(/OS 11.+Version\/11.+Safari/)) return e(t.EXCLUDED); var n = window.OfflineAudioContext || window.webkitOfflineAudioContext; if (n == null) return e(t.NOT_AVAILABLE); var i = new n(1, 44100, 44100); var o = i.createOscillator(); o.type = 'triangle', o.frequency.setValueAtTime(1e4, i.currentTime); var a = i.createDynamicsCompressor(); c([['threshold', -50], ['knee', 40], ['ratio', 12], ['reduction', -20], ['attack', 0], ['release', 0.25]], function (e) { void 0 !== a[e[0]] && typeof a[e[0]].setValueAtTime === 'function' && a[e[0]].setValueAtTime(e[1], i.currentTime) }), o.connect(a), a.connect(i.destination), o.start(0), i.startRendering(); var s = setTimeout(function () { return console.warn('Audio fingerprint timed out. Please report bug at https://github.com/Valve/fingerprintjs2 with your user agent: "' + navigator.userAgent + '".'), i.oncomplete = function () { }, i = null, e('audioTimeout') }, r.timeout); i.oncomplete = function (t) { var r; try { clearTimeout(s), r = t.renderedBuffer.getChannelData(0).slice(4500, 5e3).reduce(function (e, t) { return e + Math.abs(t) }, 0).toString(), o.disconnect(), a.disconnect() } catch (t) { return void e(t) } e(r) } } }, { key: 'enumerateDevices', getData: function (e, t) { if (!d()) return e(t.NOT_AVAILABLE); navigator.mediaDevices.enumerateDevices().then(function (t) { e(t.map(function (e) { return 'id=' + e.deviceId + ';gid=' + e.groupId + ';' + e.kind + ';' + e.label })) }).catch(function (t) { e(t) }) } }]; var U = function (e) { throw new Error("'new Fingerprint()' is deprecated, see https://github.com/Valve/fingerprintjs2#upgrade-guide-from-182-to-200") }; return U.get = function (e, t) { t ? e || (e = {}) : (t = e, e = {}), (function (e, t) { if (t == null) return e; var r, n; for (n in t) (r = t[n]) == null || Object.prototype.hasOwnProperty.call(e, n) || (e[n] = r) }(e, s)), e.components = e.extraComponents.concat(F); var r = { data: [], addPreprocessedComponent: function (t, n) { typeof e.preprocessor === 'function' && (n = e.preprocessor(t, n)), r.data.push({ key: t, value: n }) } }; var n = -1; var i = function (o) { if ((n += 1) >= e.components.length) t(r.data); else { var a = e.components[n]; if (e.excludes[a.key]) i(!1); else { if (!o && a.pauseBefore) return n -= 1, void setTimeout(function () { i(!0) }, 1); try { a.getData(function (e) { r.addPreprocessedComponent(a.key, e), i(!1) }, e) } catch (e) { r.addPreprocessedComponent(a.key, String(e)), i(!1) } } } }; i(!1) }, U.getPromise = function (e) { return new Promise(function (t, r) { U.get(e, t) }) }, U.getV18 = function (e, t) { return t == null && (t = e, e = {}), U.get(e, function (r) { for (var n = [], i = 0; i < r.length; i++) { var o = r[i]; if (o.value === (e.NOT_AVAILABLE || 'not available')) n.push({ key: o.key, value: 'unknown' }); else if (o.key === 'plugins') n.push({ key: 'plugins', value: u(o.value, function (e) { var t = u(e[2], function (e) { return e.join ? e.join('~') : e }).join(','); return [e[0], e[1], t].join('::') }) }); else if (['canvas', 'webgl'].indexOf(o.key) !== -1) n.push({ key: o.key, value: o.value.join('~') }); else if (['sessionStorage', 'localStorage', 'indexedDb', 'addBehavior', 'openDatabase'].indexOf(o.key) !== -1) { if (!o.value) continue; n.push({ key: o.key, value: 1 }) } else o.value ? n.push(o.value.join ? { key: o.key, value: o.value.join(';') } : o) : n.push({ key: o.key, value: o.value }) } var s = a(u(n, function (e) { return e.value }).join('~~~'), 31); t(s, n) }) }, U.x64hash128 = a, U.VERSION = '2.0.0', U }, e.exports ? e.exports = r() : t.exports ? t.exports = r() : t.Fingerprint2 = r() }); var G = l(function (e, t) { e.exports = (function e (t, r, n) { function i (a, s) { if (!r[a]) { if (!t[a]) { var c = d; if (!s && c) return c(a, !0); if (o) return o(a, !0); var u = new Error("Cannot find module '" + a + "'"); throw u.code = 'MODULE_NOT_FOUND', u } var l = r[a] = { exports: {} }; t[a][0].call(l.exports, function (e) { var r = t[a][1][e]; return i(r || e) }, l, l.exports, e, t, r, n) } return r[a].exports } for (var o = d, a = 0; a < n.length; a++)i(n[a]); return i }({ 1: [function (e, t, r) { (function (e) { var r; var n; var i = e.MutationObserver || e.WebKitMutationObserver; if (i) { var o = 0; var a = new i(d); var s = e.document.createTextNode(''); a.observe(s, { characterData: !0 }), r = function () { s.data = o = ++o % 2 } } else if (e.setImmediate || void 0 === e.MessageChannel) r = 'document' in e && 'onreadystatechange' in e.document.createElement('script') ? function () { var t = e.document.createElement('script'); t.onreadystatechange = function () { d(), t.onreadystatechange = null, t.parentNode.removeChild(t), t = null }, e.document.documentElement.appendChild(t) } : function () { setTimeout(d, 0) }; else { var c = new e.MessageChannel(); c.port1.onmessage = d, r = function () { c.port2.postMessage(0) } } var u = []; function d () { var e, t; n = !0; for (var r = u.length; r;) { for (t = u, u = [], e = -1; ++e < r;)t[e](); r = u.length } n = !1 } t.exports = function (e) { u.push(e) !== 1 || n || r() } }).call(this, void 0 !== u ? u : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}) }, {}], 2: [function (e, t, r) { var n = e(1); function i () { } var o = {}; var a = ['REJECTED']; var s = ['FULFILLED']; var c = ['PENDING']; function u (e) { if (typeof e !== 'function') throw new TypeError('resolver must be a function'); this.state = c, this.queue = [], this.outcome = void 0, e !== i && f(this, e) } function d (e, t, r) { this.promise = e, typeof t === 'function' && (this.onFulfilled = t, this.callFulfilled = this.otherCallFulfilled), typeof r === 'function' && (this.onRejected = r, this.callRejected = this.otherCallRejected) } function l (e, t, r) { n(function () { var n; try { n = t(r) } catch (t) { return o.reject(e, t) } n === e ? o.reject(e, new TypeError('Cannot resolve promise with itself')) : o.resolve(e, n) }) } function h (e) { var t = e && e.then; if (e && (typeof e === 'object' || typeof e === 'function') && typeof t === 'function') return function () { t.apply(e, arguments) } } function f (e, t) { var r = !1; function n (t) { r || (r = !0, o.reject(e, t)) } function i (t) { r || (r = !0, o.resolve(e, t)) } var a = p(function () { t(i, n) }); a.status === 'error' && n(a.value) } function p (e, t) { var r = {}; try { r.value = e(t), r.status = 'success' } catch (e) { r.status = 'error', r.value = e } return r } t.exports = u, u.prototype.catch = function (e) { return this.then(null, e) }, u.prototype.then = function (e, t) { if (typeof e !== 'function' && this.state === s || typeof t !== 'function' && this.state === a) return this; var r = new this.constructor(i); if (this.state !== c) { var n = this.state === s ? e : t; l(r, n, this.outcome) } else this.queue.push(new d(r, e, t)); return r }, d.prototype.callFulfilled = function (e) { o.resolve(this.promise, e) }, d.prototype.otherCallFulfilled = function (e) { l(this.promise, this.onFulfilled, e) }, d.prototype.callRejected = function (e) { o.reject(this.promise, e) }, d.prototype.otherCallRejected = function (e) { l(this.promise, this.onRejected, e) }, o.resolve = function (e, t) { var r = p(h, t); if (r.status === 'error') return o.reject(e, r.value); var n = r.value; if (n) f(e, n); else { e.state = s, e.outcome = t; for (var i = -1, a = e.queue.length; ++i < a;)e.queue[i].callFulfilled(t) } return e }, o.reject = function (e, t) { e.state = a, e.outcome = t; for (var r = -1, n = e.queue.length; ++r < n;)e.queue[r].callRejected(t); return e }, u.resolve = function (e) { return e instanceof this ? e : o.resolve(new this(i), e) }, u.reject = function (e) { var t = new this(i); return o.reject(t, e) }, u.all = function (e) { var t = this; if (Object.prototype.toString.call(e) !== '[object Array]') return this.reject(new TypeError('must be an array')); var r = e.length; var n = !1; if (!r) return this.resolve([]); for (var a = new Array(r), s = 0, c = -1, u = new this(i); ++c < r;)d(e[c], c); return u; function d (e, i) { t.resolve(e).then(function (e) { a[i] = e, ++s !== r || n || (n = !0, o.resolve(u, a)) }, function (e) { n || (n = !0, o.reject(u, e)) }) } }, u.race = function (e) { var t = this; if (Object.prototype.toString.call(e) !== '[object Array]') return this.reject(new TypeError('must be an array')); var r = e.length; var n = !1; if (!r) return this.resolve([]); for (var a, s = -1, c = new this(i); ++s < r;)a = e[s], t.resolve(a).then(function (e) { n || (n = !0, o.resolve(c, e)) }, function (e) { n || (n = !0, o.reject(c, e)) }); return c } }, { 1: 1 }], 3: [function (e, t, r) { (function (t) { typeof t.Promise !== 'function' && (t.Promise = e(2)) }).call(this, void 0 !== u ? u : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}) }, { 2: 2 }], 4: [function (e, t, r) { var n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; var i = (function () { try { if (typeof indexedDB !== 'undefined') return indexedDB; if (typeof webkitIndexedDB !== 'undefined') return webkitIndexedDB; if (typeof mozIndexedDB !== 'undefined') return mozIndexedDB; if (typeof OIndexedDB !== 'undefined') return OIndexedDB; if (typeof msIndexedDB !== 'undefined') return msIndexedDB } catch (e) { } }()); function o (e, t) { e = e || [], t = t || {}; try { return new Blob(e, t) } catch (o) { if (o.name !== 'TypeError') throw o; for (var r = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder, n = new r(), i = 0; i < e.length; i += 1)n.append(e[i]); return n.getBlob(t.type) } } typeof Promise === 'undefined' && e(3); var a = Promise; function s (e, t) { t && e.then(function (e) { t(null, e) }, function (e) { t(e) }) } function c (e, t, r) { typeof t === 'function' && e.then(t), typeof r === 'function' && e.catch(r) } function u (e) { return typeof e !== 'string' && (console.warn(e + ' used as a key, but it is not a string.'), e = String(e)), e } function d () { if (arguments.length && typeof arguments[arguments.length - 1] === 'function') return arguments[arguments.length - 1] } var l = 'local-forage-detect-blob-support'; var h = void 0; var f = {}; var p = Object.prototype.toString; var m = 'readonly'; var v = 'readwrite'; function g (e) { return typeof h === 'boolean' ? a.resolve(h) : (function (e) { return new a(function (t) { var r = e.transaction(l, v); var n = o(['']); r.objectStore(l).put(n, 'key'), r.onabort = function (e) { e.preventDefault(), e.stopPropagation(), t(!1) }, r.oncomplete = function () { var e = navigator.userAgent.match(/Chrome\/(\d+)/); var r = navigator.userAgent.match(/Edge\//); t(r || !e || parseInt(e[1], 10) >= 43) } }).catch(function () { return !1 }) }(e)).then(function (e) { return h = e }) } function y (e) { var t = f[e.name]; var r = {}; r.promise = new a(function (e, t) { r.resolve = e, r.reject = t }), t.deferredOperations.push(r), t.dbReady ? t.dbReady = t.dbReady.then(function () { return r.promise }) : t.dbReady = r.promise } function b (e) { var t = f[e.name]; var r = t.deferredOperations.pop(); if (r) return r.resolve(), r.promise } function k (e, t) { var r = f[e.name]; var n = r.deferredOperations.pop(); if (n) return n.reject(t), n.promise } function _ (e, t) { return new a(function (r, n) { if (f[e.name] = f[e.name] || { forages: [], db: null, dbReady: null, deferredOperations: [] }, e.db) { if (!t) return r(e.db); y(e), e.db.close() } var o = [e.name]; t && o.push(e.version); var a = i.open.apply(i, o); t && (a.onupgradeneeded = function (t) { var r = a.result; try { r.createObjectStore(e.storeName), t.oldVersion <= 1 && r.createObjectStore(l) } catch (r) { if (r.name !== 'ConstraintError') throw r; console.warn('The database "' + e.name + '" has been upgraded from version ' + t.oldVersion + ' to version ' + t.newVersion + ', but the storage "' + e.storeName + '" already exists.') } }), a.onerror = function (e) { e.preventDefault(), n(a.error) }, a.onsuccess = function () { r(a.result), b(e) } }) } function S (e) { return _(e, !1) } function T (e) { return _(e, !0) } function w (e, t) { if (!e.db) return !0; var r = !e.db.objectStoreNames.contains(e.storeName); var n = e.version < e.db.version; var i = e.version > e.db.version; if (n && (e.version !== t && console.warn('The database "' + e.name + "\" can't be downgraded from version " + e.db.version + ' to version ' + e.version + '.'), e.version = e.db.version), i || r) { if (r) { var o = e.db.version + 1; o > e.version && (e.version = o) } return !0 } return !1 } function C (e) { var t = (function (e) { for (var t = e.length, r = new ArrayBuffer(t), n = new Uint8Array(r), i = 0; i < t; i++)n[i] = e.charCodeAt(i); return r }(atob(e.data))); return o([t], { type: e.type }) } function E (e) { return e && e.__local_forage_encoded_blob } function R (e) { var t = this; var r = t._initReady().then(function () { var e = f[t._dbInfo.name]; if (e && e.dbReady) return e.dbReady }); return c(r, e, e), r } function I (e, t, r, n) { void 0 === n && (n = 1); try { var i = e.db.transaction(e.storeName, t); r(null, i) } catch (i) { if (n > 0 && (!e.db || i.name === 'InvalidStateError' || i.name === 'NotFoundError')) return a.resolve().then(function () { if (!e.db || i.name === 'NotFoundError' && !e.db.objectStoreNames.contains(e.storeName) && e.version <= e.db.version) return e.db && (e.version = e.db.version + 1), T(e) }).then(function () { return (function (e) { y(e); for (var t = f[e.name], r = t.forages, n = 0; n < r.length; n++) { var i = r[n]; i._dbInfo.db && (i._dbInfo.db.close(), i._dbInfo.db = null) } return e.db = null, S(e).then(function (t) { return e.db = t, w(e) ? T(e) : t }).then(function (n) { e.db = t.db = n; for (var i = 0; i < r.length; i++)r[i]._dbInfo.db = n }).catch(function (t) { throw k(e, t), t }) }(e)).then(function () { I(e, t, r, n - 1) }) }).catch(r); r(i) } } var P = { _driver: 'asyncStorage', _initStorage: function (e) { var t = this; var r = { db: null }; if (e) for (var n in e) r[n] = e[n]; var i = f[r.name]; i || (i = { forages: [], db: null, dbReady: null, deferredOperations: [] }, f[r.name] = i), i.forages.push(t), t._initReady || (t._initReady = t.ready, t.ready = R); var o = []; function s () { return a.resolve() } for (var c = 0; c < i.forages.length; c++) { var u = i.forages[c]; u !== t && o.push(u._initReady().catch(s)) } var d = i.forages.slice(0); return a.all(o).then(function () { return r.db = i.db, S(r) }).then(function (e) { return r.db = e, w(r, t._defaultConfig.version) ? T(r) : e }).then(function (e) { r.db = i.db = e, t._dbInfo = r; for (var n = 0; n < d.length; n++) { var o = d[n]; o !== t && (o._dbInfo.db = r.db, o._dbInfo.version = r.version) } }) }, _support: (function () { try { if (!i) return !1; var e = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform); var t = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1; return (!e || t) && typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined' } catch (e) { return !1 } }()), iterate: function (e, t) { var r = this; var n = new a(function (t, n) { r.ready().then(function () { I(r._dbInfo, m, function (i, o) { if (i) return n(i); try { var a = o.objectStore(r._dbInfo.storeName); var s = a.openCursor(); var c = 1; s.onsuccess = function () { var r = s.result; if (r) { var n = r.value; E(n) && (n = C(n)); var i = e(n, r.key, c++); void 0 !== i ? t(i) : r.continue() } else t() }, s.onerror = function () { n(s.error) } } catch (e) { n(e) } }) }).catch(n) }); return s(n, t), n }, getItem: function (e, t) { var r = this; e = u(e); var n = new a(function (t, n) { r.ready().then(function () { I(r._dbInfo, m, function (i, o) { if (i) return n(i); try { var a = o.objectStore(r._dbInfo.storeName); var s = a.get(e); s.onsuccess = function () { var e = s.result; void 0 === e && (e = null), E(e) && (e = C(e)), t(e) }, s.onerror = function () { n(s.error) } } catch (e) { n(e) } }) }).catch(n) }); return s(n, t), n }, setItem: function (e, t, r) { var n = this; e = u(e); var i = new a(function (r, i) { var o; n.ready().then(function () { return o = n._dbInfo, p.call(t) === '[object Blob]' ? g(o.db).then(function (e) { return e ? t : (r = t, new a(function (e, t) { var n = new FileReader(); n.onerror = t, n.onloadend = function (t) { var n = btoa(t.target.result || ''); e({ __local_forage_encoded_blob: !0, data: n, type: r.type }) }, n.readAsBinaryString(r) })); var r }) : t }).then(function (t) { I(n._dbInfo, v, function (o, a) { if (o) return i(o); try { var s = a.objectStore(n._dbInfo.storeName); t === null && (t = void 0); var c = s.put(t, e); a.oncomplete = function () { void 0 === t && (t = null), r(t) }, a.onabort = a.onerror = function () { var e = c.error ? c.error : c.transaction.error; i(e) } } catch (e) { i(e) } }) }).catch(i) }); return s(i, r), i }, removeItem: function (e, t) { var r = this; e = u(e); var n = new a(function (t, n) { r.ready().then(function () { I(r._dbInfo, v, function (i, o) { if (i) return n(i); try { var a = o.objectStore(r._dbInfo.storeName); var s = a.delete(e); o.oncomplete = function () { t() }, o.onerror = function () { n(s.error) }, o.onabort = function () { var e = s.error ? s.error : s.transaction.error; n(e) } } catch (e) { n(e) } }) }).catch(n) }); return s(n, t), n }, clear: function (e) { var t = this; var r = new a(function (e, r) { t.ready().then(function () { I(t._dbInfo, v, function (n, i) { if (n) return r(n); try { var o = i.objectStore(t._dbInfo.storeName); var a = o.clear(); i.oncomplete = function () { e() }, i.onabort = i.onerror = function () { var e = a.error ? a.error : a.transaction.error; r(e) } } catch (e) { r(e) } }) }).catch(r) }); return s(r, e), r }, length: function (e) { var t = this; var r = new a(function (e, r) { t.ready().then(function () { I(t._dbInfo, m, function (n, i) { if (n) return r(n); try { var o = i.objectStore(t._dbInfo.storeName); var a = o.count(); a.onsuccess = function () { e(a.result) }, a.onerror = function () { r(a.error) } } catch (e) { r(e) } }) }).catch(r) }); return s(r, e), r }, key: function (e, t) { var r = this; var n = new a(function (t, n) { e < 0 ? t(null) : r.ready().then(function () { I(r._dbInfo, m, function (i, o) { if (i) return n(i); try { var a = o.objectStore(r._dbInfo.storeName); var s = !1; var c = a.openCursor(); c.onsuccess = function () { var r = c.result; r ? e === 0 ? t(r.key) : s ? t(r.key) : (s = !0, r.advance(e)) : t(null) }, c.onerror = function () { n(c.error) } } catch (e) { n(e) } }) }).catch(n) }); return s(n, t), n }, keys: function (e) { var t = this; var r = new a(function (e, r) { t.ready().then(function () { I(t._dbInfo, m, function (n, i) { if (n) return r(n); try { var o = i.objectStore(t._dbInfo.storeName); var a = o.openCursor(); var s = []; a.onsuccess = function () { var t = a.result; t ? (s.push(t.key), t.continue()) : e(s) }, a.onerror = function () { r(a.error) } } catch (e) { r(e) } }) }).catch(r) }); return s(r, e), r }, dropInstance: function (e, t) { t = d.apply(this, arguments); var r; var n = this.config(); if ((e = typeof e !== 'function' && e || {}).name || (e.name = e.name || n.name, e.storeName = e.storeName || n.storeName), e.name) { var o = e.name === n.name && this._dbInfo.db; var c = o ? a.resolve(this._dbInfo.db) : S(e).then(function (t) { var r = f[e.name]; var n = r.forages; r.db = t; for (var i = 0; i < n.length; i++)n[i]._dbInfo.db = t; return t }); r = e.storeName ? c.then(function (t) { if (t.objectStoreNames.contains(e.storeName)) { var r = t.version + 1; y(e); var n = f[e.name]; var o = n.forages; t.close(); for (var s = 0; s < o.length; s++) { var c = o[s]; c._dbInfo.db = null, c._dbInfo.version = r } var u = new a(function (t, n) { var o = i.open(e.name, r); o.onerror = function (e) { var t = o.result; t.close(), n(e) }, o.onupgradeneeded = function () { var t = o.result; t.deleteObjectStore(e.storeName) }, o.onsuccess = function () { var e = o.result; e.close(), t(e) } }); return u.then(function (e) { n.db = e; for (var t = 0; t < o.length; t++) { var r = o[t]; r._dbInfo.db = e, b(r._dbInfo) } }).catch(function (t) { throw (k(e, t) || a.resolve()).catch(function () { }), t }) } }) : c.then(function (t) { y(e); var r = f[e.name]; var n = r.forages; t.close(); for (var o = 0; o < n.length; o++) { var s = n[o]; s._dbInfo.db = null } var c = new a(function (t, r) { var n = i.deleteDatabase(e.name); n.onerror = n.onblocked = function (e) { var t = n.result; t && t.close(), r(e) }, n.onsuccess = function () { var e = n.result; e && e.close(), t(e) } }); return c.then(function (e) { r.db = e; for (var t = 0; t < n.length; t++) { var i = n[t]; b(i._dbInfo) } }).catch(function (t) { throw (k(e, t) || a.resolve()).catch(function () { }), t }) }) } else r = a.reject('Invalid arguments'); return s(r, t), r } }; var A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; var M = '~~local_forage_type~'; var x = /^~~local_forage_type~([^~]+)~/; var O = '__lfsc__:'; var D = O.length; var L = 'arbf'; var j = 'blob'; var N = 'si08'; var B = 'ui08'; var F = 'uic8'; var U = 'si16'; var $ = 'si32'; var V = 'ur16'; var G = 'ui32'; var W = 'fl32'; var H = 'fl64'; var z = D + L.length; var J = Object.prototype.toString; function q (e) { var t; var r; var n; var i; var o; var a = 0.75 * e.length; var s = e.length; var c = 0; e[e.length - 1] === '=' && (a--, e[e.length - 2] === '=' && a--); var u = new ArrayBuffer(a); var d = new Uint8Array(u); for (t = 0; t < s; t += 4)r = A.indexOf(e[t]), n = A.indexOf(e[t + 1]), i = A.indexOf(e[t + 2]), o = A.indexOf(e[t + 3]), d[c++] = r << 2 | n >> 4, d[c++] = (15 & n) << 4 | i >> 2, d[c++] = (3 & i) << 6 | 63 & o; return u } function X (e) { var t; var r = new Uint8Array(e); var n = ''; for (t = 0; t < r.length; t += 3)n += A[r[t] >> 2], n += A[(3 & r[t]) << 4 | r[t + 1] >> 4], n += A[(15 & r[t + 1]) << 2 | r[t + 2] >> 6], n += A[63 & r[t + 2]]; return r.length % 3 == 2 ? n = n.substring(0, n.length - 1) + '=' : r.length % 3 == 1 && (n = n.substring(0, n.length - 2) + '=='), n } var Q = { serialize: function (e, t) { var r = ''; if (e && (r = J.call(e)), e && (r === '[object ArrayBuffer]' || e.buffer && J.call(e.buffer) === '[object ArrayBuffer]')) { var n; var i = O; e instanceof ArrayBuffer ? (n = e, i += L) : (n = e.buffer, r === '[object Int8Array]' ? i += N : r === '[object Uint8Array]' ? i += B : r === '[object Uint8ClampedArray]' ? i += F : r === '[object Int16Array]' ? i += U : r === '[object Uint16Array]' ? i += V : r === '[object Int32Array]' ? i += $ : r === '[object Uint32Array]' ? i += G : r === '[object Float32Array]' ? i += W : r === '[object Float64Array]' ? i += H : t(new Error('Failed to get type for BinaryArray'))), t(i + X(n)) } else if (r === '[object Blob]') { var o = new FileReader(); o.onload = function () { var r = M + e.type + '~' + X(this.result); t(O + j + r) }, o.readAsArrayBuffer(e) } else try { t(JSON.stringify(e)) } catch (r) { console.error("Couldn't convert value into a JSON string: ", e), t(null, r) } }, deserialize: function (e) { if (e.substring(0, D) !== O) return JSON.parse(e); var t; var r = e.substring(z); var n = e.substring(D, z); if (n === j && x.test(r)) { var i = r.match(x); t = i[1], r = r.substring(i[0].length) } var a = q(r); switch (n) { case L: return a; case j: return o([a], { type: t }); case N: return new Int8Array(a); case B: return new Uint8Array(a); case F: return new Uint8ClampedArray(a); case U: return new Int16Array(a); case V: return new Uint16Array(a); case $: return new Int32Array(a); case G: return new Uint32Array(a); case W: return new Float32Array(a); case H: return new Float64Array(a); default: throw new Error('Unkown type: ' + n) } }, stringToBuffer: q, bufferToString: X }; function K (e, t, r, n) { e.executeSql('CREATE TABLE IF NOT EXISTS ' + t.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], r, n) } function Z (e, t, r, n, i, o) { e.executeSql(r, n, i, function (e, a) { a.code === a.SYNTAX_ERR ? e.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [t.storeName], function (e, s) { s.rows.length ? o(e, a) : K(e, t, function () { e.executeSql(r, n, i, o) }, o) }, o) : o(e, a) }, o) } var Y = { _driver: 'webSQLStorage', _initStorage: function (e) { var t = this; var r = { db: null }; if (e) for (var n in e) r[n] = typeof e[n] !== 'string' ? e[n].toString() : e[n]; var i = new a(function (e, n) { try { r.db = openDatabase(r.name, String(r.version), r.description, r.size) } catch (e) { return n(e) } r.db.transaction(function (i) { K(i, r, function () { t._dbInfo = r, e() }, function (e, t) { n(t) }) }, n) }); return r.serializer = Q, i }, _support: typeof openDatabase === 'function', iterate: function (e, t) { var r = this; var n = new a(function (t, n) { r.ready().then(function () { var i = r._dbInfo; i.db.transaction(function (r) { Z(r, i, 'SELECT * FROM ' + i.storeName, [], function (r, n) { for (var o = n.rows, a = o.length, s = 0; s < a; s++) { var c = o.item(s); var u = c.value; if (u && (u = i.serializer.deserialize(u)), void 0 !== (u = e(u, c.key, s + 1))) return void t(u) } t() }, function (e, t) { n(t) }) }) }).catch(n) }); return s(n, t), n }, getItem: function (e, t) { var r = this; e = u(e); var n = new a(function (t, n) { r.ready().then(function () { var i = r._dbInfo; i.db.transaction(function (r) { Z(r, i, 'SELECT * FROM ' + i.storeName + ' WHERE key = ? LIMIT 1', [e], function (e, r) { var n = r.rows.length ? r.rows.item(0).value : null; n && (n = i.serializer.deserialize(n)), t(n) }, function (e, t) { n(t) }) }) }).catch(n) }); return s(n, t), n }, setItem: function (e, t, r) { return (function e (t, r, n, i) { var o = this; t = u(t); var c = new a(function (a, s) { o.ready().then(function () { void 0 === r && (r = null); var c = r; var u = o._dbInfo; u.serializer.serialize(r, function (r, d) { d ? s(d) : u.db.transaction(function (e) { Z(e, u, 'INSERT OR REPLACE INTO ' + u.storeName + ' (key, value) VALUES (?, ?)', [t, r], function () { a(c) }, function (e, t) { s(t) }) }, function (r) { if (r.code === r.QUOTA_ERR) { if (i > 0) return void a(e.apply(o, [t, c, n, i - 1])); s(r) } }) }) }).catch(s) }); return s(c, n), c }.apply(this, [e, t, r, 1])) }, removeItem: function (e, t) { var r = this; e = u(e); var n = new a(function (t, n) { r.ready().then(function () { var i = r._dbInfo; i.db.transaction(function (r) { Z(r, i, 'DELETE FROM ' + i.storeName + ' WHERE key = ?', [e], function () { t() }, function (e, t) { n(t) }) }) }).catch(n) }); return s(n, t), n }, clear: function (e) { var t = this; var r = new a(function (e, r) { t.ready().then(function () { var n = t._dbInfo; n.db.transaction(function (t) { Z(t, n, 'DELETE FROM ' + n.storeName, [], function () { e() }, function (e, t) { r(t) }) }) }).catch(r) }); return s(r, e), r }, length: function (e) { var t = this; var r = new a(function (e, r) { t.ready().then(function () { var n = t._dbInfo; n.db.transaction(function (t) { Z(t, n, 'SELECT COUNT(key) as c FROM ' + n.storeName, [], function (t, r) { var n = r.rows.item(0).c; e(n) }, function (e, t) { r(t) }) }) }).catch(r) }); return s(r, e), r }, key: function (e, t) { var r = this; var n = new a(function (t, n) { r.ready().then(function () { var i = r._dbInfo; i.db.transaction(function (r) { Z(r, i, 'SELECT key FROM ' + i.storeName + ' WHERE id = ? LIMIT 1', [e + 1], function (e, r) { var n = r.rows.length ? r.rows.item(0).key : null; t(n) }, function (e, t) { n(t) }) }) }).catch(n) }); return s(n, t), n }, keys: function (e) { var t = this; var r = new a(function (e, r) { t.ready().then(function () { var n = t._dbInfo; n.db.transaction(function (t) { Z(t, n, 'SELECT key FROM ' + n.storeName, [], function (t, r) { for (var n = [], i = 0; i < r.rows.length; i++)n.push(r.rows.item(i).key); e(n) }, function (e, t) { r(t) }) }) }).catch(r) }); return s(r, e), r }, dropInstance: function (e, t) { t = d.apply(this, arguments); var r = this.config(); (e = typeof e !== 'function' && e || {}).name || (e.name = e.name || r.name, e.storeName = e.storeName || r.storeName); var n; var i = this; return s(n = e.name ? new a(function (t) { var n; n = e.name === r.name ? i._dbInfo.db : openDatabase(e.name, '', '', 0), e.storeName ? t({ db: n, storeNames: [e.storeName] }) : t(function (e) { return new a(function (t, r) { e.transaction(function (n) { n.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (r, n) { for (var i = [], o = 0; o < n.rows.length; o++)i.push(n.rows.item(o).name); t({ db: e, storeNames: i }) }, function (e, t) { r(t) }) }, function (e) { r(e) }) }) }(n)) }).then(function (e) { return new a(function (t, r) { e.db.transaction(function (n) { function i (e) { return new a(function (t, r) { n.executeSql('DROP TABLE IF EXISTS ' + e, [], function () { t() }, function (e, t) { r(t) }) }) } for (var o = [], s = 0, c = e.storeNames.length; s < c; s++)o.push(i(e.storeNames[s])); a.all(o).then(function () { t() }).catch(function (e) { r(e) }) }, function (e) { r(e) }) }) }) : a.reject('Invalid arguments'), t), n } }; function ee (e, t) { var r = e.name + '/'; return e.storeName !== t.storeName && (r += e.storeName + '/'), r } function te () { return !(function () { try { return localStorage.setItem('_localforage_support_test', !0), localStorage.removeItem('_localforage_support_test'), !1 } catch (e) { return !0 } }()) || localStorage.length > 0 } var re = { _driver: 'localStorageWrapper', _initStorage: function (e) { var t = {}; if (e) for (var r in e) t[r] = e[r]; return t.keyPrefix = ee(e, this._defaultConfig), te() ? (this._dbInfo = t, t.serializer = Q, a.resolve()) : a.reject() }, _support: (function () { try { return typeof localStorage !== 'undefined' && 'setItem' in localStorage && !!localStorage.setItem } catch (e) { return !1 } }()), iterate: function (e, t) { var r = this; var n = r.ready().then(function () { for (var t = r._dbInfo, n = t.keyPrefix, i = n.length, o = localStorage.length, a = 1, s = 0; s < o; s++) { var c = localStorage.key(s); if (c.indexOf(n) === 0) { var u = localStorage.getItem(c); if (u && (u = t.serializer.deserialize(u)), void 0 !== (u = e(u, c.substring(i), a++))) return u } } }); return s(n, t), n }, getItem: function (e, t) { var r = this; e = u(e); var n = r.ready().then(function () { var t = r._dbInfo; var n = localStorage.getItem(t.keyPrefix + e); return n && (n = t.serializer.deserialize(n)), n }); return s(n, t), n }, setItem: function (e, t, r) { var n = this; e = u(e); var i = n.ready().then(function () { void 0 === t && (t = null); var r = t; return new a(function (i, o) { var a = n._dbInfo; a.serializer.serialize(t, function (t, n) { if (n) o(n); else try { localStorage.setItem(a.keyPrefix + e, t), i(r) } catch (e) { e.name !== 'QuotaExceededError' && e.name !== 'NS_ERROR_DOM_QUOTA_REACHED' || o(e), o(e) } }) }) }); return s(i, r), i }, removeItem: function (e, t) { var r = this; e = u(e); var n = r.ready().then(function () { var t = r._dbInfo; localStorage.removeItem(t.keyPrefix + e) }); return s(n, t), n }, clear: function (e) { var t = this; var r = t.ready().then(function () { for (var e = t._dbInfo.keyPrefix, r = localStorage.length - 1; r >= 0; r--) { var n = localStorage.key(r); n.indexOf(e) === 0 && localStorage.removeItem(n) } }); return s(r, e), r }, length: function (e) { var t = this.keys().then(function (e) { return e.length }); return s(t, e), t }, key: function (e, t) { var r = this; var n = r.ready().then(function () { var t; var n = r._dbInfo; try { t = localStorage.key(e) } catch (e) { t = null } return t && (t = t.substring(n.keyPrefix.length)), t }); return s(n, t), n }, keys: function (e) { var t = this; var r = t.ready().then(function () { for (var e = t._dbInfo, r = localStorage.length, n = [], i = 0; i < r; i++) { var o = localStorage.key(i); o.indexOf(e.keyPrefix) === 0 && n.push(o.substring(e.keyPrefix.length)) } return n }); return s(r, e), r }, dropInstance: function (e, t) { if (t = d.apply(this, arguments), !(e = typeof e !== 'function' && e || {}).name) { var r = this.config(); e.name = e.name || r.name, e.storeName = e.storeName || r.storeName } var n; var i = this; return s(n = e.name ? new a(function (t) { e.storeName ? t(ee(e, i._defaultConfig)) : t(e.name + '/') }).then(function (e) { for (var t = localStorage.length - 1; t >= 0; t--) { var r = localStorage.key(t); r.indexOf(e) === 0 && localStorage.removeItem(r) } }) : a.reject('Invalid arguments'), t), n } }; var ne = function (e, t) { for (var r = e.length, n = 0; n < r;) { if ((i = e[n]) === (o = t) || typeof i === 'number' && typeof o === 'number' && isNaN(i) && isNaN(o)) return !0; n++ } var i, o; return !1 }; var ie = Array.isArray || function (e) { return Object.prototype.toString.call(e) === '[object Array]' }; var oe = {}; var ae = {}; var se = { INDEXEDDB: P, WEBSQL: Y, LOCALSTORAGE: re }; var ce = [se.INDEXEDDB._driver, se.WEBSQL._driver, se.LOCALSTORAGE._driver]; var ue = ['dropInstance']; var de = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(ue); var le = { description: '', driver: ce.slice(), name: 'localforage', size: 4980736, storeName: 'keyvaluepairs', version: 1 }; function he (e, t) { e[t] = function () { var r = arguments; return e.ready().then(function () { return e[t].apply(e, r) }) } } function fe () { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; if (t) for (var r in t) t.hasOwnProperty(r) && (ie(t[r]) ? arguments[0][r] = t[r].slice() : arguments[0][r] = t[r]) } return arguments[0] } var pe = (function () { function e (t) { for (var r in (function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') }(this, e)), se) if (se.hasOwnProperty(r)) { var n = se[r]; var i = n._driver; this[r] = i, oe[i] || this.defineDriver(n) } this._defaultConfig = fe({}, le), this._config = fe({}, this._defaultConfig, t), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function () { }) } return e.prototype.config = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object') { if (this._ready) return new Error("Can't call config() after localforage has been used."); for (var t in e) { if (t === 'storeName' && (e[t] = e[t].replace(/\W/g, '_')), t === 'version' && typeof e[t] !== 'number') return new Error('Database version must be a number.'); this._config[t] = e[t] } return !('driver' in e && e.driver) || this.setDriver(this._config.driver) } return typeof e === 'string' ? this._config[e] : this._config }, e.prototype.defineDriver = function (e, t, r) { var n = new a(function (t, r) { try { var n = e._driver; var i = new Error('Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver'); if (!e._driver) return void r(i); for (var o = de.concat('_initStorage'), c = 0, u = o.length; c < u; c++) { var d = o[c]; var l = !ne(ue, d); if ((l || e[d]) && typeof e[d] !== 'function') return void r(i) } !(function () { for (var t = function (e) { return function () { var t = new Error('Method ' + e + ' is not implemented by the current driver'); var r = a.reject(t); return s(r, arguments[arguments.length - 1]), r } }, r = 0, n = ue.length; r < n; r++) { var i = ue[r]; e[i] || (e[i] = t(i)) } }()); var h = function (r) { oe[n] && console.info('Redefining LocalForage driver: ' + n), oe[n] = e, ae[n] = r, t() }; '_support' in e ? e._support && typeof e._support === 'function' ? e._support().then(h, r) : h(!!e._support) : h(!0) } catch (e) { r(e) } }); return c(n, t, r), n }, e.prototype.driver = function () { return this._driver || null }, e.prototype.getDriver = function (e, t, r) { var n = oe[e] ? a.resolve(oe[e]) : a.reject(new Error('Driver not found.')); return c(n, t, r), n }, e.prototype.getSerializer = function (e) { var t = a.resolve(Q); return c(t, e), t }, e.prototype.ready = function (e) { var t = this; var r = t._driverSet.then(function () { return t._ready === null && (t._ready = t._initDriver()), t._ready }); return c(r, e, e), r }, e.prototype.setDriver = function (e, t, r) { var n = this; ie(e) || (e = [e]); var i = this._getSupportedDrivers(e); function o () { n._config.driver = n.driver() } function s (e) { return n._extend(e), o(), n._ready = n._initStorage(n._config), n._ready } var u = this._driverSet !== null ? this._driverSet.catch(function () { return a.resolve() }) : a.resolve(); return this._driverSet = u.then(function () { var e = i[0]; return n._dbInfo = null, n._ready = null, n.getDriver(e).then(function (e) { n._driver = e._driver, o(), n._wrapLibraryMethodsWithReady(), n._initDriver = (function (e) { return function () { var t = 0; return (function r () { for (; t < e.length;) { var i = e[t]; return t++, n._dbInfo = null, n._ready = null, n.getDriver(i).then(s).catch(r) } o(); var c = new Error('No available storage method found.'); return n._driverSet = a.reject(c), n._driverSet }()) } }(i)) }) }).catch(function () { o(); var e = new Error('No available storage method found.'); return n._driverSet = a.reject(e), n._driverSet }), c(this._driverSet, t, r), this._driverSet }, e.prototype.supports = function (e) { return !!ae[e] }, e.prototype._extend = function (e) { fe(this, e) }, e.prototype._getSupportedDrivers = function (e) { for (var t = [], r = 0, n = e.length; r < n; r++) { var i = e[r]; this.supports(i) && t.push(i) } return t }, e.prototype._wrapLibraryMethodsWithReady = function () { for (var e = 0, t = de.length; e < t; e++)he(this, de[e]) }, e.prototype.createInstance = function (t) { return new e(t) }, e }()); var me = new pe(); t.exports = me }, { 3: 3 }] }, {}, [4]))(4) }); var W = l(function (e) { !(function () { var t = []; var r = 3988292384; function n (e) { var t; var n; var i; var o; var a = -1; for (t = 0, i = e.length; t < i; t += 1) { for (o = 255 & (a ^ e[t]), n = 0; n < 8; n += 1)(1 & o) == 1 ? o = o >>> 1 ^ r : o >>>= 1; a = a >>> 8 ^ o } return -1 ^ a } function i (e, r) { var n, o, a; if (void 0 !== i.crc && r && e || (i.crc = -1, e)) { for (n = i.crc, o = 0, a = e.length; o < a; o += 1)n = n >>> 8 ^ t[255 & (n ^ e[o])]; return i.crc = n, -1 ^ n } } !(function () { var e, n, i; for (n = 0; n < 256; n += 1) { for (e = n, i = 0; i < 8; i += 1)1 & e ? e = r ^ e >>> 1 : e >>>= 1; t[n] = e >>> 0 } }()), e.exports = function (e, t) { var r; e = typeof e === 'string' ? (r = e, Array.prototype.map.call(r, function (e) { return e.charCodeAt(0) })) : e; return ((t ? n(e) : i(e)) >>> 0).toString(16) }, e.exports.direct = n, e.exports.table = i }()) }); var H = (W.direct, W.table, l(function (e) { !(function () { var t; var r; var n; var i; var o; var a; var s; var c; var u; var d; var l; var h; var f; var p; var m; var v; var g; var y = 32768; var b = 0; var k = 1; var _ = 2; var S = 9; var T = 6; var w = null; var C = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535]; var E = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]; var R = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99]; var I = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]; var P = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]; var A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; function M () { this.next = null, this.list = null } function x () { this.e = 0, this.b = 0, this.n = 0, this.t = null } function O (e, t, r, n, i, o) { var a; this.BMAX = 16, this.N_MAX = 288, this.status = 0, this.root = null, this.m = 0; var s; var c; var u; var d; var l; var h; var f; var p; var m; var v; var g; var y; var b; var k; var _; var S; var T = []; var w = []; var C = new x(); var E = []; var R = []; var I = []; for (S = this.root = null, l = 0; l < this.BMAX + 1; l++)T[l] = 0; for (l = 0; l < this.BMAX + 1; l++)w[l] = 0; for (l = 0; l < this.BMAX; l++)E[l] = null; for (l = 0; l < this.N_MAX; l++)R[l] = 0; for (l = 0; l < this.BMAX + 1; l++)I[l] = 0; s = t > 256 ? e[256] : this.BMAX, p = e, m = 0, l = t; do { T[p[m]]++, m++ } while (--l > 0); if (T[0] === t) return this.root = null, this.m = 0, void (this.status = 0); for (h = 1; h <= this.BMAX && T[h] === 0; h++); for (f = h, o < h && (o = h), l = this.BMAX; l !== 0 && T[l] === 0; l--); for (u = l, o > l && (o = l), b = 1 << h; h < l; h++, b <<= 1) if ((b -= T[h]) < 0) return this.status = 2, void (this.m = o); if ((b -= T[l]) < 0) return this.status = 2, void (this.m = o); for (T[l] += b, I[1] = h = 0, p = T, m = 1, y = 2; --l > 0;)I[y++] = h += p[m++]; p = e, m = 0, l = 0; do { (h = p[m++]) !== 0 && (R[I[h]++] = l) } while (++l < t); for (t = I[u], I[0] = l = 0, p = R, m = 0, d = -1, g = w[0] = 0, v = null, k = 0; f <= u; f++) for (a = T[f]; a-- > 0;) { for (; f > g + w[1 + d];) { if (g += w[1 + d], d++, k = (k = u - g) > o ? o : k, (c = 1 << (h = f - g)) > a + 1) for (c -= a + 1, y = f; ++h < k && !((c <<= 1) <= T[++y]);)c -= T[y]; for (g + h > s && g < s && (h = s - g), k = 1 << h, w[1 + d] = h, v = [], _ = 0; _ < k; _++)v[_] = new x(); (S = S ? S.next = new M() : this.root = new M()).next = null, S.list = v, E[d] = v, d > 0 && (I[d] = l, C.b = w[d], C.e = 16 + h, C.t = v, h = (l & (1 << g) - 1) >> g - w[d], E[d - 1][h].e = C.e, E[d - 1][h].b = C.b, E[d - 1][h].n = C.n, E[d - 1][h].t = C.t) } for (C.b = f - g, m >= t ? C.e = 99 : p[m] < r ? (C.e = p[m] < 256 ? 16 : 15, C.n = p[m++]) : (C.e = i[p[m] - r], C.n = n[p[m++] - r]), c = 1 << f - g, h = l >> g; h < k; h += c)v[h].e = C.e, v[h].b = C.b, v[h].n = C.n, v[h].t = C.t; for (h = 1 << f - 1; (l & h) != 0; h >>= 1)l ^= h; for (l ^= h; (l & (1 << g) - 1) !== I[d];)g -= w[d], d-- } this.m = w[1], this.status = b !== 0 && u !== 1 ? 1 : 0 } function D (e) { for (; s < e;)a |= (v.length === g ? -1 : 255 & v[g++]) << s, s += 8 } function L (e) { return a & C[e] } function j (e) { a >>= e, s -= e } function N (e, n, i) { var o, a, s; if (i === 0) return 0; for (s = 0; ;) { for (D(p), o = (a = h.list[L(p)]).e; o > 16;) { if (o === 99) return -1; j(a.b), D(o -= 16), o = (a = a.t[L(o)]).e } if (j(a.b), o !== 16) { if (o === 15) break; for (D(o), d = a.n + L(o), j(o), D(m), o = (a = f.list[L(m)]).e; o > 16;) { if (o === 99) return -1; j(a.b), D(o -= 16), o = (a = a.t[L(o)]).e } for (j(a.b), D(o), l = r - a.n - L(o), j(o); d > 0 && s < i;)d--, l &= y - 1, r &= y - 1, e[n + s++] = t[r++] = t[l++]; if (s === i) return i } else if (r &= y - 1, e[n + s++] = t[r++] = a.n, s === i) return i } return c = -1, s } function B (e, n, i) { var o; if (j(o = 7 & s), D(16), o = L(16), j(16), D(16), o !== (65535 & ~a)) return -1; for (j(16), d = o, o = 0; d > 0 && o < i;)d--, r &= y - 1, D(8), e[n + o++] = t[r++] = L(8), j(8); return d === 0 && (c = -1), o } function F (e, t, r) { if (!w) { var a; var s; var c = []; for (a = 0; a < 144; a++)c[a] = 8; for (; a < 256; a++)c[a] = 9; for (; a < 280; a++)c[a] = 7; for (; a < 288; a++)c[a] = 8; if ((s = new O(c, 288, 257, E, R, i = 7)).status !== 0) return console.error('HufBuild error: ' + s.status), -1; for (w = s.root, i = s.m, a = 0; a < 30; a++)c[a] = 5; if ((s = new O(c, 30, 0, I, P, o = 5)).status > 1) return w = null, console.error('HufBuild error: ' + s.status), -1; n = s.root, o = s.m } return h = w, f = n, p = i, m = o, N(e, t, r) } function U (e, t, r) { var n; var i; var o; var a; var s; var c; var u; var d; var l; var v = []; for (n = 0; n < 316; n++)v[n] = 0; if (D(5), u = 257 + L(5), j(5), D(5), d = 1 + L(5), j(5), D(4), c = 4 + L(4), j(4), u > 286 || d > 30) return -1; for (i = 0; i < c; i++)D(3), v[A[i]] = L(3), j(3); for (; i < 19; i++)v[A[i]] = 0; if ((l = new O(v, 19, 19, null, null, p = 7)).status !== 0) return -1; for (h = l.root, p = l.m, a = u + d, n = o = 0; n < a;) if (D(p), j(i = (s = h.list[L(p)]).b), (i = s.n) < 16) v[n++] = o = i; else if (i === 16) { if (D(2), i = 3 + L(2), j(2), n + i > a) return -1; for (; i-- > 0;)v[n++] = o } else if (i === 17) { if (D(3), i = 3 + L(3), j(3), n + i > a) return -1; for (; i-- > 0;)v[n++] = 0; o = 0 } else { if (D(7), i = 11 + L(7), j(7), n + i > a) return -1; for (; i-- > 0;)v[n++] = 0; o = 0 } if (l = new O(v, u, 257, E, R, p = S), p === 0 && (l.status = 1), l.status !== 0 && l.status !== 1) return -1; for (h = l.root, p = l.m, n = 0; n < d; n++)v[n] = v[n + u]; return l = new O(v, d, 0, I, P, m = T), f = l.root, (m = l.m) === 0 && u > 257 ? -1 : l.status !== 0 ? -1 : N(e, t, r) } function $ (e, n, i) { var o, a; for (o = 0; o < i;) { if (u && c === -1) return o; if (d > 0) { if (c !== b) for (; d > 0 && o < i;)d--, l &= y - 1, r &= y - 1, e[n + o++] = t[r++] = t[l++]; else { for (; d > 0 && o < i;)d--, r &= y - 1, D(8), e[n + o++] = t[r++] = L(8), j(8); d === 0 && (c = -1) } if (o === i) return o } if (c === -1) { if (u) break; D(1), L(1) !== 0 && (u = !0), j(1), D(2), c = L(2), j(2), h = null, d = 0 } switch (c) { case b: a = B(e, n + o, i - o); break; case k: a = h ? N(e, n + o, i - o) : F(e, n + o, i - o); break; case _: a = h ? N(e, n + o, i - o) : U(e, n + o, i - o); break; default: a = -1 } if (a === -1) return u ? 0 : -1; o += a } return o } e.exports = function (e) { var n; var i = []; t || (t = []), r = 0, a = 0, s = 0, c = -1, u = !1, d = l = 0, h = null, v = e, g = 0; do { n = $(i, i.length, 1024) } while (n > 0); return v = null, i } }()) })); var z = l(function (e) { !(function () { var t; var r; var n; var i; var o; var a; var s; var c; var u; var d; var l; var h; var f; var p; var m; var v; var g; var y; var b; var k; var _; var S; var T; var w; var C; var E; var R; var I; var P; var A; var M; var x; var O; var D; var L; var j; var N; var B; var F; var U; var $; var V; var G; var W; var H; var z; var J; var q; var X; var Q; var K; var Z; var Y; var ee; var te; var re; var ne = 32768; var ie = 0; var oe = 1; var ae = 2; var se = 6; var ce = 8192; var ue = 2 * ne; var de = 3; var le = 258; var he = 8192; var fe = he; var pe = 32768; var me = pe - 1; var ve = ne - 1; var ge = 0; var ye = 4096; var be = le + de + 1; var ke = ne - be; var _e = 1; var Se = 15; var Te = 7; var we = 29; var Ce = 256; var Ee = 256; var Re = Ce + 1 + we; var Ie = 30; var Pe = 19; var Ae = 16; var Me = 17; var xe = 18; var Oe = 2 * Re + 1; var De = parseInt((15 + de - 1) / de, 10); var Le = null; function je () { this.fc = 0, this.dl = 0 } function Ne () { this.dyn_tree = null, this.static_tree = null, this.extra_bits = null, this.extra_base = 0, this.elems = 0, this.max_length = 0, this.max_code = 0 } function Be (e, t, r, n) { this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = n } function Fe () { this.next = null, this.len = 0, this.ptr = [], this.off = 0 } var Ue = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]; var $e = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]; var Ve = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]; var Ge = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; var We = [new Be(0, 0, 0, 0), new Be(4, 4, 8, 4), new Be(4, 5, 16, 8), new Be(4, 6, 32, 32), new Be(4, 4, 16, 16), new Be(8, 16, 32, 32), new Be(8, 16, 128, 128), new Be(8, 32, 128, 256), new Be(32, 128, 258, 1024), new Be(32, 258, 258, 4096)]; function He (e) { e.next = t, t = e } function ze (e) { return l[ne + e] } function Je (e, t) { return l[ne + e] = t } function qe (e) { Le[a + o++] = e, a + o === ce && (function () { var e, i; if (o !== 0) { for (t !== null ? (s = t, t = t.next) : s = new Fe(), s.next = null, s.len = s.off = 0, e = s, r === null ? r = n = e : n = n.next = e, e.len = o - a, i = 0; i < e.len; i++)e.ptr[i] = Le[a + i]; o = a = 0 } var s }()) } function Xe (e) { e &= 65535, a + o < ce - 2 ? (Le[a + o++] = 255 & e, Le[a + o++] = e >>> 8) : (qe(255 & e), qe(e >>> 8)) } function Qe () { m = (m << De ^ 255 & c[_ + de - 1]) & me, v = ze(m), l[_ & ve] = v, Je(m, _) } function Ke (e, t) { vt(t[e].fc, t[e].dl) } function Ze (e) { return 255 & (e < 256 ? W[e] : W[256 + (e >> 7)]) } function Ye (e, t, r) { return e[t].fc < e[r].fc || e[t].fc === e[r].fc && V[t] <= V[r] } function et (e, t, r) { var n; for (n = 0; n < r && re < te.length; n++)e[t + n] = 255 & te[re++]; return n } function tt (e) { var t; var r; var n; var i; var o = C; var a = _; var s = k; var u = _ > ke ? _ - ke : ge; var d = _ + le; var h = c[a + s - 1]; var f = c[a + s]; k >= I && (o >>= 2); do { if (c[(t = e) + s] === f && c[t + s - 1] === h && c[t] === c[a] && c[++t] === c[a + 1]) { for (a += 2, t++; a < d;) { for (i = !1, n = 0; n < 8; n += 1) if (t += 1, c[a += 1] !== c[t]) { i = !0; break } if (i) break } if (r = le - (d - a), a = d - le, r > s) { if (S = e, s = r, r >= P) break; h = c[a + s - 1], f = c[a + s] } } } while ((e = l[e & ve]) > u && --o != 0); return s } function rt () { var e; var t; var r = ue - w - _; if (r === -1) r--; else if (_ >= ne + ke) { for (e = 0; e < ne; e++)c[e] = c[e + ne]; for (S -= ne, _ -= ne, p -= ne, e = 0; e < pe; e++)Je(e, (t = ze(e)) >= ne ? t - ne : ge); for (e = 0; e < ne; e++)t = l[e], l[e] = t >= ne ? t - ne : ge; r += ne } T || ((e = et(c, _ + w, r)) <= 0 ? T = !0 : w += e) } function nt () { T || (h = 0, f = 0, (function () { var e, t, r, n, i; if (O[0].dl !== 0) return; for (L.dyn_tree = A, L.static_tree = x, L.extra_bits = Ue, L.extra_base = Ce + 1, L.elems = Re, L.max_length = Se, L.max_code = 0, j.dyn_tree = M, j.static_tree = O, j.extra_bits = $e, j.extra_base = 0, j.elems = Ie, j.max_length = Se, j.max_code = 0, N.dyn_tree = D, N.static_tree = null, N.extra_bits = Ve, N.extra_base = 0, N.elems = Pe, N.max_length = Te, N.max_code = 0, r = 0, n = 0; n < we - 1; n++) for (H[n] = r, e = 0; e < 1 << Ue[n]; e++)G[r++] = n; for (G[r - 1] = n, i = 0, n = 0; n < 16; n++) for (z[n] = i, e = 0; e < 1 << $e[n]; e++)W[i++] = n; for (i >>= 7; n < Ie; n++) for (z[n] = i << 7, e = 0; e < 1 << $e[n] - 7; e++)W[256 + i++] = n; for (t = 0; t <= Se; t++)B[t] = 0; e = 0; for (; e <= 143;)x[e++].dl = 8, B[8]++; for (; e <= 255;)x[e++].dl = 9, B[9]++; for (; e <= 279;)x[e++].dl = 7, B[7]++; for (; e <= 287;)x[e++].dl = 8, B[8]++; for (ct(x, Re + 1), e = 0; e < Ie; e++)O[e].dl = 5, O[e].fc = gt(e, 5); at() }()), (function () { var e; for (e = 0; e < pe; e++)l[ne + e] = 0; if (E = We[R].max_lazy, I = We[R].good_length, P = We[R].nice_length, C = We[R].max_chain, _ = 0, p = 0, (w = et(c, 0, 2 * ne)) <= 0) return T = !0, void (w = 0); for (T = !1; w < be && !T;)rt(); for (m = 0, e = 0; e < de - 1; e++)m = (m << De ^ 255 & c[e]) & me }()), r = null, o = 0, a = 0, R <= 3 ? (k = de - 1, b = 0) : (b = de - 1, y = !1), s = !1) } function it (e, t, n) { var o; return i || (nt(), i = !0, w !== 0) ? (o = ot(e, t, n)) === n ? n : s ? o : (R <= 3 ? (function () { for (; w !== 0 && r === null;) { var e; if (Qe(), v !== ge && _ - v <= ke && (b = tt(v)) > w && (b = w), b >= de) if (e = ft(_ - S, b - de), w -= b, b <= E) { b--; do { _++, Qe() } while (--b != 0); _++ } else _ += b, b = 0, m = ((m = 255 & c[_]) << De ^ 255 & c[_ + 1]) & me; else e = ft(0, 255 & c[_]), w--, _++; for (e && (ht(0), p = _); w < be && !T;)rt() } }()) : (function () { for (; w !== 0 && r === null;) { if (Qe(), k = b, g = S, b = de - 1, v !== ge && k < E && _ - v <= ke && ((b = tt(v)) > w && (b = w), b === de && _ - S > ye && b--), k >= de && b <= k) { var e; e = ft(_ - 1 - g, k - de), w -= k - 1, k -= 2; do { _++, Qe() } while (--k != 0); y = !1, b = de - 1, _++, e && (ht(0), p = _) } else y ? (ft(0, 255 & c[_ - 1]) && (ht(0), p = _), _++, w--) : (y = !0, _++, w--); for (; w < be && !T;)rt() } }()), w === 0 && (y && ft(0, 255 & c[_ - 1]), ht(1), s = !0), o + ot(e, o + t, n - o)) : (s = !0, 0) } function ot (e, t, n) { var i, s, c; for (i = 0; r !== null && i < n;) { for ((s = n - i) > r.len && (s = r.len), c = 0; c < s; c++)e[t + i + c] = r.ptr[r.off + c]; var u; if (r.off += s, r.len -= s, i += s, r.len === 0) u = r, r = r.next, He(u) } if (i === n) return i; if (a < o) { for ((s = n - i) > o - a && (s = o - a), c = 0; c < s; c++)e[t + i + c] = Le[a + c]; i += s, o === (a += s) && (o = a = 0) } return i } function at () { var e; for (e = 0; e < Re; e++)A[e].fc = 0; for (e = 0; e < Ie; e++)M[e].fc = 0; for (e = 0; e < Pe; e++)D[e].fc = 0; A[Ee].fc = 1, Y = ee = 0, q = X = Q = 0, K = 0, Z = 1 } function st (e, t) { for (var r = F[t], n = t << 1; n <= U && (n < U && Ye(e, F[n + 1], F[n]) && n++, !Ye(e, r, F[n]));)F[t] = F[n], t = n, n <<= 1; F[t] = r } function ct (e, t) { var r; var n; var i = []; var o = 0; for (r = 1; r <= Se; r++)o = o + B[r - 1] << 1, i[r] = o; for (n = 0; n <= t; n++) { var a = e[n].dl; a !== 0 && (e[n].fc = gt(i[a]++, a)) } } function ut (e) { var t; var r; var n = e.dyn_tree; var i = e.static_tree; var o = e.elems; var a = -1; var s = o; for (U = 0, $ = Oe, t = 0; t < o; t++)n[t].fc !== 0 ? (F[++U] = a = t, V[t] = 0) : n[t].dl = 0; for (; U < 2;) { var c = F[++U] = a < 2 ? ++a : 0; n[c].fc = 1, V[c] = 0, Y--, i !== null && (ee -= i[c].dl) } for (e.max_code = a, t = U >> 1; t >= 1; t--)st(n, t); do { t = F[_e], F[_e] = F[U--], st(n, _e), r = F[_e], F[--$] = t, F[--$] = r, n[s].fc = n[t].fc + n[r].fc, V[t] > V[r] + 1 ? V[s] = V[t] : V[s] = V[r] + 1, n[t].dl = n[r].dl = s, F[_e] = s++, st(n, _e) } while (U >= 2); F[--$] = F[_e], (function (e) { var t; var r; var n; var i; var o; var a; var s = e.dyn_tree; var c = e.extra_bits; var u = e.extra_base; var d = e.max_code; var l = e.max_length; var h = e.static_tree; var f = 0; for (i = 0; i <= Se; i++)B[i] = 0; for (s[F[$]].dl = 0, t = $ + 1; t < Oe; t++)(i = s[s[r = F[t]].dl].dl + 1) > l && (i = l, f++), s[r].dl = i, r > d || (B[i]++, o = 0, r >= u && (o = c[r - u]), a = s[r].fc, Y += a * (i + o), h !== null && (ee += a * (h[r].dl + o))); if (f !== 0) { do { for (i = l - 1; B[i] === 0;)i--; B[i]--, B[i + 1] += 2, B[l]--, f -= 2 } while (f > 0); for (i = l; i !== 0; i--) for (r = B[i]; r !== 0;)(n = F[--t]) > d || (s[n].dl !== i && (Y += (i - s[n].dl) * s[n].fc, s[n].fc = i), r--) } }(e)), ct(n, a) } function dt (e, t) { var r; var n; var i = -1; var o = e[0].dl; var a = 0; var s = 7; var c = 4; for (o === 0 && (s = 138, c = 3), e[t + 1].dl = 65535, r = 0; r <= t; r++)n = o, o = e[r + 1].dl, ++a < s && n === o || (a < c ? D[n].fc += a : n !== 0 ? (n !== i && D[n].fc++, D[Ae].fc++) : a <= 10 ? D[Me].fc++ : D[xe].fc++, a = 0, i = n, o === 0 ? (s = 138, c = 3) : n === o ? (s = 6, c = 3) : (s = 7, c = 4)) } function lt (e, t) { var r; var n; var i = -1; var o = e[0].dl; var a = 0; var s = 7; var c = 4; for (o === 0 && (s = 138, c = 3), r = 0; r <= t; r++) if (n = o, o = e[r + 1].dl, !(++a < s && n === o)) { if (a < c) do { Ke(n, D) } while (--a != 0); else n !== 0 ? (n !== i && (Ke(n, D), a--), Ke(Ae, D), vt(a - 3, 2)) : a <= 10 ? (Ke(Me, D), vt(a - 3, 3)) : (Ke(xe, D), vt(a - 11, 7)); a = 0, i = n, o === 0 ? (s = 138, c = 3) : n === o ? (s = 6, c = 3) : (s = 7, c = 4) } } function ht (e) { var t, r, n, i, o; if (i = _ - p, J[Q] = K, ut(L), ut(j), n = (function () { var e; for (dt(A, L.max_code), dt(M, j.max_code), ut(N), e = Pe - 1; e >= 3 && D[Ge[e]].dl === 0; e--); return Y += 3 * (e + 1) + 5 + 5 + 4, e }()), (r = ee + 3 + 7 >> 3) <= (t = Y + 3 + 7 >> 3) && (t = r), i + 4 <= t && p >= 0) for (vt((ie << 1) + e, 3), yt(), Xe(i), Xe(~i), o = 0; o < i; o++)qe(c[p + o]); else r === t ? (vt((oe << 1) + e, 3), pt(x, O)) : (vt((ae << 1) + e, 3), (function (e, t, r) { var n; for (vt(e - 257, 5), vt(t - 1, 5), vt(r - 4, 4), n = 0; n < r; n++)vt(D[Ge[n]].dl, 3); lt(A, e - 1), lt(M, t - 1) }(L.max_code + 1, j.max_code + 1, n + 1)), pt(A, M)); at(), e !== 0 && yt() } function ft (e, t) { if (d[q++] = t, e === 0 ? A[t].fc++ : (e--, A[G[t] + Ce + 1].fc++, M[Ze(e)].fc++, u[X++] = e, K |= Z), Z <<= 1, (7 & q) == 0 && (J[Q++] = K, K = 0, Z = 1), R > 2 && (4095 & q) == 0) { var r; var n = 8 * q; var i = _ - p; for (r = 0; r < Ie; r++)n += M[r].fc * (5 + $e[r]); if (n >>= 3, X < parseInt(q / 2, 10) && n < parseInt(i / 2, 10)) return !0 } return q === he - 1 || X === fe } function pt (e, t) { var r; var n; var i; var o; var a = 0; var s = 0; var c = 0; var l = 0; if (q !== 0) do { (7 & a) == 0 && (l = J[c++]), n = 255 & d[a++], (1 & l) == 0 ? Ke(n, e) : (Ke((i = G[n]) + Ce + 1, e), (o = Ue[i]) !== 0 && vt(n -= H[i], o), Ke(i = Ze(r = u[s++]), t), (o = $e[i]) !== 0 && vt(r -= z[i], o)), l >>= 1 } while (a < q); Ke(Ee, e) } var mt = 16; function vt (e, t) { f > mt - t ? (Xe(h |= e << f), h = e >> mt - f, f += t - mt) : (h |= e << f, f += t) } function gt (e, t) { var r = 0; do { r |= 1 & e, e >>= 1, r <<= 1 } while (--t > 0); return r >> 1 } function yt () { f > 8 ? Xe(h) : f > 0 && qe(h), h = 0, f = 0 } e.exports = function (e, o) { var a, s; te = e, re = 0, void 0 === o && (o = se), (function (e) { var o; if (e ? e < 1 ? e = 1 : e > 9 && (e = 9) : e = se, R = e, i = !1, T = !1, Le === null) { for (t = r = n = null, Le = [], c = [], u = [], d = [], l = [], A = [], o = 0; o < Oe; o++)A[o] = new je(); for (M = [], o = 0; o < 2 * Ie + 1; o++)M[o] = new je(); for (x = [], o = 0; o < Re + 2; o++)x[o] = new je(); for (O = [], o = 0; o < Ie; o++)O[o] = new je(); for (D = [], o = 0; o < 2 * Pe + 1; o++)D[o] = new je(); L = new Ne(), j = new Ne(), N = new Ne(), B = [], F = [], V = [], G = [], W = [], H = [], z = [], J = [] } }(o)), s = []; do { a = it(s, s.length, 1024) } while (a > 0); return te = null, s }, e.exports.DEFAULT_LEVEL = se }()) }); var J = (z.DEFAULT_LEVEL, l(function (e) { e.exports = { inflate: H, deflate: z } })); var q = l(function (e) { !(function () { var t = W; var r = J; var n = 31; var i = 139; var o = { deflate: 8 }; var a = { FTEXT: 1, FHCRC: 2, FEXTRA: 4, FNAME: 8, FCOMMENT: 16 }; var s = { fat: 0, amiga: 1, vmz: 2, unix: 3, 'vm/cms': 4, atari: 5, hpfs: 6, macintosh: 7, 'z-system': 8, cplm: 9, 'tops-20': 10, ntfs: 11, qdos: 12, acorn: 13, vfat: 14, vms: 15, beos: 16, tandem: 17, theos: 18 }; var c = 'unix'; var u = 6; function d (e, t) { t.push(255 & e) } function l (e, t) { t.push(255 & e), t.push(e >>> 8) } function h (e, t) { l(65535 & e, t), l(e >>> 16, t) } function f (e) { return e.shift() } function p (e) { return e.shift() | e.shift() << 8 } function m (e) { var t = p(e); var r = p(e); return r > 32768 ? ((r -= 32768) << 16 | t) + 32768 * Math.pow(2, 16) : r << 16 | t } function v (e) { for (var t = []; e[0] !== 0;)t.push(String.fromCharCode(e.shift())); return e.shift(), t.join('') } e.exports = { zip: function (e, l) { var f; var p = 0; var m = []; return l || (l = {}), f = l.level || u, typeof e === 'string' && (e = Array.prototype.map.call(e, function (e) { return e.charCodeAt(0) })), d(n, m), d(i, m), d(o.deflate, m), l.name && (p |= a.FNAME), d(p, m), h(l.timestamp || parseInt(Date.now() / 1e3, 10), m), d(f === 1 ? 4 : f === 9 ? 2 : 0, m), d(s[c], m), l.name && ((function (e, t) { var r; var n = e.length; for (r = 0; r < n; r += 1)d(e.charCodeAt(r), t) }(l.name.substring(l.name.lastIndexOf('/') + 1), m)), d(0, m)), r.deflate(e, f).forEach(function (e) { d(e, m) }), h(parseInt(t(e), 16), m), h(e.length, m), m }, unzip: function (e, c) { var u; var d; var l; var h; var g = Array.prototype.slice.call(e, 0); if (f(g) !== n || f(g) !== i) throw 'Not a GZIP file'; if (u = f(g), !(u = Object.keys(o).some(function (e) { return d = e, o[e] === u }))) throw 'Unsupported compression method'; if (l = f(g), m(g), f(g), u = f(g), Object.keys(s).some(function (e) { if (s[e] === u) return !0 }), l & a.FEXTRA && (function (e, t) { var r; var n = []; for (r = 0; r < t; r += 1)n.push(e.shift()) }(g, u = p(g))), l & a.FNAME && v(g), l & a.FCOMMENT && v(g), l & a.FHCRC && p(g), d === 'deflate' && (h = r.inflate(g.splice(0, g.length - 8))), l & a.FTEXT && (h = Array.prototype.map.call(h, function (e) { return String.fromCharCode(e) }).join('')), m(g) !== parseInt(t(h), 16)) throw 'Checksum does not match'; if (m(g) !== h.length) throw 'Size of decompressed file not correct'; return h }, get DEFAULT_LEVEL () { return u } } }()) }); var X = (q.zip, q.unzip, q.DEFAULT_LEVEL, l(function (e) { !(function (t) { function r (e, t) { var r = (65535 & e) + (65535 & t); return (e >> 16) + (t >> 16) + (r >> 16) << 16 | 65535 & r } function n (e, t, n, i, o, a) { return r((s = r(r(t, e), r(i, a))) << (c = o) | s >>> 32 - c, n); var s, c } function i (e, t, r, i, o, a, s) { return n(t & r | ~t & i, e, t, o, a, s) } function o (e, t, r, i, o, a, s) { return n(t & i | r & ~i, e, t, o, a, s) } function a (e, t, r, i, o, a, s) { return n(t ^ r ^ i, e, t, o, a, s) } function s (e, t, r, i, o, a, s) { return n(r ^ (t | ~i), e, t, o, a, s) } function c (e, t) { var n, c, u, d, l; e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t; var h = 1732584193; var f = -271733879; var p = -1732584194; var m = 271733878; for (n = 0; n < e.length; n += 16)c = h, u = f, d = p, l = m, h = i(h, f, p, m, e[n], 7, -680876936), m = i(m, h, f, p, e[n + 1], 12, -389564586), p = i(p, m, h, f, e[n + 2], 17, 606105819), f = i(f, p, m, h, e[n + 3], 22, -1044525330), h = i(h, f, p, m, e[n + 4], 7, -176418897), m = i(m, h, f, p, e[n + 5], 12, 1200080426), p = i(p, m, h, f, e[n + 6], 17, -1473231341), f = i(f, p, m, h, e[n + 7], 22, -45705983), h = i(h, f, p, m, e[n + 8], 7, 1770035416), m = i(m, h, f, p, e[n + 9], 12, -1958414417), p = i(p, m, h, f, e[n + 10], 17, -42063), f = i(f, p, m, h, e[n + 11], 22, -1990404162), h = i(h, f, p, m, e[n + 12], 7, 1804603682), m = i(m, h, f, p, e[n + 13], 12, -40341101), p = i(p, m, h, f, e[n + 14], 17, -1502002290), h = o(h, f = i(f, p, m, h, e[n + 15], 22, 1236535329), p, m, e[n + 1], 5, -165796510), m = o(m, h, f, p, e[n + 6], 9, -1069501632), p = o(p, m, h, f, e[n + 11], 14, 643717713), f = o(f, p, m, h, e[n], 20, -373897302), h = o(h, f, p, m, e[n + 5], 5, -701558691), m = o(m, h, f, p, e[n + 10], 9, 38016083), p = o(p, m, h, f, e[n + 15], 14, -660478335), f = o(f, p, m, h, e[n + 4], 20, -405537848), h = o(h, f, p, m, e[n + 9], 5, 568446438), m = o(m, h, f, p, e[n + 14], 9, -1019803690), p = o(p, m, h, f, e[n + 3], 14, -187363961), f = o(f, p, m, h, e[n + 8], 20, 1163531501), h = o(h, f, p, m, e[n + 13], 5, -1444681467), m = o(m, h, f, p, e[n + 2], 9, -51403784), p = o(p, m, h, f, e[n + 7], 14, 1735328473), h = a(h, f = o(f, p, m, h, e[n + 12], 20, -1926607734), p, m, e[n + 5], 4, -378558), m = a(m, h, f, p, e[n + 8], 11, -2022574463), p = a(p, m, h, f, e[n + 11], 16, 1839030562), f = a(f, p, m, h, e[n + 14], 23, -35309556), h = a(h, f, p, m, e[n + 1], 4, -1530992060), m = a(m, h, f, p, e[n + 4], 11, 1272893353), p = a(p, m, h, f, e[n + 7], 16, -155497632), f = a(f, p, m, h, e[n + 10], 23, -1094730640), h = a(h, f, p, m, e[n + 13], 4, 681279174), m = a(m, h, f, p, e[n], 11, -358537222), p = a(p, m, h, f, e[n + 3], 16, -722521979), f = a(f, p, m, h, e[n + 6], 23, 76029189), h = a(h, f, p, m, e[n + 9], 4, -640364487), m = a(m, h, f, p, e[n + 12], 11, -421815835), p = a(p, m, h, f, e[n + 15], 16, 530742520), h = s(h, f = a(f, p, m, h, e[n + 2], 23, -995338651), p, m, e[n], 6, -198630844), m = s(m, h, f, p, e[n + 7], 10, 1126891415), p = s(p, m, h, f, e[n + 14], 15, -1416354905), f = s(f, p, m, h, e[n + 5], 21, -57434055), h = s(h, f, p, m, e[n + 12], 6, 1700485571), m = s(m, h, f, p, e[n + 3], 10, -1894986606), p = s(p, m, h, f, e[n + 10], 15, -1051523), f = s(f, p, m, h, e[n + 1], 21, -2054922799), h = s(h, f, p, m, e[n + 8], 6, 1873313359), m = s(m, h, f, p, e[n + 15], 10, -30611744), p = s(p, m, h, f, e[n + 6], 15, -1560198380), f = s(f, p, m, h, e[n + 13], 21, 1309151649), h = s(h, f, p, m, e[n + 4], 6, -145523070), m = s(m, h, f, p, e[n + 11], 10, -1120210379), p = s(p, m, h, f, e[n + 2], 15, 718787259), f = s(f, p, m, h, e[n + 9], 21, -343485551), h = r(h, c), f = r(f, u), p = r(p, d), m = r(m, l); return [h, f, p, m] } function u (e) { var t; var r = ''; var n = 32 * e.length; for (t = 0; t < n; t += 8)r += String.fromCharCode(e[t >> 5] >>> t % 32 & 255); return r } function d (e) { var t; var r = []; for (r[(e.length >> 2) - 1] = void 0, t = 0; t < r.length; t += 1)r[t] = 0; var n = 8 * e.length; for (t = 0; t < n; t += 8)r[t >> 5] |= (255 & e.charCodeAt(t / 8)) << t % 32; return r } function l (e) { var t; var r; var n = ''; for (r = 0; r < e.length; r += 1)t = e.charCodeAt(r), n += '0123456789abcdef'.charAt(t >>> 4 & 15) + '0123456789abcdef'.charAt(15 & t); return n } function h (e) { return unescape(encodeURIComponent(e)) } function f (e) { return (function (e) { return u(c(d(e), 8 * e.length)) }(h(e))) } function p (e, t) { return (function (e, t) { var r; var n; var i = d(e); var o = []; var a = []; for (o[15] = a[15] = void 0, i.length > 16 && (i = c(i, 8 * e.length)), r = 0; r < 16; r += 1)o[r] = 909522486 ^ i[r], a[r] = 1549556828 ^ i[r]; return n = c(o.concat(d(t)), 512 + 8 * t.length), u(c(a.concat(n), 640)) }(h(e), h(t))) } function m (e, t, r) { return t ? r ? p(t, e) : l(p(t, e)) : r ? f(e) : l(f(e)) } e.exports ? e.exports = m : t.md5 = m }(u)) })); var Q = l(function (e, t) { var r = 200; var n = 'Expected a function'; var i = '__lodash_hash_undefined__'; var o = 1; var a = 2; var s = 1 / 0; var c = 9007199254740991; var d = '[object Arguments]'; var l = '[object Array]'; var h = '[object Boolean]'; var f = '[object Date]'; var p = '[object Error]'; var m = '[object Function]'; var v = '[object GeneratorFunction]'; var g = '[object Map]'; var y = '[object Number]'; var b = '[object Object]'; var k = '[object RegExp]'; var _ = '[object Set]'; var S = '[object String]'; var T = '[object Symbol]'; var w = '[object ArrayBuffer]'; var C = '[object DataView]'; var E = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/; var R = /^\w*$/; var I = /^\./; var P = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g; var A = /\\(\\)?/g; var M = /^\[object .+?Constructor\]$/; var x = /^(?:0|[1-9]\d*)$/; var O = {}; O['[object Float32Array]'] = O['[object Float64Array]'] = O['[object Int8Array]'] = O['[object Int16Array]'] = O['[object Int32Array]'] = O['[object Uint8Array]'] = O['[object Uint8ClampedArray]'] = O['[object Uint16Array]'] = O['[object Uint32Array]'] = !0, O[d] = O[l] = O[w] = O[h] = O[C] = O[f] = O[p] = O[m] = O[g] = O[y] = O[b] = O[k] = O[_] = O[S] = O['[object WeakMap]'] = !1; var D = typeof u === 'object' && u && u.Object === Object && u; var L = typeof self === 'object' && self && self.Object === Object && self; var j = D || L || Function('return this')(); var N = t && !t.nodeType && t; var B = N && e && !e.nodeType && e; var F = B && B.exports === N && D.process; var U = (function () { try { return F && F.binding('util') } catch (e) { } }()); var $ = U && U.isTypedArray; function V (e, t, r, n) { for (var i = -1, o = e ? e.length : 0; ++i < o;) { var a = e[i]; t(n, a, r(a), e) } return n } function G (e, t) { for (var r = -1, n = e ? e.length : 0; ++r < n;) if (t(e[r], r, e)) return !0; return !1 } function W (e) { var t = !1; if (e != null && typeof e.toString !== 'function') try { t = !!(e + '') } catch (e) { } return t } function H (e) { var t = -1; var r = Array(e.size); return e.forEach(function (e, n) { r[++t] = [n, e] }), r } function z (e) { var t = -1; var r = Array(e.size); return e.forEach(function (e) { r[++t] = e }), r } var J; var q; var X; var Q = Array.prototype; var K = Function.prototype; var Z = Object.prototype; var Y = j['__core-js_shared__']; var ee = (J = /[^.]+$/.exec(Y && Y.keys && Y.keys.IE_PROTO || '')) ? 'Symbol(src)_1.' + J : ''; var te = K.toString; var re = Z.hasOwnProperty; var ne = Z.toString; var ie = RegExp('^' + te.call(re).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'); var oe = j.Symbol; var ae = j.Uint8Array; var se = Z.propertyIsEnumerable; var ce = Q.splice; var ue = (q = Object.keys, X = Object, function (e) { return q(X(e)) }); var de = He(j, 'DataView'); var le = He(j, 'Map'); var he = He(j, 'Promise'); var fe = He(j, 'Set'); var pe = He(j, 'WeakMap'); var me = He(Object, 'create'); var ve = Ye(de); var ge = Ye(le); var ye = Ye(he); var be = Ye(fe); var ke = Ye(pe); var _e = oe ? oe.prototype : void 0; var Se = _e ? _e.valueOf : void 0; var Te = _e ? _e.toString : void 0; function we (e) { var t = -1; var r = e ? e.length : 0; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function Ce (e) { var t = -1; var r = e ? e.length : 0; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function Ee (e) { var t = -1; var r = e ? e.length : 0; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function Re (e) { var t = -1; var r = e ? e.length : 0; for (this.__data__ = new Ee(); ++t < r;) this.add(e[t]) } function Ie (e) { this.__data__ = new Ce(e) } function Pe (e, t) { var r = at(e) || ot(e) ? (function (e, t) { for (var r = -1, n = Array(e); ++r < e;)n[r] = t(r); return n }(e.length, String)) : []; var n = r.length; var i = !!n; for (var o in e) !t && !re.call(e, o) || i && (o == 'length' || Je(o, n)) || r.push(o); return r } function Ae (e, t) { for (var r = e.length; r--;) if (it(e[r][0], t)) return r; return -1 } function Me (e, t, r, n) { return De(e, function (e, i, o) { t(n, e, r(e), o) }), n } we.prototype.clear = function () { this.__data__ = me ? me(null) : {} }, we.prototype.delete = function (e) { return this.has(e) && delete this.__data__[e] }, we.prototype.get = function (e) { var t = this.__data__; if (me) { var r = t[e]; return r === i ? void 0 : r } return re.call(t, e) ? t[e] : void 0 }, we.prototype.has = function (e) { var t = this.__data__; return me ? void 0 !== t[e] : re.call(t, e) }, we.prototype.set = function (e, t) { return this.__data__[e] = me && void 0 === t ? i : t, this }, Ce.prototype.clear = function () { this.__data__ = [] }, Ce.prototype.delete = function (e) { var t = this.__data__; var r = Ae(t, e); return !(r < 0 || (r == t.length - 1 ? t.pop() : ce.call(t, r, 1), 0)) }, Ce.prototype.get = function (e) { var t = this.__data__; var r = Ae(t, e); return r < 0 ? void 0 : t[r][1] }, Ce.prototype.has = function (e) { return Ae(this.__data__, e) > -1 }, Ce.prototype.set = function (e, t) { var r = this.__data__; var n = Ae(r, e); return n < 0 ? r.push([e, t]) : r[n][1] = t, this }, Ee.prototype.clear = function () { this.__data__ = { hash: new we(), map: new (le || Ce)(), string: new we() } }, Ee.prototype.delete = function (e) { return We(this, e).delete(e) }, Ee.prototype.get = function (e) { return We(this, e).get(e) }, Ee.prototype.has = function (e) { return We(this, e).has(e) }, Ee.prototype.set = function (e, t) { return We(this, e).set(e, t), this }, Re.prototype.add = Re.prototype.push = function (e) { return this.__data__.set(e, i), this }, Re.prototype.has = function (e) { return this.__data__.has(e) }, Ie.prototype.clear = function () { this.__data__ = new Ce() }, Ie.prototype.delete = function (e) { return this.__data__.delete(e) }, Ie.prototype.get = function (e) { return this.__data__.get(e) }, Ie.prototype.has = function (e) { return this.__data__.has(e) }, Ie.prototype.set = function (e, t) { var n = this.__data__; if (n instanceof Ce) { var i = n.__data__; if (!le || i.length < r - 1) return i.push([e, t]), this; n = this.__data__ = new Ee(i) } return n.set(e, t), this }; var xe; var Oe; var De = (xe = function (e, t) { return e && Le(e, t, pt) }, function (e, t) { if (e == null) return e; if (!st(e)) return xe(e, t); for (var r = e.length, n = Oe ? r : -1, i = Object(e); (Oe ? n-- : ++n < r) && !1 !== t(i[n], n, i);); return e }); var Le = (function (e) { return function (t, r, n) { for (var i = -1, o = Object(t), a = n(t), s = a.length; s--;) { var c = a[e ? s : ++i]; if (!1 === r(o[c], c, o)) break } return t } }()); function je (e, t) { for (var r = 0, n = (t = qe(t, e) ? [t] : Ve(t)).length; e != null && r < n;)e = e[Ze(t[r++])]; return r && r == n ? e : void 0 } function Ne (e, t) { return e != null && t in Object(e) } function Be (e, t, r, n, i) { return e === t || (e == null || t == null || !dt(e) && !lt(t) ? e != e && t != t : (function (e, t, r, n, i, s) { var c = at(e); var u = at(t); var m = l; var v = l; c || (m = (m = ze(e)) == d ? b : m); u || (v = (v = ze(t)) == d ? b : v); var E = m == b && !W(e); var R = v == b && !W(t); var I = m == v; if (I && !E) return s || (s = new Ie()), c || ft(e) ? Ge(e, t, r, n, i, s) : (function (e, t, r, n, i, s, c) { switch (r) { case C: if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1; e = e.buffer, t = t.buffer; case w: return !(e.byteLength != t.byteLength || !n(new ae(e), new ae(t))); case h: case f: case y: return it(+e, +t); case p: return e.name == t.name && e.message == t.message; case k: case S: return e == t + ''; case g: var u = H; case _: var d = s & a; if (u || (u = z), e.size != t.size && !d) return !1; var l = c.get(e); if (l) return l == t; s |= o, c.set(e, t); var m = Ge(u(e), u(t), n, i, s, c); return c.delete(e), m; case T: if (Se) return Se.call(e) == Se.call(t) } return !1 }(e, t, m, r, n, i, s)); if (!(i & a)) { var P = E && re.call(e, '__wrapped__'); var A = R && re.call(t, '__wrapped__'); if (P || A) { var M = P ? e.value() : e; var x = A ? t.value() : t; return s || (s = new Ie()), r(M, x, n, i, s) } } if (!I) return !1; return s || (s = new Ie()), (function (e, t, r, n, i, o) { var s = i & a; var c = pt(e); var u = c.length; var d = pt(t).length; if (u != d && !s) return !1; for (var l = u; l--;) { var h = c[l]; if (!(s ? h in t : re.call(t, h))) return !1 } var f = o.get(e); if (f && o.get(t)) return f == t; var p = !0; o.set(e, t), o.set(t, e); for (var m = s; ++l < u;) { h = c[l]; var v = e[h]; var g = t[h]; if (n) var y = s ? n(g, v, h, t, e, o) : n(v, g, h, e, t, o); if (!(void 0 === y ? v === g || r(v, g, n, i, o) : y)) { p = !1; break } m || (m = h == 'constructor') } if (p && !m) { var b = e.constructor; var k = t.constructor; b != k && 'constructor' in e && 'constructor' in t && !(typeof b === 'function' && b instanceof b && typeof k === 'function' && k instanceof k) && (p = !1) } return o.delete(e), o.delete(t), p }(e, t, r, n, i, s)) }(e, t, Be, r, n, i))) } function Fe (e) { return !(!dt(e) || (t = e, ee && ee in t)) && (ct(e) || W(e) ? ie : M).test(Ye(e)); var t } function Ue (e) { return typeof e === 'function' ? e : e == null ? mt : typeof e === 'object' ? at(e) ? (function (e, t) { if (qe(e) && Xe(t)) return Qe(Ze(e), t); return function (r) { var n = (function (e, t, r) { var n = e == null ? void 0 : je(e, t); return void 0 === n ? r : n }(r, e)); return void 0 === n && n === t ? (function (e, t) { return e != null && (function (e, t, r) { t = qe(t, e) ? [t] : Ve(t); var n; var i = -1; var o = t.length; for (; ++i < o;) { var a = Ze(t[i]); if (!(n = e != null && r(e, a))) break; e = e[a] } if (n) return n; return !!(o = e ? e.length : 0) && ut(o) && Je(a, o) && (at(e) || ot(e)) }(e, t, Ne)) }(r, e)) : Be(t, n, void 0, o | a) } }(e[0], e[1])) : (function (e) { var t = (function (e) { var t = pt(e); var r = t.length; for (; r--;) { var n = t[r]; var i = e[n]; t[r] = [n, i, Xe(i)] } return t }(e)); if (t.length == 1 && t[0][2]) return Qe(t[0][0], t[0][1]); return function (r) { return r === e || (function (e, t, r, n) { var i = r.length; var s = i; var c = !n; if (e == null) return !s; for (e = Object(e); i--;) { var u = r[i]; if (c && u[2] ? u[1] !== e[u[0]] : !(u[0] in e)) return !1 } for (; ++i < s;) { var d = (u = r[i])[0]; var l = e[d]; var h = u[1]; if (c && u[2]) { if (void 0 === l && !(d in e)) return !1 } else { var f = new Ie(); if (n) var p = n(l, h, d, e, t, f); if (!(void 0 === p ? Be(h, l, n, o | a, f) : p)) return !1 } } return !0 }(r, e, t)) } }(e)) : qe(t = e) ? (r = Ze(t), function (e) { return e == null ? void 0 : e[r] }) : (function (e) { return function (t) { return je(t, e) } }(t)); var t, r } function $e (e) { if (r = (t = e) && t.constructor, n = typeof r === 'function' && r.prototype || Z, t !== n) return ue(e); var t; var r; var n; var i = []; for (var o in Object(e)) re.call(e, o) && o != 'constructor' && i.push(o); return i } function Ve (e) { return at(e) ? e : Ke(e) } function Ge (e, t, r, n, i, s) { var c = i & a; var u = e.length; var d = t.length; if (u != d && !(c && d > u)) return !1; var l = s.get(e); if (l && s.get(t)) return l == t; var h = -1; var f = !0; var p = i & o ? new Re() : void 0; for (s.set(e, t), s.set(t, e); ++h < u;) { var m = e[h]; var v = t[h]; if (n) var g = c ? n(v, m, h, t, e, s) : n(m, v, h, e, t, s); if (void 0 !== g) { if (g) continue; f = !1; break } if (p) { if (!G(t, function (e, t) { if (!p.has(t) && (m === e || r(m, e, n, i, s))) return p.add(t) })) { f = !1; break } } else if (m !== v && !r(m, v, n, i, s)) { f = !1; break } } return s.delete(e), s.delete(t), f } function We (e, t) { var r; var n; var i = e.__data__; return ((n = typeof (r = t)) == 'string' || n == 'number' || n == 'symbol' || n == 'boolean' ? r !== '__proto__' : r === null) ? i[typeof t === 'string' ? 'string' : 'hash'] : i.map } function He (e, t) { var r = (function (e, t) { return e == null ? void 0 : e[t] }(e, t)); return Fe(r) ? r : void 0 } var ze = function (e) { return ne.call(e) }; function Je (e, t) { return !!(t = t == null ? c : t) && (typeof e === 'number' || x.test(e)) && e > -1 && e % 1 == 0 && e < t } function qe (e, t) { if (at(e)) return !1; var r = typeof e; return !(r != 'number' && r != 'symbol' && r != 'boolean' && e != null && !ht(e)) || (R.test(e) || !E.test(e) || t != null && e in Object(t)) } function Xe (e) { return e == e && !dt(e) } function Qe (e, t) { return function (r) { return r != null && (r[e] === t && (void 0 !== t || e in Object(r))) } } (de && ze(new de(new ArrayBuffer(1))) != C || le && ze(new le()) != g || he && ze(he.resolve()) != '[object Promise]' || fe && ze(new fe()) != _ || pe && ze(new pe()) != '[object WeakMap]') && (ze = function (e) { var t = ne.call(e); var r = t == b ? e.constructor : void 0; var n = r ? Ye(r) : void 0; if (n) switch (n) { case ve: return C; case ge: return g; case ye: return '[object Promise]'; case be: return _; case ke: return '[object WeakMap]' } return t }); var Ke = nt(function (e) { var t; e = (t = e) == null ? '' : (function (e) { if (typeof e === 'string') return e; if (ht(e)) return Te ? Te.call(e) : ''; var t = e + ''; return t == '0' && 1 / e == -s ? '-0' : t }(t)); var r = []; return I.test(e) && r.push(''), e.replace(P, function (e, t, n, i) { r.push(n ? i.replace(A, '$1') : t || e) }), r }); function Ze (e) { if (typeof e === 'string' || ht(e)) return e; var t = e + ''; return t == '0' && 1 / e == -s ? '-0' : t } function Ye (e) { if (e != null) { try { return te.call(e) } catch (e) { } try { return e + '' } catch (e) { } } return '' } var et; var tt; var rt = (et = function (e, t, r) { re.call(e, r) ? e[r].push(t) : e[r] = [t] }, function (e, t) { var r = at(e) ? V : Me; var n = tt ? tt() : {}; return r(e, et, Ue(t), n) }); function nt (e, t) { if (typeof e !== 'function' || t && typeof t !== 'function') throw new TypeError(n); var r = function () { var n = arguments; var i = t ? t.apply(this, n) : n[0]; var o = r.cache; if (o.has(i)) return o.get(i); var a = e.apply(this, n); return r.cache = o.set(i, a), a }; return r.cache = new (nt.Cache || Ee)(), r } function it (e, t) { return e === t || e != e && t != t } function ot (e) { return (function (e) { return lt(e) && st(e) }(e)) && re.call(e, 'callee') && (!se.call(e, 'callee') || ne.call(e) == d) } nt.Cache = Ee; var at = Array.isArray; function st (e) { return e != null && ut(e.length) && !ct(e) } function ct (e) { var t = dt(e) ? ne.call(e) : ''; return t == m || t == v } function ut (e) { return typeof e === 'number' && e > -1 && e % 1 == 0 && e <= c } function dt (e) { var t = typeof e; return !!e && (t == 'object' || t == 'function') } function lt (e) { return !!e && typeof e === 'object' } function ht (e) { return typeof e === 'symbol' || lt(e) && ne.call(e) == T } var ft = $ ? (function (e) { return function (t) { return e(t) } }($)) : function (e) { return lt(e) && ut(e.length) && !!O[ne.call(e)] }; function pt (e) { return st(e) ? Pe(e) : $e(e) } function mt (e) { return e } e.exports = rt }); const K = '2.4.0'; function Z () { const e = new Date(); function t (e) { const t = e.toString(); return t.length < 2 ? '0' + t : t } return `[${t(e.getHours())}:${t(e.getMinutes())}:${t(e.getSeconds())}.${e.getMilliseconds()}]` } const Y = new class { constructor (e) { this.level = e } setLevel (e) { this.level = e } log (...e) { if (this.level !== 'log') return; const t = `${Z()} %cLOG-QNRTC`; console.info(t, 'color: #66ccff; font-weight: bold;', ...e) } debug (...e) { if (this.level !== 'log' && this.level !== 'debug') return; const t = `${Z()} %cDEBUG-QNRTC`; console.info(t, 'color: #A28148; font-weight: bold;', ...e) } warning (...e) { if (this.level === 'disable') return; const t = `${Z()} %cWARNING-QNRTC`; console.warn(t, 'color: #E44F44; font-weight: bold;', ...e) } }('log'); class ee { constructor (e, t = ee.AlphaForPacketLossFractionSmoother) { this.mLastFilteredTimestamp = Date.now(), this.mMax = ee.kValueUndefined, this.smooth_interval = e === 'audio' ? ee.SMOOTH_AUDIO_INTERVAL : ee.SMOOTH_VIDEO_INTERVAL, this.Reset(t) } Reset (e) { this.mAlpha = e, this.mFiltered = ee.kValueUndefined } Apply (e) { const t = Date.now() - this.mLastFilteredTimestamp; if (t < this.smooth_interval && e === 0) return void (this.applied = !1); let r; if (this.mFiltered === ee.kValueUndefined) r = e; else if (t === 1) r = this.mAlpha * this.mFiltered + (1 - this.mAlpha) * e; else { const n = Math.pow(this.mAlpha, t); r = n * this.mFiltered + (1 - n) * e } isNaN(r) || (this.mFiltered = r), this.mMax !== ee.kValueUndefined && this.mFiltered > this.mMax && (this.mFiltered = this.mMax), this.mLastFilteredTimestamp = Date.now(), this.applied = !0 } Filtered () { return this.mFiltered } LastFilteredTime () { return this.mLastFilteredTimestamp } UpdateBase (e) { this.mAlpha = e } } function te () { const e = {}; return (t, r) => t in e ? e[t] : (e[t] = new ee(r), e[t]) } ee.kValueUndefined = -1, ee.AlphaForPacketLossFractionSmoother = 0.9999, ee.SMOOTH_VIDEO_INTERVAL = 1e3, ee.SMOOTH_AUDIO_INTERVAL = 5e3; const re = te(); const ne = te(); const ie = () => ({ id: '', kind: 'audio', packetLossRate: 0, bitrate: 0, bytes: 0, packets: 0, packetLoss: 0, rtt: 0, timestamp: Date.now() }); const oe = { track_audio_volume: 0, jitter_buffer_delay: 0, bytes_sent: 0, bytes_received: 0 }; const ae = { nack_count: 0, fir_count: 0, pli_count: 0, width: 0, height: 0, jitter_buffer_delay: 0, bytes_sent: 0, frame_encoded: 0, bytes_received: 0, frame_decoded: 0 }; const se = { frames_received: 0, frames_sent: 0, packets_lost: 0, packets_received: 0, packets_sent: 0, timestamp: 0, bytes_sent: 0, bytes_received: 0 }; var ce, ue, de; async function le (e) { let t; try { t = await e.getStats() } catch (e) { return Y.debug('get media statistic stats error, fallback to default', e), [] } if (!t) return Y.debug('get null media statistic stats, fallback to default'), []; const n = [...t.values()]; return n.filter(e => e.type === ue.InBoundRtp || e.type === ue.OutBoundRtp).map(e => (function (e, t) { const n = { [ue.MediaSource]: t.filter(e => e.type === ue.MediaSource).find(t => t.id === e.mediaSourceId), [ue.Track]: t.filter(e => e.type === ue.Track).find(t => t.id === e.trackId), [ue.RemoteInBound]: t.filter(e => e.type === ue.RemoteInBound).find(t => t.id === e.remoteId) }; let i = (function (e, t, n) { const i = { id: e, track_id: t, kind: 'audio', kbps: 0, framerate: 0, packet_lost_rate: 0, rtt: 0, extra_stats: null, calculation_stats: r({}, se) }; return n === ce.Audio ? i.extra_stats = r({}, oe) : i.extra_stats = r({}, ae), i }(e.id, e.trackId, e.mediaType)); i.rtt = he(n[ue.RemoteInBound]) || he(e) || 0, i.calculation_stats.packets_lost = fe(e, n[ue.RemoteInBound]) || 0, e.mediaType === ce.Video ? (i = (function (e, t) { return t.kind = e.kind, t.extra_stats.nack_count = e.nackCount, t.extra_stats.fir_count = e.firCount, t.extra_stats.pli_count = e.pliCount, t.extra_stats.bytes_sent = e.bytesSent || 0, t.extra_stats.frame_encoded = e.framesEncoded || 0, t.extra_stats.bytes_received = e.bytesReceived || 0, t.extra_stats.frame_decoded = e.framesDecoded || 0, t.calculation_stats.bytes_received = e.bytesReceived || 0, t.calculation_stats.bytes_sent = e.bytesSent || 0, t.calculation_stats.packets_received = e.packetsReceived || 0, t.calculation_stats.packets_sent = e.packetsSent || 0, t.calculation_stats.timestamp = e.timestamp || 0, t }(e, i)), n[ue.MediaSource] && (i = (function (e, t) { return t.framerate = e.framesPerSecond, t }(n[ue.MediaSource], i))), n[ue.Track] && (i = (function (e, t) { return t.track_id = e.trackIdentifier, t.extra_stats.width = e.frameWidth, t.extra_stats.height = e.frameHeight, t.extra_stats.jitter_buffer_delay = e.jitterBufferDelay || 0, t.calculation_stats.frames_sent = e.framesSent || 0, t.calculation_stats.frames_received = e.framesReceived || 0, t }(n[ue.Track], i)))) : (i = (function (e, t) { return t.kind = e.kind, t.extra_stats.bytes_sent = e.bytesSent || 0, t.extra_stats.bytes_received = e.bytesReceived || 0, t.calculation_stats.bytes_received = e.bytesReceived || 0, t.calculation_stats.bytes_sent = e.bytesSent || 0, t.calculation_stats.packets_received = e.packetsReceived || 0, t.calculation_stats.packets_sent = e.packetsSent || 0, t.calculation_stats.timestamp = e.timestamp || 0, t }(e, i)), n[ue.MediaSource] && (i = (function (e, t) { return t.extra_stats.track_audio_volume = e.audioLevel, t }(n[ue.MediaSource], i))), n[ue.Track] && (i = (function (e, t) { return t.track_id = e.trackIdentifier, t.extra_stats.jitter_buffer_delay = e.jitterBufferDelay || 0, t.calculation_stats.frames_sent = e.framesSent || 0, t.calculation_stats.frames_received = e.framesReceived || 0, t }(n[ue.Track], i)))); return i })(e, n)) } function he (e) { if (e) return e.roundTripTime ? 1e3 * e.roundTripTime : e.googRtt ? e.googRtt : e.mozRtt ? e.mozRtt : void 0 } function fe (e, t) { return e.type === 'inbound-rtp' ? e.packetsLost : e.type === 'outbound-rtp' && t ? t.packetsLost : void 0 } function pe (e, t, r, n) { const i = t - e; const o = n - r; if (i <= 0 || o <= 0) return 0; const a = i / o; return a > 1 ? 1 : a } !(function (e) { e.Video = 'video', e.Audio = 'audio' }(ce || (ce = {}))), (function (e) { e.MediaSource = 'media-source', e.Track = 'track', e.OutBoundRtp = 'outbound-rtp', e.InBoundRtp = 'inbound-rtp', e.RemoteInBound = 'remote-inbound-rtp' }(ue || (ue = {}))), (function (e) { e.In = 'in', e.Out = 'out' }(de || (de = {}))); class me extends E { constructor (e, t = !0) { super(), this._closed = !1, this._busy = !1, this._queue = [], this.name = e || 'TaskQueue', this.isDebug = t } close () { this._closed = !0 } push (e, t) { return this.isDebug && Y.debug(`${this.name} push()`, e, t), new Promise((r, n) => { this._queue.push({ method: e, data: t, resolve: r, reject: n }), this._handlePendingCommands() }) } _handlePendingCommands () { if (this._busy) return; const e = this._queue; const t = e[0]; t && (this._busy = !0, this._handleCommand(t).then(() => { this._busy = !1, e.shift(), this._handlePendingCommands() })) } _handleCommand (e) { if (this.isDebug && Y.debug(`${this.name} _handleCommand() `, e.method, e.data), this._closed) return e.reject(new Ue('closed')), Promise.resolve(); const t = { promise: null }; return this.emit('exec', e, t), Promise.resolve().then(() => t.promise).then(t => { this.isDebug && Y.debug(`${this.name} _handleCommand() | command succeeded`, e.method), this._closed ? e.reject(new Ue('closed')) : e.resolve(t) }).catch(t => { this.isDebug && Y.warning(`${this.name} _handleCommand() | command failed [method:%s]: %o`, e.method, t), e.reject(t) }) } } const ve = 'qnrtcqosevents'; function ge (e) { const t = []; for (let r = 0; r < e.length; r++) { let n = e.charCodeAt(r); n < 128 ? t.push(n) : n < 2048 ? t.push(192 | n >> 6, 128 | 63 & n) : n < 55296 || n >= 57344 ? t.push(224 | n >> 12, 128 | n >> 6 & 63, 128 | 63 & n) : (r++, n = 65536 + ((1023 & n) << 10 | 1023 & e.charCodeAt(r)), t.push(240 | n >> 18, 128 | n >> 12 & 63, 128 | n >> 6 & 63, 128 | 63 & n)) } return new Uint8Array(t) } const ye = new class { constructor () { this.events = [], this.lastSubmitTime = Date.now(), this.submitQueue = new me('qossubmit', !1), new Promise((e, t) => { window.requestIdleCallback ? window.requestIdleCallback(() => { V.get(t => { const r = X(JSON.stringify(t)); e(r) }) }) : setTimeout(() => { V.get(t => { const r = X(JSON.stringify(t)); e(r) }) }, 500) }).then(e => { this.deviceId = e, this.base.device_id = this.deviceId }), this.base = { qos_version: '2.0', device_id: '', bundle_id: window.location.href, app_version: '', sdk_version: K, device_model: `${k.name}${k.version}`, os_platform: k.os, os_version: '' }, this.initSubmitQueue(), this.submitQueue.push('resume').catch(We) } setSessionId (e) { for (let t = this.events.length - 1; t >= 0; t -= 1) { const r = this.events[t]; if (r.session_id) break; r.session_id = e } this.sessionId = e } setUserBase (e, t, r) { this.userBase = { user_id: e, room_name: t, app_id: r }; for (let e = this.events.length - 1; e >= 0; e -= 1) { const t = this.events[e]; if (t.user_base) break; t.user_base = this.userBase } } addEvent (e, t, n) { const i = r({ timestamp: Date.now(), event_id: $[e], event_name: e }, t); this.submitQueue.push('add', i).catch(We), this.submit(n) } addMediaStatistics (e, t) { const n = e.map((e, n) => { const i = ne(e.id, e.kind); const o = t && t[n]; const { calculation_stats: a } = e; const s = A(e, ['calculation_stats']); return r({}, s, (function (e, t, r) { if (!e || !t) return { framerate: 0, kbps: 0, packet_lost_rate: 0 }; const n = (e.timestamp - t.timestamp) / 1e3; const i = n === 0 ? 0 : (e.frames_sent - t.frames_sent + (e.frames_received - t.frames_received)) / n; const o = n === 0 ? 0 : (e.bytes_sent - t.bytes_sent + (e.bytes_received - t.bytes_received)) / (1024 * n / 8); const a = pe(t.packets_lost, e.packets_lost, t.packets_received + t.packets_sent, e.packets_received + e.packets_sent); r.Apply(a); const s = r.Filtered() < 0 ? 0 : 100 * r.Filtered(); return { framerate: Math.ceil(i), kbps: Math.ceil(o), packet_lost_rate: Math.ceil(s) } }(a, o, i))) }); Y.log('media statistics', n), this.addEvent('MediaStatistics', { cpu_loading: 0, track_stats: n }) } submit (e = !1) { this.submitQueue.push('submit', e).catch(We) } initSubmitQueue () { this.submitQueue.on('exec', (e, t) => { switch (e.method) { case 'submit': return void (t.promise = this._submit(e.data)); case 'add': return void (t.promise = this._addEvent(e.data)); case 'resume': return void (t.promise = this._recoverStoredEvents()) } }) } async _recoverStoredEvents () { const e = await G.getItem(ve); Y.log('get item', e), await G.removeItem(ve), e && (this.events = JSON.parse(window.atob(decodeURIComponent(e))), this.events = this.events.filter(e => !!e.session_id && !!e.user_base).sort((e, t) => e.event.timestamp - t.event.timestamp)) } _addEvent (e) { return this.events.push({ user_base: this.userBase, event: e, session_id: this.sessionId }), this.submit(), Promise.resolve() } saveEvents () { const e = encodeURIComponent(window.btoa(JSON.stringify(this.events))); G.setItem(ve, e).catch(We) } submitCheck () { return !!(this.sessionId && this.deviceId && this.userBase) && (Date.now() - this.lastSubmitTime > 3e5 || this.events.length >= 30) } async _submit (e = !1) { if (e || this.submitCheck()) try { const e = this.encodeQosSubmitData(); for (const t of e) if (!(await fetch('https://pili-rtc-qos.qiniuapi.com/v1/rtcevent', { method: 'POST', headers: { 'Content-Type': 'application/x-gzip' }, body: t.buffer })).ok) throw Se('rtcevent error'); this.lastSubmitTime = Date.now(), this.events = [], await G.removeItem(ve) } catch (e) { Y.log(e) } else this.saveEvents() } encodeQosSubmitData () { const e = Q(this.events, e => e.session_id || '' + JSON.stringify(e.user_base)); const t = []; for (const r in e) { const n = e[r]; if (n.length === 0) continue; const i = { session_id: n[0].session_id, user_base: n[0].user_base, base: this.base, items: n.map(e => e.event) }; Y.log('encode', i); const o = new Uint8Array(q.zip(ge(JSON.stringify(i)))); t.push(o) } return t } }(); { const t = navigator; function be (t, r) { let n; switch (t) { case 'prompt': n = e.PermissionStateCode.prompt; break; case 'granted': n = e.PermissionStateCode.granted; break; case 'denied': n = e.PermissionStateCode.denied; break; default: return }ye.addEvent('AuthorizationStatus', { type: r, status: n }) } function ke (r) { t && t.permissions && t.permissions.query({ name: r }).then(t => { be(t.state, e.PermissionNameCode[r]), t.onchange = () => { be(t.state, e.PermissionNameCode[r]) } }).catch(e => { Y.debug('error when queryPermission', e) }) } ke('camera'), ke('microphone') } document.visibilityState && document.addEventListener('visibilitychange', () => { ye.addEvent('ApplicationState', { state: document.visibilityState === 'visible' ? 0 : 2 }) }); class _e extends Error { constructor (e, t) { super(t), this.code = e, this.error = t, ye.addEvent('SDKError', { error_code: e, error_msg: t }) } } const Se = e => new _e(11e3, `piliRTC: unexpected error ${e}`); const Te = e => new _e(11001, `enterRoom error, can not get accessToken. Error: ${e}\n please check enterRoom arguments`); const we = (e, t) => new _e(e, `publish error, signaling code: ${e}, msg: ${t}`); const Ce = (e, t) => new _e(e, `create merge job error, signaling code: ${e}, msg: ${t}`); const Ee = e => new _e(11005, `subscribe faild, can not create p2p connection, ${e}`); const Re = e => new _e(11006, `publish faild, can not create p2p connection, ${e}`); const Ie = e => new _e(11007, `media format not support, ${e}`); const Pe = (e, t) => new _e(e, `subscribe error, signaling code: ${e}, msg: ${t}`); const Ae = (e, t) => new _e(e, `send control error, code: ${e}, msg: ${t}`); const Me = e => new _e(11008, `not support! ${e}`); const xe = () => new _e(10052, 'server unavailable'); const Oe = e => new _e(11009, `plugin not avaliable! ${e}`); const De = e => new _e(11010, `NotAllowedError: no permission to access media device. ${e}`); const Le = e => new _e(11012, `can not set merge layout stream, no merge job id ${e}`); const je = () => new _e(11013, 'can not sharing screen/window on chrome'); const Ne = () => new _e(11014, 'subscribe/publish operation is aborted'); const Be = e => new _e(11015, `can not decode audio data, ${e.toString()}`); const Fe = () => new _e(30001, 'websocket abort'); class Ue extends Error { constructor (e) { super(e), this.name = 'InvalidStateError', Error.hasOwnProperty('captureStackTrace') ? Error.captureStackTrace(this, Ue) : this.stack = new Error(e).stack } } var $e = Object.freeze({ QNRTCError: _e, UNEXPECTED_ERROR: Se, AUTH_ENTER_ROOM_ERROR: Te, PUBLISH_ERROR: we, CREATE_MERGE_JOB_ERROR: Ce, PUBLISH_ICE_ERROR: () => new _e(11002, 'publish faild, ice not ready'), SUB_ICE_ERROR: () => new _e(11003, 'subscribe faild, ice not ready'), SUB_ERROR_NO_STREAM: e => new _e(11004, `subscribe faild, can not find this player in streams, userId: ${e}`), SUB_P2P_ERROR: Ee, PUB_P2P_ERROR: Re, UNSUPPORT_FMT: Ie, JOIN_ROOM_ERROR: (e, t) => new _e(e, `joinRoom error, code: ${e}, ${t}`), SUB_ERROR: Pe, UNPUBLISH_ERROR: (e, t) => new _e(e, 'unpublish error, code: ${code}, msg: ${msg}'), UNSUB_ERROR: (e, t) => new _e(e, 'unsubscribe error, code: ${code}, msg: ${msg}'), CONTROL_ERROR: Ae, NOT_SUPPORT_ERROR: Me, SERVER_UNAVAILABLE: xe, PLUGIN_NOT_AVALIABLE: Oe, DEVICE_NOT_ALLOWED: De, SUB_ERROR_NO_USER: e => new _e(11011, `subscribe faild, can not find this user in room, userId: ${e}`), NO_MERGE_JOB: Le, SCREEN_PERMISSION_DENIED: je, SUB_PUB_ABORT: Ne, AUDIO_DECODE_ERROR: Be, AUTO_SWITCH_ERROR: e => new _e(20001, `deviceManager auto switch error. ${e}`), WS_ABORT: Fe, InvalidStateError: Ue }); function Ve (e) { try { const t = e.split(':')[2]; const r = atob(t); return JSON.parse(r) } catch (e) { throw Se(`can not parse roomToken, ${e}`) } } function Ge (e, t, r) { if (!r) return null; for (let n = 0; n < e.length; n += 1) { const i = e[n]; if (i[t] === r) return i } return null } function We () { } function He (e) { Promise.resolve().then(e) } function ze (e) { return ('0' + e.toString(16)).substr(-2) } function Je (e = 5) { const t = new Uint8Array((e || 40) / 2); return window.crypto.getRandomValues(t), Array.from(t, ze).join('') } function qe (e) { return new Promise(t => { setTimeout(() => { t() }, e) }) } const Xe = {}; function Qe (e) { Y.warning('play failed!', e), Y.warning('play failed due to browser security policy, see: http://s.qnsdk.com/s/Txsdz') } async function Ke (e) { const t = await fetch(e); if (t.status >= 400 && t.status < 500) throw { retry: !1, message: t.status.toString() }; if (t.status !== 200) throw { retry: !0, message: t.status.toString() }; return await t.json() } async function Ze (e) { const t = e.match(/(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/); if (e.match(/^([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])$/) || t) return e; try { const t = await fetch(`https://${e}/ip`); return (await t.json()).ip } catch (t) { return Y.warning('resolve ice failed, retry', t), await qe(1e3), await Ze(e) } } function Ye () { const e = { bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', iceServers: [] }; return T.unifiedPlan ? e.sdpSemantics = 'unified-plan' : e.sdpSemantics = 'plan-b', new RTCPeerConnection(e) } async function et (e, t) { const r = t.getTransceivers().find(t => t.direction === 'inactive' && t.receiver.track.kind === e.kind); return r ? (r.direction = 'sendonly', await r.sender.replaceTrack(e), r) : await t.addTransceiver(e, { direction: 'sendonly' }) } async function tt (e, t, n, i) { if (T.stats) { return (function (e, t) { if (!t || t.length === 0) return e; if (t.length !== e.length) return e; const n = Object.values(Q([...e, ...t], 'id')); if (!n.every(e => e.length === 2)) return e; return n.map(([e, t]) => { const n = (e.timestamp - t.timestamp) / 1e3; if (n <= 0) return e; const i = r({}, e); const o = pe(t.packetLoss, e.packetLoss, t.packets, e.packets); const a = re(e.id, e.kind); return a.Apply(o), i.packetLossRate = a.Filtered() < 0 ? 0 : a.Filtered(), i.bitrate = 8 * (e.bytes - t.bytes) / n, i.bitrate < 0 ? t : i }) }(await (async function (e, t, r) { let n; try { n = await e.getStats(t) } catch (e) { return Y.debug('get stats error, fallback to default', e), [] } if (!n) return Y.debug('get null stats, fallback to default'), []; const i = []; for (const e of n.values()) if (r === 'send' && e.type === 'outbound-rtp' && !e.isRemote || r === 'recv' && e.type === 'inbound-rtp' && !e.isRemote) { const t = ie(); const o = n.get(e.remoteId); t.packetLoss = fe(e, o) || 0, t.bytes = r === 'send' ? e.bytesSent : e.bytesReceived, t.packets = r === 'send' ? e.packetsSent : e.packetsReceived, t.rtt = he(e) || he(o) || 0, t.id = e.id, t.kind = e.kind, e.frameWidth && (t.width = e.frameWidth), e.frameHeight && (t.height = e.frameHeight), i.push(t) } return i }(e, t, n)), i)) } return (function (e, t) { if (!Xe[t]) Xe[t] = !0, e() }(() => { Y.warning('your browser does not support getStats') }, 'not-support-stats-warning')), [] } window.addEventListener('message', e => { e.origin === window.location.origin && (function (e) { if (e === 'PermissionDeniedError') { if (it = 'PermissionDeniedError', nt) return nt('PermissionDeniedError'); throw je() } e === 'qnrtc:rtcmulticonnection-extension-loaded' && (it = 'desktop'); e === 'rtcmulticonnection-extension-loaded' && Y.warning('your chrome screen sharing plugin is not the latest version, or you have other screen sharing plugins.'); e.sourceId && nt && nt(rt = e.sourceId, !0 === e.canRequestAudioTrack) }(e.data)) }); let rt; let nt; let it = 'screen'; async function ot () { return await (() => new Promise((e, t) => { it !== 'desktop' ? (window.postMessage('qnrtc:are-you-there', '*'), setTimeout(() => { e(it !== 'screen') }, 2e3)) : e(!0) }))() } async function at (e, t) { const r = t.source; return await (() => new Promise((n, i) => { const o = { mozMediaSource: r || 'window', mediaSource: r || 'window', height: t.height, width: t.width }; if (g) return void n(o); const a = { mandatory: { chromeMediaSource: it, maxWidth: At(t.width), maxHeight: At(t.height) }, optional: [] }; it !== 'desktop' ? n(a) : e ? (function (e) { if (rt) return e(rt); nt = e, window.postMessage('qnrtc:audio-plus-tab', '*') }(function (e, t) { a.mandatory.chromeMediaSourceId = e, t && (a.canRequestAudioTrack = !0), e !== 'PermissionDeniedError' ? n(a) : i(je()) })) : (function (e, t = !1, r = !1) { nt = e, t ? window.postMessage('qnrtc:get-sourceId-screen', '*') : r ? window.postMessage('qnrtc:get-sourceId-window', '*') : window.postMessage('qnrtc:get-sourceId', '*') }(function (e) { a.mandatory.chromeMediaSourceId = e, e !== 'PermissionDeniedError' ? n(a) : i(je()) }, r === 'screen', r === 'window')) }))() } class st { constructor (e, t) { this.tracks = [], this.publishedTrackInfo = [], this.userId = e, this.userData = t } get published () { return this.publishedTrackInfo.length > 0 } addTracks (e) { this.tracks = this.tracks.concat(e), this.tracks = R(this.tracks, 'mediaTrack'); for (const e of this.tracks) e.once('release', () => { I(this.tracks, t => t === e) }) } removeTracksByTrackId (e) { I(this.tracks, t => !!t.info.trackId && e.indexOf(t.info.trackId) !== -1) } addPublishedTrackInfo (e) { this.publishedTrackInfo = this.publishedTrackInfo.concat(e), this.publishedTrackInfo = R(this.publishedTrackInfo, 'trackId') } removePublishedTrackInfo (e) { I(this.publishedTrackInfo, t => e.indexOf(t.trackId) !== -1) } } function ct (e) { const t = document.createElement('audio'); const r = new MediaStream([e]); return t.style.visibility = 'hidden', t.className = 'qnrtc-audio-player qnrtc-stream-player', t.dataset.localid = e.id, t.srcObject = r, t.autoplay = !0, t } function ut (e) { const t = document.createElement('video'); const r = new MediaStream([e]); return t.style.width = '100%', t.style.height = '100%', t.style.objectFit = 'contain', t.muted = !0, t.className = 'qnrtc-video-player qnrtc-stream-player', t.dataset.localid = e.id, t.setAttribute('playsinline', !0), t.autoplay = !0, t.srcObject = r, b && (t.setAttribute('controls', !0), He(() => { t && t.srcObject && t.removeAttribute('controls') })), t } class dt extends E { safeEmit (e, ...t) { try { this.emit(e, ...t) } catch (t) { Y.warning('safeEmit() | event listener threw an error [event:%s]:%o', e, t) } } safeEmitAsPromise (e, ...t) { return new Promise((r, n) => { const i = r; this.safeEmit(e, ...t, i, t => { Y.warning('safeEmitAsPromise() | errback called [event:%s]:%o', e, t), n(t) }) }) } } class lt extends dt { constructor (t, r, n, i) { super(), this.master = !1, this.stats = [], this.direction = 'local', this.sourceType = e.TrackSourceType.NORMAL, this.onended = e => { Y.warning('track ended', this.mediaTrack, this.info.trackId), this.direction === 'local' ? this.emit('ended', e) : this.emit('@ended', e) }, this.mediaTrack = t, this.mediaTrack.addEventListener('ended', this.onended), this.userId = r, n && (this.direction = n), this.info = { kind: t.kind, muted: !t.enabled, userId: this.userId, versionid: 0, profiles: i || [] } } play (e, t) { this.removeMediaElement(); const r = this.info.kind === 'video' ? ut : ct; this.mediaElement = r(this.mediaTrack), this.info.kind === 'audio' && t && (this.mediaElement.muted = !0), e.appendChild(this.mediaElement), this.mediaElement.play().catch(Qe) } resume (e) { if (this.mediaTrack.removeEventListener('ended', this.onended), this.mediaTrack.stop(), this.mediaTrack = e, this.mediaTrack.addEventListener('ended', this.onended), this.mediaElement) { const t = new MediaStream([e]); this.mediaElement.dataset.localid = e.id, this.mediaElement.srcObject = t } this.removeEvent('@get-stats'), this.resetStats() } getStats () { return this.statsInterval || this.startGetStatsInterval(), this.stats } getCurrentFrameDataURL () { return this.mediaElement && this.mediaElement instanceof HTMLVideoElement ? (function (e) { const t = document.createElement('canvas'); t.width = e.videoWidth, t.height = e.videoHeight; const r = t.getContext('2d'); return r ? (r.drawImage(e, 0, 0, e.videoWidth, e.videoHeight), t.toDataURL()) : 'data:,' }(this.mediaElement)) : 'data:,' } setMaster (e) { this.master = e } setMute (e) { this.info.muted = e, this.mediaTrack.enabled = !e, this.emit('mute', e) } setKbps (e) { this.info.kbps = e } setInfo (e) { this.info = r({}, this.info, e) } removeMediaElement () { this.mediaElement && (this.mediaElement.remove(), this.mediaElement = void 0) } release () { this.emit('release'), this.removeEvent(), this.statsInterval && window.clearInterval(this.statsInterval), this.direction !== 'local' && T.unifiedPlan || this.mediaTrack.stop(), this.removeMediaElement() } reset () { this.info.trackId = void 0, this.info.userId = void 0, this.info.versionid = 0, this.userId = void 0, this.resetStats() } resetStats () { this.stats = [], this.lastStats = [] } async startGetStatsInterval () { this.statsInterval = window.setInterval(async () => { const e = this.getListeners('@get-stats'); if (!e || e.length === 0) return []; this.stats = await this.safeEmitAsPromise('@get-stats', this.lastStats), this.lastStats = [...this.stats] }, 1e3) } onAudioBuffer (e, t) { Y.warning('not implement') } setVolume (e) { Y.warning('not implement') } getCurrentTimeDomainData () { return Y.warning('not implement'), new Uint8Array() } getCurrentFrequencyData () { return Y.warning('not implement'), new Uint8Array() } getVolume () { return Y.warning('not implement'), 0 } getCurrentVolumeLevel () { return Y.warning('not implement'), 0 } setLoop (e) { Y.warning('not implement') } startAudioSource () { Y.warning('not implement') } pauseAudioSource () { Y.warning('not implement') } resumeAudioSource () { Y.warning('not implement') } stopAudioSource () { Y.warning('not implement') } getCurrentTime () { return Y.warning('not implement'), 0 } setCurrentTime (e) { Y.warning('not implement') } getDuration () { return Y.warning('not implement'), 0 } } const ht = window.AudioContext || window.webkitAudioContext || window.Object; const ft = T.audioContextOptions ? new ht({ latencyHint: 'interactive' }) : new ht(); if (window.audioContext = ft, window.Promise) { const e = () => { (function (e) { return new Promise((t, r) => { if (e.state === 'suspended') { Y.log('audio context state is suspended'); const n = () => { e.resume().then(() => { document.body.removeEventListener('touchstart', n), document.body.removeEventListener('touchend', n), document.body.removeEventListener('mousedown', n), document.body.removeEventListener('mouseup', n), t(!0) }).catch(r) }; document.body.addEventListener('touchstart', n, !0), document.body.addEventListener('touchend', n, !0), document.body.addEventListener('mousedown', n, !0), document.body.addEventListener('mouseup', n, !0) } else t(!1) }) })(ft).then(e => { Y.debug('web audio context unlocked', e) }).catch(e => { Y.warning('can not unlock web audio context', e) }), window.removeEventListener('load', e) }; document.body ? e() : window.addEventListener('load', e) } const pt = 2048; const mt = 4096; const vt = ['play', 'playing', 'pause', 'ended', 'waiting', 'seeking']; class gt extends dt { constructor () { super(), this.audioSource = null, this._audioSourceState = e.AudioSourceState.IDLE, this.bufferSourceDuration = { startTime: 0, pauseTime: 0, lastPauseTime: 0, offsetTime: 0, stopTime: 0 }, this.handleMediaElementEvents = t => { switch (t.type) { case 'playing': case 'play': this.audioSourceState = e.AudioSourceState.PLAY; break; case 'pause': if (this.audioSourceState === e.AudioSourceState.END) break; this.audioSourceState = e.AudioSourceState.PAUSE; break; case 'waiting': case 'seeking': this.audioSourceState = e.AudioSourceState.LOADING; break; case 'ended': this.audioSourceState = e.AudioSourceState.END } } } get audioSourceState () { return this._audioSourceState } set audioSourceState (e) { e !== this._audioSourceState && (this.emit('@audio-source-state-change', e, this._audioSourceState), this._audioSourceState = e) } onAudioBuffer (e, t = mt) { this.audioBufferCallback = e, this.audioBufferSize = t } initAudioContext () { Y.log('init audio context', ft.state), ft.state === 'suspended' && (Y.log('audio context suspended'), ft.resume().catch(e => { Y.warning('resume audiocontext failed! see: http://s.qnsdk.com/s/Txsdz', e) })), Y.log('init audio finish', ft.state), this.analyserNode = ft.createAnalyser(), this.analyserNode.fftSize = pt, this.gainNode = ft.createGain(), (function (e) { if (T.disconnectAudioNode) return; const t = e.connect; const r = e.disconnect; e.connect = (r, n, i) => (e._inputNodes || (e._inputNodes = []), r instanceof AudioNode ? (e._inputNodes.push(r), e._inputNodes = R(e._inputNodes, e => e), t.call(e, r, n, i)) : t.call(e, r, n), e), e.disconnect = (t, n, i) => { r.call(e, t, n, i), t || (e._inputNodes = []), I(e._inputNodes, e => e === t); for (const t of e._inputNodes) e.connect(t) } }(this.gainNode)), T.mediaStreamDest && (this.audioStream = ft.createMediaStreamDestination()), this.initScriptNode(mt) } setMediaStreamSource (e) { this.audioSource = ft.createMediaStreamSource(e), this.connect() } setAudioBufferSource () { this.audioSource = ft.createBufferSource(), this.audioSource.onended = () => this.stopAudioSource(), this.connect() } setMediaElementSource (e) { this.audioSource = ft.createMediaElementSource(e), this.audioSourceElement = e; for (const e of vt) this.audioSourceElement.addEventListener(e, this.handleMediaElementEvents); this.connect() } setAudioSourceLoop (e) { this.audioSourceLoop = e, this.audioSource instanceof AudioBufferSourceNode ? this.audioSource.loop = !!e : this.audioSourceElement && (this.audioSourceElement.loop = !!e) } setAudioBuffer (e) { this.audioSource instanceof AudioBufferSourceNode && (this.audioSource.buffer = e, this.audioSourceBuffer = e) } playAudioSource (t = 0) { if (this.audioSource instanceof AudioBufferSourceNode) { this.resetBufferSourceDuration(); try { this.audioSource.start(0, t), this.bufferSourceDuration.startTime = ft.currentTime, this.bufferSourceDuration.offsetTime = t, this.audioSourceState = e.AudioSourceState.PLAY } catch (e) { this.stopAudioSource(), this.playAudioSource(t) } } else this.audioSourceElement ? (this.audioSourceElement.currentTime = 0, this.audioSourceElement.play().catch(Qe)) : this.audioSource === null && this.audioSourceBuffer && (this.resetBufferSourceDuration(), this.setAudioBufferSource(), this.setAudioBuffer(this.audioSourceBuffer), this.setAudioSourceLoop(!!this.audioSourceLoop), this.audioSource.start(0, t), this.bufferSourceDuration.startTime = ft.currentTime, this.bufferSourceDuration.offsetTime = t, this.audioSourceState = e.AudioSourceState.PLAY) } resumeAudioSource () { if (this.audioSource instanceof AudioBufferSourceNode) { if (this.audioSourceState !== e.AudioSourceState.PAUSE) return; this.audioSource.playbackRate.value = 1, this.bufferSourceDuration.pauseTime += ft.currentTime - this.bufferSourceDuration.lastPauseTime, this.bufferSourceDuration.lastPauseTime = 0, this.audioSourceState = e.AudioSourceState.PLAY } else this.audioSourceElement && this.audioSourceElement.play().catch(Qe) } pauseAudioSource () { this.audioSource instanceof AudioBufferSourceNode ? (this.audioSource.playbackRate.value = g ? 1e-7 : Number.MIN_VALUE, this.bufferSourceDuration.lastPauseTime || (this.bufferSourceDuration.lastPauseTime = ft.currentTime), this.audioSourceState = e.AudioSourceState.PAUSE) : this.audioSourceElement && this.audioSourceElement.pause() } stopAudioSource (t = !1) { this.audioSource instanceof AudioBufferSourceNode ? (this.audioSource.onended = null, this.audioSource.stop(), this.audioSource.disconnect(), this.audioSource = null, this.bufferSourceDuration.stopTime = ft.currentTime, t || (this.audioSourceState = e.AudioSourceState.END)) : this.audioSourceElement && (this.audioSourceState = e.AudioSourceState.END, this.audioSourceElement.pause(), this.audioSourceElement.currentTime = 0) } getAudioSourceCurrentTime () { if (this.audioSourceElement) return this.audioSourceElement.currentTime; if (this.audioSource instanceof AudioBufferSourceNode) { let e = ft.currentTime; const t = this.getAudioSourceDuration(); this.bufferSourceDuration.lastPauseTime && (e = this.bufferSourceDuration.lastPauseTime), this.bufferSourceDuration.stopTime && (e = this.bufferSourceDuration.stopTime); const r = this.bufferSourceDuration.offsetTime + e - this.bufferSourceDuration.startTime - this.bufferSourceDuration.pauseTime; return Math.max(0, r % t) } return 0 } setAudioSourceCurrentTime (e) { this.audioSourceElement ? this.audioSourceElement.currentTime = e : this.audioSource instanceof AudioBufferSourceNode && (this.stopAudioSource(!0), this.playAudioSource(e)) } getAudioSourceDuration () { return this.audioSourceElement ? this.audioSourceElement.duration : this.audioSourceBuffer ? this.audioSourceBuffer.duration : 0 } release () { if (this.audioSource instanceof MediaStreamAudioSourceNode && this.audioSource.mediaStream && this.audioSource.mediaStream.getTracks().map(e => e.stop()), this.audioSource && this.audioSource.disconnect(), this.gainNode.disconnect(), this.audioSourceElement) { for (const e of vt) this.audioSourceElement.removeEventListener(e, this.handleMediaElementEvents); this.audioSourceElement.src = '', this.audioSourceElement.load(), this.audioSourceElement.remove(), this.audioSourceElement = void 0 } this.scriptNode && this.scriptNode.disconnect() } connect () { this.audioSource ? (this.audioSource.connect(this.analyserNode), this.audioSource.connect(this.scriptNode), this.audioSource.connect(this.gainNode), this.audioStream && this.gainNode.connect(this.audioStream)) : Y.warning('no audio source, can not connect') } handleAudioBuffer (e) { const t = e.inputBuffer; this.audioBufferCallback && this.audioBufferCallback(t) } initScriptNode (e) { this.scriptNode = ft.createScriptProcessor(e), this.scriptNode.onaudioprocess = this.handleAudioBuffer.bind(this) } resetBufferSourceDuration () { this.bufferSourceDuration = { offsetTime: 0, startTime: 0, lastPauseTime: 0, pauseTime: 0, stopTime: 0 } } } const yt = 0; class bt extends lt { constructor (e, t, r) { if (e.kind !== 'audio') throw new Error('audio track only!'); super(e, t, r), this.mediaStream = new MediaStream(), this.mediaStream.addTrack(e) } resume (e) { this.mediaTrack = e, this.removeEvent('@get-stats'), this.resetStats(); const t = new MediaStream([e]); this.mediaStream = t, this.mediaElement && (this.mediaElement.dataset.localid = e.id, this.mediaElement.srcObject = t), this.audioManager && (this.audioManager.release(), this.initAudioManager()) } initAudioManager (e) { this.audioManager = new gt(), this.audioManager.initAudioContext(), this.audioManager.setMediaStreamSource(this.mediaStream), e && T.mediaStreamDest && (this.mediaStream = this.audioManager.audioStream.stream, this.mediaTrack = this.mediaStream.getTracks()[0]) } onAudioBuffer (e, t = mt) { this.audioManager.onAudioBuffer(e, t) } setVolume (e) { this.audioManager.gainNode.gain.setValueAtTime(e, ft.currentTime) } getCurrentTimeDomainData () { const e = new Uint8Array(pt); return this.audioManager.analyserNode.getByteTimeDomainData(e), e } getCurrentFrequencyData () { const e = new Uint8Array(this.audioManager.analyserNode.frequencyBinCount); return this.audioManager.analyserNode.getByteFrequencyData(e), e } getVolume () { return this.audioManager.gainNode.gain.value } getCurrentVolumeLevel () { const e = this.getCurrentFrequencyData(); let t = 0; let r = e.length; return e.forEach((n, i) => { const o = i * (ft.sampleRate || 44100) / e.length; if (o > 22050) return void (r -= 1); const a = (function (e) { const t = e * e; return 1.2588966 * 14884e4 * t * t / ((t + 424.36) * Math.sqrt((t + 11599.29) * (t + 544496.41)) * (t + 14884e4)) }(o)) * n / 255; a <= yt ? r -= 1 : t += a * a }), Math.sqrt(t / r) } release () { this.emit('release'), this.removeEvent(), this.statsInterval && window.clearInterval(this.statsInterval), this.mediaTrack.stop(), this.removeMediaElement(), this.audioManager && this.audioManager.release() } } class kt extends bt { constructor (t, r) { if (!T.mediaStreamDest) throw Me('your browser does not support audio buffer input!'); const n = new gt(); n.initAudioContext(), t instanceof AudioBuffer ? (n.setAudioBufferSource(), n.setAudioBuffer(t)) : t instanceof HTMLAudioElement && n.setMediaElementSource(t), super(n.audioStream.stream.getTracks()[0], r, 'local'), this.sourceType = e.TrackSourceType.EXTERNAL, this.isLoop = !1, this.originSource = t, this.audioManager = n, this.handleAudioManagerEvents() } setLoop (e) { this.isLoop = e, this.audioManager.setAudioSourceLoop(e) } startAudioSource () { this.audioManager.playAudioSource() } pauseAudioSource () { this.audioManager.pauseAudioSource() } resumeAudioSource () { this.audioManager.resumeAudioSource() } stopAudioSource () { this.audioManager.stopAudioSource() } getCurrentTime () { return this.audioManager.getAudioSourceCurrentTime() || 0 } setCurrentTime (e) { this.audioManager.setAudioSourceCurrentTime(e) } getDuration () { return this.audioManager.getAudioSourceDuration() || 0 } handleAudioManagerEvents () { this.audioManager.on('@audio-source-state-change', (e, t) => { this.emit('audio-state-change', e, t) }) } } class _t extends E { constructor (e, t = 'send', r) { super(), this.trackList = [], this.isDestroyed = !1, this.enableAudio = !0, this.enableVideo = !0, this.muteAudio = !1, this.muteVideo = !1, this.onAudioEnded = e => { this.emit('audio-ended', e) }, this.onVideoEnded = e => { this.emit('video-ended', e) }, this.onAudioSourceStateChange = (e, t) => { this.emit('audio-source-state-change', e, t) }, this.direction = t, this.userId = r, e.forEach(e => { e.setMaster(!0), e.on('mute', () => { this.updateTrackState() }), e.on('release', () => { I(this.trackList, t => t === e), this.updateTrackState(), this.trackList.length === 0 && this.release() }), this.trackList.push(e) }), this.updateTrackState() } get audioSourceIsLoop () { return this._audioTrack instanceof kt && this._audioTrack.isLoop } setVolume (e) { this._audioTrack && this._audioTrack.setVolume(e) } play (e, t) { this.trackList.forEach(r => r.play(e, t)), this._audioTrack && (this.audio = this._audioTrack.mediaElement), this._videoTrack && (this.video = this._videoTrack.mediaElement) } onAudioBuffer (e, t) { this._audioTrack && this._audioTrack.onAudioBuffer(e, t) } getCurrentTimeDomainData () { return this._audioTrack ? this._audioTrack.getCurrentTimeDomainData() : new Uint8Array(0) } getCurrentFrequencyData () { return this._audioTrack ? this._audioTrack.getCurrentFrequencyData() : new Uint8Array(0) } getCurrentVolumeLevel () { return this._audioTrack ? this._audioTrack.getCurrentVolumeLevel() : 0 } getStats () { let e = ie(); if (this._audioTrack) { const t = this._audioTrack.getStats(); t.length > 0 && (e = t[0]) } let t = ie(); if (this._videoTrack) { const e = this._videoTrack.getStats(); e.length > 0 && (t = e[0]) } return { timestamp: Date.now(), videoBitrate: t.bitrate, audioBitrate: e.bitrate, videoPacketLoss: t.packetLoss, audioPacketLoss: e.packetLoss, videoPackets: t.packets, audioPackets: e.packets, videoPacketLossRate: t.packetLossRate, audioPacketLossRate: e.packetLossRate, videoBytes: t.bytes, audioBytes: e.bytes, pctype: this.direction } } getCurrentFrameDataURL () { return this._videoTrack ? this._videoTrack.getCurrentFrameDataURL() : 'data:,' } setAudioSourceLoop (e) { this._audioTrack instanceof kt && this._audioTrack.setLoop(e) } startAudioSource () { this._audioTrack instanceof kt && this._audioTrack.startAudioSource() } pauseAudioSource () { this._audioTrack instanceof kt && this._audioTrack.pauseAudioSource() } resumeAudioSource () { this._audioTrack instanceof kt && this._audioTrack.resumeAudioSource() } stopAudioSource () { this._audioTrack instanceof kt && this._audioTrack.stopAudioSource() } getAudioSourceCurrentTime () { return this._audioTrack instanceof kt ? this._audioTrack.getCurrentTime() : 0 } getAudioSourceDuration () { return this._audioTrack instanceof kt ? this._audioTrack.getDuration() : 0 } setAudioSourceCurrentTime (e) { if (this._audioTrack instanceof kt) return this._audioTrack.setCurrentTime(e) } setKbps (e, t) { e && this._videoTrack && this._videoTrack.setKbps(e), t && this._audioTrack && this._audioTrack.setKbps(t) } updateTrackState () { this.trackList.forEach(e => { e.info.kind === 'audio' ? (this._audioTrack && (this._audioTrack.off('ended', this.onAudioEnded), this._audioTrack.off('audio-state-change', this.onAudioSourceStateChange)), this.audioTrack = e.mediaTrack, this._audioTrack = e, this._audioTrack.on('ended', this.onAudioEnded), this._audioTrack instanceof kt && this._audioTrack.on('audio-state-change', this.onAudioSourceStateChange)) : (this._videoTrack && this._videoTrack.off('ended', this.onVideoEnded), this.videoTrack = e.mediaTrack, this._videoTrack = e, this._videoTrack.on('ended', this.onVideoEnded)) }), this.audioTrack ? (this.enableAudio = !0, this.muteAudio = !this.audioTrack.enabled) : this.enableAudio = !1, this.videoTrack ? (this.enableVideo = !0, this.muteVideo = !this.videoTrack.enabled) : this.enableVideo = !1 } release () { if (!this.isDestroyed) { for (let e = 0; e < this.trackList.length; e += 1) { const t = this.trackList[e]; t.removeAllListeners('release'), t.release() } this.trackList = [], this.isDestroyed = !0, this.emit('release'), this.removeEvent() } } releaseTrack (e) { const { removeElement: t, newArray: r } = (function (e, t, r) { const n = []; let i = null; for (let o = 0; o < e.length; o += 1)e[o][t] !== r ? n.push(e[o]) : i = e[o]; return { removeElement: i, newArray: n } }(this.trackList, 'mediaTrack', e.mediaTrack)); t && (e.release(), this.trackList = r, this.trackList.length === 0 && (this.isDestroyed = !0)) } } function St (e) { return { timestamp: e.msgts, data: e.text, userId: e.playerid, type: e.type } } function Tt (e) { return { trackId: e.trackid, tag: e.tag, mid: e.mid || void 0, kind: e.kind, userId: e.playerid, muted: e.muted, versionid: e.versionid, profiles: e.profiles || [] } } function wt (e, t) { return { trackid: e.trackId, mid: e.mid || void 0, kind: e.kind, master: t, muted: !!e.muted, playerid: e.userId, tag: e.tag || '', versionid: e.versionid } } function Ct (e) { if (!e.info.mid && T.unifiedPlan) throw Se('can not find track mid!'); return { localid: e.mediaTrack.id, localmid: e.info.mid || void 0, master: e.master, kind: e.info.kind, kbps: e.info.kbps, tag: e.info.tag } } function Et (e) { return new st(e.playerid, e.playerdata) } function Rt (e, t, r) { let n; return e.kind === 'audio' ? (n = new bt(e)).initAudioManager(!0) : n = new lt(e), r && n.setKbps(r), n.setInfo({ tag: t }), n } function It (e) { switch (e) { case 'window': return 'application'; case 'screen': return ['window', 'monitor']; default: } } const Pt = e => (function (e) { Object.keys(e.audio).length === 0 && typeof e.audio !== 'boolean' && (e.audio = !0); Object.keys(e.video).length === 0 && typeof e.video !== 'boolean' && (e.video = !0); return e })(function (e) { if (T.minMaxWithIdeal) return e; return ['video', 'screen'].forEach(t => { typeof e[t] === 'object' && typeof e[t].width === 'object' && e[t].width.ideal && delete e[t].width.ideal, typeof e[t] === 'object' && typeof e[t].height === 'object' && e[t].height.ideal && delete e[t].height.ideal }), e }(function e (t, r = 0) { if (r >= 4) return t; for (const n in t) void 0 === t[n] && delete t[n], typeof t[n] === 'object' && (t[n] = e(t[n], r + 1)); return t }(e))); function At (e) { if (e) return typeof e === 'number' ? e : e.exact ? e.exact : e.max ? e.max : e.ideal ? e.ideal : e.min ? e.min : void 0 } var Mt = l(function (e) { var t = e.exports = { v: [{ name: 'version', reg: /^(\d*)$/ }], o: [{ name: 'origin', reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/, names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'], format: '%s %s %d %s IP%d %s' }], s: [{ name: 'name' }], i: [{ name: 'description' }], u: [{ name: 'uri' }], e: [{ name: 'email' }], p: [{ name: 'phone' }], z: [{ name: 'timezones' }], r: [{ name: 'repeats' }], t: [{ name: 'timing', reg: /^(\d*) (\d*)/, names: ['start', 'stop'], format: '%d %d' }], c: [{ name: 'connection', reg: /^IN IP(\d) (\S*)/, names: ['version', 'ip'], format: 'IN IP%d %s' }], b: [{ push: 'bandwidth', reg: /^(TIAS|AS|CT|RR|RS):(\d*)/, names: ['type', 'limit'], format: '%s:%s' }], m: [{ reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/, names: ['type', 'port', 'protocol', 'payloads'], format: '%s %d %s %s' }], a: [{ push: 'rtp', reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/, names: ['payload', 'codec', 'rate', 'encoding'], format: function (e) { return e.encoding ? 'rtpmap:%d %s/%s/%s' : e.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s' } }, { push: 'fmtp', reg: /^fmtp:(\d*) ([\S| ]*)/, names: ['payload', 'config'], format: 'fmtp:%d %s' }, { name: 'control', reg: /^control:(.*)/, format: 'control:%s' }, { name: 'rtcp', reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/, names: ['port', 'netType', 'ipVer', 'address'], format: function (e) { return e.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d' } }, { push: 'rtcpFbTrrInt', reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/, names: ['payload', 'value'], format: 'rtcp-fb:%d trr-int %d' }, { push: 'rtcpFb', reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/, names: ['payload', 'type', 'subtype'], format: function (e) { return e.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s' } }, { push: 'ext', reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/, names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'], format: function (e) { return 'extmap:%d' + (e.direction ? '/%s' : '%v') + (e['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (e.config ? ' %s' : '') } }, { name: 'extmapAllowMixed', reg: /^(extmap-allow-mixed)/ }, { push: 'crypto', reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/, names: ['id', 'suite', 'config', 'sessionConfig'], format: function (e) { return e.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s' } }, { name: 'setup', reg: /^setup:(\w*)/, format: 'setup:%s' }, { name: 'connectionType', reg: /^connection:(new|existing)/, format: 'connection:%s' }, { name: 'mid', reg: /^mid:([^\s]*)/, format: 'mid:%s' }, { name: 'msid', reg: /^msid:(.*)/, format: 'msid:%s' }, { name: 'ptime', reg: /^ptime:(\d*(?:\.\d*)*)/, format: 'ptime:%d' }, { name: 'maxptime', reg: /^maxptime:(\d*(?:\.\d*)*)/, format: 'maxptime:%d' }, { name: 'direction', reg: /^(sendrecv|recvonly|sendonly|inactive)/ }, { name: 'icelite', reg: /^(ice-lite)/ }, { name: 'iceUfrag', reg: /^ice-ufrag:(\S*)/, format: 'ice-ufrag:%s' }, { name: 'icePwd', reg: /^ice-pwd:(\S*)/, format: 'ice-pwd:%s' }, { name: 'fingerprint', reg: /^fingerprint:(\S*) (\S*)/, names: ['type', 'hash'], format: 'fingerprint:%s %s' }, { push: 'candidates', reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/, names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'], format: function (e) { var t = 'candidate:%s %d %s %d %s %d typ %s'; return t += e.raddr != null ? ' raddr %s rport %d' : '%v%v', t += e.tcptype != null ? ' tcptype %s' : '%v', e.generation != null && (t += ' generation %d'), t += e['network-id'] != null ? ' network-id %d' : '%v', t += e['network-cost'] != null ? ' network-cost %d' : '%v' } }, { name: 'endOfCandidates', reg: /^(end-of-candidates)/ }, { name: 'remoteCandidates', reg: /^remote-candidates:(.*)/, format: 'remote-candidates:%s' }, { name: 'iceOptions', reg: /^ice-options:(\S*)/, format: 'ice-options:%s' }, { push: 'ssrcs', reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/, names: ['id', 'attribute', 'value'], format: function (e) { var t = 'ssrc:%d'; return e.attribute != null && (t += ' %s', e.value != null && (t += ':%s')), t } }, { push: 'ssrcGroups', reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/, names: ['semantics', 'ssrcs'], format: 'ssrc-group:%s %s' }, { name: 'msidSemantic', reg: /^msid-semantic:\s?(\w*) (\S*)/, names: ['semantic', 'token'], format: 'msid-semantic: %s %s' }, { push: 'groups', reg: /^group:(\w*) (.*)/, names: ['type', 'mids'], format: 'group:%s %s' }, { name: 'rtcpMux', reg: /^(rtcp-mux)/ }, { name: 'rtcpRsize', reg: /^(rtcp-rsize)/ }, { name: 'sctpmap', reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/, names: ['sctpmapNumber', 'app', 'maxMessageSize'], format: function (e) { return e.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s' } }, { name: 'xGoogleFlag', reg: /^x-google-flag:([^\s]*)/, format: 'x-google-flag:%s' }, { push: 'rids', reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/, names: ['id', 'direction', 'params'], format: function (e) { return e.params ? 'rid:%s %s %s' : 'rid:%s %s' } }, { push: 'imageattrs', reg: new RegExp('^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'), names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'], format: function (e) { return 'imageattr:%s %s %s' + (e.dir2 ? ' %s %s' : '') } }, { name: 'simulcast', reg: new RegExp('^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$'), names: ['dir1', 'list1', 'dir2', 'list2'], format: function (e) { return 'simulcast:%s %s' + (e.dir2 ? ' %s %s' : '') } }, { name: 'simulcast_03', reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/, names: ['value'], format: 'simulcast: %s' }, { name: 'framerate', reg: /^framerate:(\d+(?:$|\.\d+))/, format: 'framerate:%s' }, { name: 'sourceFilter', reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/, names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'], format: 'source-filter: %s %s %s %s %s' }, { name: 'bundleOnly', reg: /^(bundle-only)/ }, { name: 'label', reg: /^label:(.+)/, format: 'label:%s' }, { name: 'sctpPort', reg: /^sctp-port:(\d+)$/, format: 'sctp-port:%s' }, { name: 'maxMessageSize', reg: /^max-message-size:(\d+)$/, format: 'max-message-size:%s' }, { push: 'tsRefClocks', reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/, names: ['clksrc', 'clksrcExt'], format: function (e) { return 'ts-refclk:%s' + (e.clksrcExt != null ? '=%s' : '') } }, { name: 'mediaClk', reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/, names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'], format: function (e) { var t = 'mediaclk:'; return t += e.id != null ? 'id=%s %s' : '%v%s', t += e.mediaClockValue != null ? '=%s' : '', t += e.rateNumerator != null ? ' rate=%s' : '', t += e.rateDenominator != null ? '/%s' : '' } }, { name: 'keywords', reg: /^keywds:(.+)$/, format: 'keywds:%s' }, { name: 'content', reg: /^content:(.+)/, format: 'content:%s' }, { name: 'bfcpFloorCtrl', reg: /^floorctrl:(c-only|s-only|c-s)/, format: 'floorctrl:%s' }, { name: 'bfcpConfId', reg: /^confid:(\d+)/, format: 'confid:%s' }, { name: 'bfcpUserId', reg: /^userid:(\d+)/, format: 'userid:%s' }, { name: 'bfcpFloorId', reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/, names: ['id', 'mStream'], format: 'floorid:%s mstrm:%s' }, { push: 'invalid', names: ['value'] }] }; Object.keys(t).forEach(function (e) { t[e].forEach(function (e) { e.reg || (e.reg = /(.*)/), e.format || (e.format = '%s') }) }) }); var xt = (Mt.v, Mt.o, Mt.s, Mt.i, Mt.u, Mt.e, Mt.p, Mt.z, Mt.r, Mt.t, Mt.c, Mt.b, Mt.m, Mt.a, l(function (e, t) { var r = function (e) { return String(Number(e)) === e ? Number(e) : e }; var n = function (e, t, n) { var i = e.name && e.names; e.push && !t[e.push] ? t[e.push] = [] : i && !t[e.name] && (t[e.name] = {}); var o = e.push ? {} : i ? t[e.name] : t; !(function (e, t, n, i) { if (i && !n) t[i] = r(e[1]); else for (var o = 0; o < n.length; o += 1)e[o + 1] != null && (t[n[o]] = r(e[o + 1])) }(n.match(e.reg), o, e.names, e.name)), e.push && t[e.push].push(o) }; var i = RegExp.prototype.test.bind(/^([a-z])=(.*)/); t.parse = function (e) { var t = {}; var r = []; var o = t; return e.split(/(\r\n|\r|\n)/).filter(i).forEach(function (e) { var t = e[0]; var i = e.slice(2); t === 'm' && (r.push({ rtp: [], fmtp: [] }), o = r[r.length - 1]); for (var a = 0; a < (Mt[t] || []).length; a += 1) { var s = Mt[t][a]; if (s.reg.test(i)) return n(s, o, i) } }), t.media = r, t }; var o = function (e, t) { var n = t.split(/=(.+)/, 2); return n.length === 2 ? e[n[0]] = r(n[1]) : n.length === 1 && t.length > 1 && (e[n[0]] = void 0), e }; t.parseParams = function (e) { return e.split(/;\s?/).reduce(o, {}) }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function (e) { return e.toString().split(' ').map(Number) }, t.parseRemoteCandidates = function (e) { for (var t = [], n = e.split(' ').map(r), i = 0; i < n.length; i += 3)t.push({ component: n[i], ip: n[i + 1], port: n[i + 2] }); return t }, t.parseImageAttributes = function (e) { return e.split(' ').map(function (e) { return e.substring(1, e.length - 1).split(',').reduce(o, {}) }) }, t.parseSimulcastStreamList = function (e) { return e.split(';').map(function (e) { return e.split(',').map(function (e) { var t; var n = !1; return e[0] !== '~' ? t = r(e) : (t = r(e.substring(1, e.length)), n = !0), { scid: t, paused: n } }) }) } })); var Ot = (xt.parse, xt.parseParams, xt.parseFmtpConfig, xt.parsePayloads, xt.parseRemoteCandidates, xt.parseImageAttributes, xt.parseSimulcastStreamList, /%[sdv%]/g); var Dt = function (e, t, r) { var n = [e + '=' + (t.format instanceof Function ? t.format(t.push ? r : r[t.name]) : t.format)]; if (t.names) for (var i = 0; i < t.names.length; i += 1) { var o = t.names[i]; t.name ? n.push(r[t.name][o]) : n.push(r[t.names[i]]) } else n.push(r[t.name]); return (function (e) { var t = 1; var r = arguments; var n = r.length; return e.replace(Ot, function (e) { if (t >= n) return e; var i = r[t]; switch (t += 1, e) { case '%%': return '%'; case '%s': return String(i); case '%d': return Number(i); case '%v': return '' } }) }.apply(null, n)) }; var Lt = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a']; var jt = ['i', 'c', 'b', 'a']; var Nt = { write: function (e, t) { t = t || {}, e.version == null && (e.version = 0), e.name == null && (e.name = ' '), e.media.forEach(function (e) { e.payloads == null && (e.payloads = '') }); var r = t.outerOrder || Lt; var n = t.innerOrder || jt; var i = []; return r.forEach(function (t) { Mt[t].forEach(function (r) { r.name in e && e[r.name] != null ? i.push(Dt(t, r, e)) : r.push in e && e[r.push] != null && e[r.push].forEach(function (e) { i.push(Dt(t, r, e)) }) }) }), e.media.forEach(function (e) { i.push(Dt('m', Mt.m[0], e)), n.forEach(function (t) { Mt[t].forEach(function (r) { r.name in e && e[r.name] != null ? i.push(Dt(t, r, e)) : r.push in e && e[r.push] != null && e[r.push].forEach(function (e) { i.push(Dt(t, r, e)) }) }) }) }), i.join('\r\n') + '\r\n' }, parse: xt.parse, parseParams: xt.parseParams, parseFmtpConfig: xt.parseFmtpConfig, parsePayloads: xt.parsePayloads, parseRemoteCandidates: xt.parseRemoteCandidates, parseImageAttributes: xt.parseImageAttributes, parseSimulcastStreamList: xt.parseSimulcastStreamList }; const Bt = '\n'; const Ft = 'qiniu-rtc-client'; function Ut (e) { return e.map(e => { const t = { component: 1, foundation: e.foundation, ip: e.ip, port: e.port, priority: e.priority, transport: e.protocol, type: e.type }; return e.tcpType && (t.tcptype = e.tcpType), t }) } class $t { constructor (e, t) { this.lastSubMids = [], this.sessionVersion = 0, this.direction = e, this.extendedRtpCapabilities = t } get transportRemoteParameters () { return this._transportRemoteParameters } async setTransportRemoteParameters (e) { for (const t of e.iceCandidates) t.ip = await Ze(t.ip); this._transportRemoteParameters = e } createRemoteAnswer (e) { if (!this.transportRemoteParameters) throw Se('no transportRemoteParameters!'); return T.unifiedPlan ? (function (e, t, r) { const n = Nt.parse(r); const i = (n.media || []).filter(e => e.hasOwnProperty('mid')).map(e => String(e.mid)); const o = { version: 0 }; o.origin = { address: '0.0.0.0', ipVer: 4, netType: 'IN', sessionId: '5975129998295344376', sessionVersion: 2, username: Ft }, o.name = '-', o.timing = { start: 0, stop: 0 }, o.icelite = t.iceParameters.iceLite ? 'ice-lite' : void 0, o.msidSemantic = { semantic: 'WMS', token: '*' }, i.length > 0 && (o.groups = [{ type: 'BUNDLE', mids: i.join(' ') }]); o.media = [], o.fingerprint = { type: t.dtlsParameters.fingerprints[0].algorithm, hash: t.dtlsParameters.fingerprints[0].value }; for (const r of n.media) { r.direction; const n = r.type; const i = n === 'audio' ? e.codecs[0] : e.codecs[1]; const a = e.headerExtensions.filter(e => e.kind === n); const s = { type: r.type, port: 7, protocol: 'RTP/SAVPF', connection: { ip: '127.0.0.1', version: 4 }, mid: r.mid, iceUfrag: t.iceParameters.usernameFragment, icePwd: t.iceParameters.password, candidates: Ut(t.iceCandidates), endOfCandidates: 'end-of-candidates', iceOptions: 'renomination', setup: t.dtlsParameters.role === 'server' ? 'actpass' : 'active', direction: r.direction === 'sendonly' || r.direction === 'sendrecv' ? 'recvonly' : 'inactive', rtp: [{ payload: i.sendPayloadType, codec: i.name, rate: i.clockRate, encoding: i.channels > 1 ? i.channels : void 0 }], rtcpFb: [], fmtp: [{ payload: i.sendPayloadType, config: Object.keys(i.parameters).map(e => `${e}=${i.parameters[e]};`).join('') }], payloads: i.sendPayloadType, rtcpMux: 'rtcp-mux', rtcpRsize: 'rtcp-rsize', ext: a.map(e => ({ uri: e.uri, value: e.sendId })) }; i.rtcpFeedback && i.rtcpFeedback.length > 0 && i.rtcpFeedback.forEach(e => { s.rtcpFb.push({ payload: i.sendPayloadType, type: e.type, subtype: e.parameter }) }), i.sendRtxPayloadType && (s.rtp.push({ payload: i.sendRtxPayloadType, codec: 'rtx', rate: i.clockRate, encoding: i.channels > 1 ? i.channels : void 0 }), s.fmtp.push({ payload: i.sendRtxPayloadType, config: `apt=${i.sendPayloadType};` }), s.payloads = `${i.sendPayloadType} ${i.sendRtxPayloadType}`), o.media.push(s) } return Nt.write(o) }(this.extendedRtpCapabilities, this.transportRemoteParameters, e)) : (function (e, t, r) { const n = Nt.parse(r); n.version = 0, n.origin = { address: '0.0.0.0', ipVer: 4, netType: 'IN', sessionId: '5975129998295344376', sessionVersion: 2, username: Ft }, n.name = '-', n.timing = { start: 0, stop: 0 }, n.icelite = t.iceParameters.iceLite ? 'ice-lite' : void 0, n.msidSemantic = { semantic: 'WMS', token: '*' }, n.fingerprint = { type: t.dtlsParameters.fingerprints[0].algorithm, hash: t.dtlsParameters.fingerprints[0].value }; const i = []; for (const r of n.media) { const n = r.type; const o = e.codecs.find(e => e.kind === n); const a = (e.headerExtensions || []).filter(e => e.kind === n); if (!o) throw Se('can not find codec' + n); const s = { type: n, mid: n, port: 7, protocol: 'RTP/SAVPF', connection: { ip: '127.0.0.1', version: 4 }, iceUfrag: t.iceParameters.usernameFragment, icePwd: t.iceParameters.password, candidates: Ut(t.iceCandidates), endOfCandidates: 'end-of-candidates', iceOptions: 'renomination', setup: t.dtlsParameters.role === 'server' ? 'actpass' : 'active', direction: 'recvonly', rtp: [{ payload: o.sendPayloadType, codec: o.name, rate: o.clockRate, encoding: o.channels > 1 ? o.channels : void 0 }], rtcpFb: [], fmtp: [{ payload: o.sendPayloadType, config: Object.keys(o.parameters).map(e => `${e}=${o.parameters[e]};`).join('') }], payloads: o.sendPayloadType, rtcpMux: 'rtcp-mux', rtcpRsize: 'rtcp-rsize', ext: a.map(e => ({ uri: e.uri, value: e.sendId })) }; o.rtcpFeedback && o.rtcpFeedback.length > 0 && o.rtcpFeedback.forEach(e => { s.rtcpFb.push({ payload: o.sendPayloadType, type: e.type, subtype: e.parameter }) }), o.sendRtxPayloadType && (s.rtp.push({ payload: o.sendRtxPayloadType, codec: 'rtx', rate: o.clockRate, encoding: o.channels > 1 ? o.channels : void 0 }), s.fmtp.push({ payload: o.sendRtxPayloadType, config: `apt=${o.sendPayloadType};` }), s.payloads = `${o.sendPayloadType} ${o.sendRtxPayloadType}`), i.push(s) } return n.media = i, Nt.write(n) }(this.extendedRtpCapabilities, this.transportRemoteParameters, e)) } createRemoteOffer (e) { if (!this.transportRemoteParameters) throw Se('no transportRemoteParameters!'); if (T.unifiedPlan) { const t = (function (e, t) { let r = []; for (const n of t) { const t = I(e, e => e.mid === n)[0]; t && r.push(t) } return r = r.concat(e), t = r.map(e => e.mid), r }(e, this.lastSubMids)); return this.lastSubMids = t.map(e => e.mid), this.sessionVersion += 1, (function (e, t, r, n) { Y.debug('consumerInfos', e); const i = {}; const o = e.map(e => e.mid); i.version = 0, i.origin = { address: '0.0.0.0', ipVer: 4, netType: 'IN', sessionId: '5975129998295344377', sessionVersion: n, username: Ft }, i.name = '-', i.timing = { start: 0, stop: 0 }, i.icelite = r.iceParameters.iceLite ? 'ice-lite' : void 0, i.msidSemantic = { semantic: 'WMS', token: '*' }, o.length > 0 && (i.groups = [{ type: 'BUNDLE', mids: o.join(' ') }]); i.media = [], i.fingerprint = { type: r.dtlsParameters.fingerprints[0].algorithm, hash: r.dtlsParameters.fingerprints[0].value }; for (const n of e) { const e = n.kind === 'audio' ? t.codecs[0] : t.codecs[1]; const o = t.headerExtensions.filter(e => e.kind === n.kind); const a = { type: n.kind, port: 7, protocol: 'RTP/SAVPF', connection: { ip: '127.0.0.1', version: 4 }, mid: n.mid, msid: `${n.streamId} ${n.trackId}`, iceUfrag: r.iceParameters.usernameFragment, icePwd: r.iceParameters.password, candidates: Ut(r.iceCandidates), endOfCandidates: 'end-of-candidates', iceOptions: 'renomination', setup: r.dtlsParameters.role === 'server' ? 'actpass' : 'active', direction: n.closed ? 'inactive' : 'sendonly', rtp: [{ payload: e.recvPayloadType, codec: e.name, rate: e.clockRate, encoding: e.channels > 1 ? e.channels : void 0 }], rtcpFb: [], fmtp: [{ payload: e.recvPayloadType, config: Object.keys(e.parameters).map(t => `${t}=${e.parameters[t]};`).join('') }], payloads: e.recvPayloadType, rtcpMux: 'rtcp-mux', rtcpRsize: 'rtcp-rsize', ext: n.closed ? [] : o.map(e => ({ uri: e.uri, value: e.recvId })), ssrcs: !n.closed && n.ssrc ? [{ id: n.ssrc, attribute: 'cname', value: n.cname }] : [], ssrcGroups: [] }; e.rtcpFeedback && e.rtcpFeedback.length > 0 && e.rtcpFeedback.forEach(t => { a.rtcpFb.push({ payload: e.recvPayloadType, type: t.type, subtype: t.parameter }) }), e.recvRtxPayloadType && (a.rtp.push({ payload: e.recvRtxPayloadType, codec: 'rtx', rate: e.clockRate, encoding: e.channels > 1 ? e.channels : void 0 }), a.fmtp.push({ payload: e.recvRtxPayloadType, config: `apt=${e.recvPayloadType};` }), a.payloads = `${e.recvPayloadType} ${e.recvRtxPayloadType}`), n.rtxSsrc && !n.closed && (a.ssrcs = a.ssrcs.concat([{ id: n.rtxSsrc, attribute: 'cname', value: n.cname }]), a.ssrcGroups.push({ semantics: 'FID', ssrcs: `${n.ssrc} ${n.rtxSsrc}` })), i.media.push(a) } return Nt.write(i) }(t, this.extendedRtpCapabilities, this.transportRemoteParameters, this.sessionVersion)) } { const t = new Set(); return e.forEach(e => t.add(e.kind)), e.length === 0 && (t.add('audio'), t.add('video')), (function (e, t, r, n) { e = ['audio', 'video']; const i = { version: 0 }; i.origin = { address: '0.0.0.0', ipVer: 4, netType: 'IN', sessionId: '5975129998295344377', sessionVersion: 2, username: Ft }, i.name = '-', i.timing = { start: 0, stop: 0 }, i.icelite = n.iceParameters.iceLite ? 'ice-lite' : void 0, i.msidSemantic = { semantic: 'WMS', token: '*' }, i.groups = [{ type: 'BUNDLE', mids: e.join(' ') }], i.media = [], i.fingerprint = { type: n.dtlsParameters.fingerprints[0].algorithm, hash: n.dtlsParameters.fingerprints[0].value }; for (const o of e) { const e = t.filter(e => e.kind === o); const a = r.codecs.find(e => e.kind === o); const s = (r.headerExtensions || []).filter(e => e.kind === o); if (!a) throw Se('no codec' + o); const c = { type: o, port: 7, protocol: 'RTP/SAVPF', connection: { ip: '127.0.0.1', version: 4 }, mid: o, iceUfrag: n.iceParameters.usernameFragment, icePwd: n.iceParameters.password, candidates: Ut(n.iceCandidates), endOfCandidates: 'end-of-candidates', iceOptions: 'renomination', setup: n.dtlsParameters.role === 'server' ? 'actpass' : 'active', direction: 'sendonly', rtp: [{ payload: a.recvPayloadType, codec: a.name, rate: a.clockRate, encoding: a.channels > 1 ? a.channels : void 0 }], rtcpFb: [], fmtp: [{ payload: a.recvPayloadType, config: Object.keys(a.parameters).map(e => `${e}=${a.parameters[e]};`).join('') }], payloads: a.recvPayloadType, rtcpMux: 'rtcp-mux', rtcpRsize: 'rtcp-rsize', ssrcs: [], ssrcGroups: [], ext: s.map(e => ({ uri: e.uri, value: e.recvId })) }; a.rtcpFeedback && a.rtcpFeedback.length > 0 && a.rtcpFeedback.forEach(e => { c.rtcpFb.push({ payload: a.recvPayloadType, type: e.type, subtype: e.parameter }) }), a.recvRtxPayloadType && (c.rtp.push({ payload: a.recvRtxPayloadType, codec: 'rtx', rate: a.clockRate, encoding: a.channels > 1 ? a.channels : void 0 }), c.fmtp.push({ payload: a.recvRtxPayloadType, config: `apt=${a.recvPayloadType};` }), c.payloads = `${a.recvPayloadType} ${a.recvRtxPayloadType}`); for (const t of e) c.ssrcs.push({ id: t.ssrc, attribute: 'msid', value: `${t.streamId} ${t.trackId}` }), c.ssrcs.push({ id: t.ssrc, attribute: 'mslabel', value: `${t.streamId}` }), c.ssrcs.push({ id: t.ssrc, attribute: 'label', value: `${t.trackId}` }), c.ssrcs.push({ id: t.ssrc, attribute: 'cname', value: `${t.cname}` }), t.rtxSsrc && (c.ssrcGroups.push({ semantics: 'FID', ssrcs: `${t.ssrc} ${t.rtxSsrc}` }), c.ssrcs.push({ id: t.rtxSsrc, attribute: 'msid', value: `${t.streamId} ${t.trackId}` }), c.ssrcs.push({ id: t.rtxSsrc, attribute: 'mslabel', value: `${t.streamId}` }), c.ssrcs.push({ id: t.rtxSsrc, attribute: 'label', value: `${t.trackId}` }), c.ssrcs.push({ id: t.rtxSsrc, attribute: 'cname', value: `${t.cname}` })); i.media.push(c) } return Nt.write(i) }(Array.from(t), e, this.extendedRtpCapabilities, this.transportRemoteParameters)) } } async updateICEData (e, t) { if (this.transportRemoteParameters) { for (const e of t) e.ip = await Ze(e.ip); this.transportRemoteParameters.iceCandidates = t, this.transportRemoteParameters.iceParameters = e } } } function Vt (e, t) { const r = Nt.parse(e); t && k.name === 'chrome' && (r.media = r.media.map(e => { if (!e.ssrcGroups || e.ssrcGroups.length === 0 || !e.ssrcs || e.ssrcs.length === 0) return e; const r = e.ssrcGroups.find(e => e.semantics === 'FID'); if (!r) return e; const [n, i] = r.ssrcs.split(' ').map(e => parseInt(e, 10)); let o, a; e.ssrcs.forEach(e => { e.attribute === 'cname' && (o = e.value), e.attribute === 'msid' && (a = e.value) }); const s = []; if (s.push(n), t >= 2) { const t = n + 1; const r = i + 1; e.ssrcs.push({ id: t, attribute: 'cname', value: o }), e.ssrcs.push({ id: t, attribute: 'msid', value: a }), e.ssrcs.push({ id: r, attribute: 'cname', value: o }), e.ssrcs.push({ id: r, attribute: 'msid', value: a }), e.ssrcGroups.push({ semantics: 'FID', ssrcs: `${t} ${r}` }), s.push(t) } if (t >= 3) { const t = n + 2; const r = i + 2; e.ssrcs.push({ id: t, attribute: 'cname', value: o }), e.ssrcs.push({ id: t, attribute: 'msid', value: a }), e.ssrcs.push({ id: r, attribute: 'cname', value: o }), e.ssrcs.push({ id: r, attribute: 'msid', value: a }), e.ssrcGroups.push({ semantics: 'FID', ssrcs: `${t} ${r}` }), s.push(t) } return e.ssrcGroups.push({ semantics: 'SIM', ssrcs: s.join(' ') }), e })); const n = Nt.write(r).split('\r\n'); let i = n.findIndex(e => e.indexOf('a=ssrc-group:FID') === 0); for (; i !== -1 && n[i].indexOf('a=ssrc-group:FID') === 0;) { const e = n[i].split(' ')[2]; for (let t = i - 1; t >= 0; t--) if (n[t].indexOf(e) > 0) { n.splice(t + 1, 0, n[i]), n.splice(i + 1, 1); break } i++ } return n.join('\r\n') } const Gt = 'https://rtc.qiniuapi.com'; async function Wt (e, t) { const { appId: n, roomName: i, userId: o } = e; const a = `${Gt}/v3/apps/${n}/rooms/${i}/auth?user=${o}&token=${t}`; for (; ;) { const e = { auth_start_time: Date.now(), auth_dns_time: 0, auth_server_ip: '', room_token: t }; try { const t = await Ke(a); return ye.addEvent('MCSAuth', r({}, e, { auth_take_time: Date.now() - e.auth_start_time, auth_error_code: 0, auth_error_message: '', access_token: t.accessToken })), t } catch (t) { if (ye.addEvent('MCSAuth', r({}, e, { auth_take_time: Date.now() - e.auth_start_time, auth_error_code: void 0 === t.retry ? -1 : Number(t.message), auth_error_message: void 0 === t.retry ? t.toString() : t.message, access_token: '' })), !1 === t.retry) throw Te(t.message); await qe(1e3), Y.warning('can not get accessToken, retry.', Te(t)) } } } const { JOIN_ROOM_ERROR: Ht } = $e; var zt, Jt, qt; !(function (e) { e[e.CONNECTING = 0] = 'CONNECTING', e[e.OPEN = 1] = 'OPEN', e[e.CLOSING = 2] = 'CLOSING', e[e.CLOSED = 3] = 'CLOSED' }(zt || (zt = {}))); class Xt extends dt { constructor (e, t, r, n, i) { super(), this.startAuthTime = 0, this.initWs = (e = !1) => new Promise((t, r) => { this.ws && this.ws.readyState === WebSocket.OPEN && (this.ws.close(), this.ws.onclose = null), this.startAuthTime = Date.now(); try { this.ws = new WebSocket(this.url), this._state = zt.CONNECTING } catch (e) { throw Se(`init signaling websocket faild!\nError: ${e}`) } this.ws.onerror = this.onWsError, this.ws.onclose = this.onWsClose.bind(this, t, r), this.ws.onopen = () => { this.emit('ws:onopen'), Y.log('signaling: websocket open', this.url), this.ws.onmessage = this.onWsMsg; const n = { token: this.accessToken, reconntoken: this.reconnectToken, agent: `${k.name}${k.version}`, sdkversion: K, capsdp: this.capsdp, msgsn: this.customMsgNumber, supportdomain: !0 }; this.playerdata && (n.playerdata = this.playerdata), this.request('auth', n).then(n => { switch (n.code !== 0 && (ye.addEvent('SignalAuth', { auth_start_time: this.startAuthTime, auth_dns_time: 0, auth_server_ip: '', auth_error_code: n.code, auth_error_message: n.error, auth_take_time: Date.now() - this.startAuthTime, access_token: this.accessToken }), this.startAuthTime = 0), n.code) { case 0: this.ws.onclose = this.onWsClose.bind(this, null, null), this.reconnectToken = n.reconntoken, Y.log('signaling: websocket authed'), this.emit('@signalingauth', n), this._state = zt.OPEN, ye.addEvent('SignalAuth', { auth_start_time: this.startAuthTime, auth_dns_time: 0, auth_server_ip: '', auth_error_code: 0, auth_error_message: '', auth_take_time: Date.now() - this.startAuthTime, access_token: this.accessToken }), this.startAuthTime = 0, t(n); break; case 10001: case 10002: case 10011: case 10022: case 10004: this.emit('@error', n), r(Ht(n.code, n.error)); break; case 10012: return void this.safeEmitAsPromise('@needupdateaccesstoken').then(() => { this.reconnect().then(t).catch(r) }).catch(e => { this.emit('@error', { code: 10002 }), r(e) }); case 10052: if (Y.debug('10052 auth, retry', e), this.reconnectToken = void 0, e) { r(Ht(n.code, n.error)); break } return void this.emit('@error', n); case 10054: r(Ie(n.error)); break; default: r(Se(n.error)) }n.code !== 0 && (this.reconnectToken = void 0, this._state = zt.CLOSED, this.release()) }) } }), this.onWsMsg = e => { const t = e.data; this.emit('ws:onmessage', t); const r = t.indexOf('='); if (!(r > 0)) throw Se(`signaling model can not parse message: ${t}`); { const e = t.substring(0, r); const n = JSON.parse(t.substring(r + 1)); this.receiveWsMsg(e, n) } }, this.onWsError = e => { Y.warning('signaling: websocket error', e), this.emit('@ws:error', e) }, this.sendWsMsg = (e, t) => { if (this.ws.readyState !== WebSocket.OPEN) throw Fe(); const r = JSON.stringify(t); try { this.ws.send(`${e}=${r}`), this.emit('send', e, t) } catch (e) { throw Y.warning('signaling: websocket send error', e), this.reconnect().catch(e => { Y.warning('signaling: reconnect error', e) }), Fe() } }, this.handlePing = () => { this.sendWsMsg('pong', {}), this.reconnectTimeoutID && clearTimeout(this.reconnectTimeoutID), this.reconnectTimeoutID = setTimeout(() => { Y.debug('signaling: websocket heartbeat timeout'), this.reconnect().catch(e => { Y.debug(e) }) }, 9e3) }, this.receiveWsMsg = (e, t) => { switch (this.emit('receive', e, t), e) { case 'ping': this.handlePing(); break; case 'auth-res': this.emit('@auth-res', t); case 'pubpc-res': case 'subpc-res': case 'pub-tracks': case 'webrtc-candidate': case 'on-player-in': case 'on-player-out': case 'disconnect': case 'mute-tracks': case 'on-add-tracks': case 'on-remove-tracks': case 'on-player-reconnect': case 'on-player-reconnect-in': this.emit(e, t); break; case 'sub-res': case 'unsub-res': this.emit(e, t), this.emit(`${e}-${t.streamid}`, t); break; case 'control-res': this.emit(e, t), this.emit(`${e}-${t.command}-${t.playerid}`, t); break; case 'on-pubpc-connected': case 'on-pubpc-disconnected': this.emit('on-pubpc-state', { pcid: t.pcid, connected: e === 'on-pubpc-connected' }), this.emit(`${e}-${t.pcid}`, t); break; case 'on-subpc-disconnected': case 'on-subpc-connected': this.emit('on-subpc-state', { pcid: t.pcid, connected: e === 'on-subpc-connected' }), this.emit(e, t); break; case 'pub-tracks-res': this.emit(e, t); break; case 'on-messages': case 'on-qos-messages': t.messages = t.messages.sort((e, t) => e.msgsn - t.msgsn), this.customMsgNumber = t.messages[t.messages.length - 1].msgsn, this.emit(e, t); break; case 'unpub-tracks-res': case 'sub-tracks-res': case 'unsub-tracks-res': case 'on-pubpc-restart-notify': case 'on-subpc-restart-notify': case 'set-sub-profile-res': case 'on-sub-profile-changed': case 'pubpc-restart-res': case 'subpc-restart-res': case 'create-merge-job-res': this.emit(e, t) } }, this.url = e, this.accessToken = t, this.capsdp = r, this.reconnectTimes = n, this.playerdata = i } set _state (e) { this.emit('@ws-state-change', this.__state, e), this.__state = e } get state () { return this.__state } set reconnectTimes (e) { this._reconnectTimes = e, this.currentLeftReconnectTimes = e } get reconnectTimes () { return this._reconnectTimes } onWsClose (e, t, r) { this._state = zt.CLOSED, Y.warning('signaling: websocket onclose', r), this.startAuthTime && ye.addEvent('SignalAuth', { auth_start_time: this.startAuthTime, auth_dns_time: 0, auth_server_ip: '', auth_error_code: r.code, auth_error_message: r.toString(), auth_take_time: Date.now() - this.startAuthTime, access_token: this.accessToken }); let n = this.reconnectPromise; switch (r.code) { case 1e3: this.emit('@closed'); break; case 1001: case 1005: case 1006: n = this.reconnect(); break; case 1007: case 1008: case 1009: case 1010: break; case 1011: n = this.reconnect(); break; case 1012: n = this.reconnect(5e3); break; case 1013: n = this.reconnect(); break; case 1014: n = this.reconnect(5e3) }e && t && (n ? e(n) : t(r)) } sendDisconnect () { if (this.state === zt.OPEN) try { this.sendWsMsg('disconnect', {}) } catch (e) { } } reconnect (e = 1e3) { return this.reconnectTimeoutID && clearTimeout(this.reconnectTimeoutID), this.reconnectPromise && this._state === zt.CONNECTING ? this.reconnectPromise : this.currentLeftReconnectTimes <= 0 ? (this.emit('@error', { code: 10007, error: 'signaling error: websocket reconnectTimes run out, reconnect stops.' }), this._state = zt.CLOSED, this.reconnectToken = void 0, this.release(), Promise.reject('signaling error: websocket reconnectTimes run out, reconnect stops.')) : (this.currentLeftReconnectTimes -= 1, this._state = zt.CONNECTING, Y.debug('signaling: websocket reconnecting, currentLeftReconnectTimes remaining: ', this.currentLeftReconnectTimes), this.reconnectPromise = qe(e).then(() => this.initWs()).then(e => (this.reconnectPromise = void 0, this.currentLeftReconnectTimes = this.reconnectTimes, e)).catch(e => (this._state = zt.CLOSED, this.emit('error', e), Promise.reject(e))), this.reconnectPromise) } request (e, t) { const r = Je(8); return t.rpcid = r, Y.log('ws request', r, e, t), this.sendWsMsg(e, t), new Promise(t => { const n = i => { i.rpcid === r && (Y.log('ws response', r, e, i), this.off(`${e}-res`, n), t(i)) }; this.on(`${e}-res`, n) }) } release () { this.reconnectTimeoutID && clearTimeout(this.reconnectTimeoutID), this.removeEvent(), this.ws.onclose = null, this.ws.onerror = null, this.ws.close() } } class Qt { } class Kt { constructor (e, t, r, n) { this.videoTrackInfo = [], this.audioTrackInfo = [], this.layoutLevel = 0, this.width = e, this.height = t, this.jobId = n, this.controller = r, this.controller.getCurrentTracks().forEach(e => { e.kind === 'audio' ? this.audioTrackInfo.push(e) : this.videoTrackInfo.push(e) }), this.controller.addMergeTrack(this.audioTrackInfo.map(e => ({ trackId: e.trackId })), this.jobId), this.initLayout(), this.controller.onAddTracks = e => { const t = e.filter(e => e.kind === 'audio'); const r = e.filter(e => e.kind === 'video'); this.controller.addMergeTrack(t.map(e => ({ trackId: e.trackId })), this.jobId), r.forEach(this.handleAddVideoTrack.bind(this)) }, this.controller.onRemoveTracks = e => { e.filter(e => e.kind === 'video').forEach(this.handleRemoveVideoTrack.bind(this)) }, Y.log('init default merger, init layout: ', this.layout) } initLayout () { const e = this.videoTrackInfo.length; this.layoutLevel = 0, this.layout = { 'level-0': { items: { 'item-0': { x: 0, y: 0, isExpand: !1, isExpanded: !1, index: 0 } }, itemWidth: this.width, itemHeight: this.height, maxItems: 1, currentItems: 0, splitWidthFlag: this.width < this.height } }; let t = this.width >= this.height; if (e !== 0) { for (; Math.pow(2, this.layoutLevel) < e;) this.updateLayoutLevel(t), t = !t; this.setLevelLayoutStream() } } updateLayoutLevel (e) { const t = this.layout[`level-${this.layoutLevel}`]; const r = t.itemWidth; const n = t.itemHeight; this.layoutLevel += 1; const i = Math.pow(2, this.layoutLevel); const o = e ? r / 2 : r; const a = e ? n : n / 2; if (this.layoutLevel === 1) this.layout[`level-${this.layoutLevel}`] = { items: { 'item-0': { x: 0, y: 0, isExpand: !1, isExpanded: !1, index: 0 }, 'item-1': { x: this.width >= this.height ? o : 0, y: this.width < this.height ? a : 0, isExpand: !1, isExpanded: !1, index: 1 } }, maxItems: i, currentItems: 0, itemWidth: o, itemHeight: a, splitWidthFlag: e }; else { this.layout[`level-${this.layoutLevel}`] = { items: {}, maxItems: i, currentItems: 0, itemWidth: o, itemHeight: a, splitWidthFlag: e }; const t = this.layout[`level-${this.layoutLevel}`].items; Object.keys(this.layout[`level-${this.layoutLevel - 1}`].items).forEach(r => { const n = this.layout[`level-${this.layoutLevel - 1}`].items[r]; const i = 2 * n.index; t[`item-${i}`] = { x: n.x, y: n.y, isExpand: !1, isExpanded: !1, index: i }, t[`item-${i + 1}`] = e ? { x: n.x + o, y: n.y, isExpand: !1, isExpanded: !1, index: i + 1 } : { x: n.x, y: n.y + a, isExpand: !1, isExpanded: !1, index: i + 1 } }) } Y.log(`merger: increase layout level, current level: ${this.layoutLevel}`, this.layout) } setLevelLayoutStream () { const e = this.videoTrackInfo.length; const t = this.layout[`level-${this.layoutLevel}`]; let r = t.maxItems - e; let n = 0; for (let e = 0; e < t.maxItems; e += 1)r > 0 ? e % 2 == 0 ? (t.items[`item-${e}`].isExpand = !0, t.items[`item-${e}`].trackId = this.videoTrackInfo[n].trackId, this.sendMergeOpt(this.layoutLevel, e), n += 1) : (t.items[`item-${e}`].isExpanded = !0, r -= 1) : (t.items[`item-${e}`].trackId = this.videoTrackInfo[n].trackId, this.sendMergeOpt(this.layoutLevel, e), n += 1); t.currentItems = e } sendMergeOpt (e, t) { const r = this.layout[`level-${e}`]; const n = r.items[`item-${t}`]; if (!n.trackId || n.isExpanded) return; let i = r.itemWidth; let o = r.itemHeight; n.isExpand && (r.splitWidthFlag ? i *= 2 : o *= 2); const a = { x: n.x, y: n.y, w: i, h: o, z: 0, trackId: n.trackId }; this.controller.addMergeTrack([a], this.jobId) } handleRemoveVideoTrack (e) { I(this.videoTrackInfo, t => t.trackId === e.trackId); const t = this.layout[`level-${this.layoutLevel}`]; if (this.layoutLevel > 0 && this.videoTrackInfo.length <= this.layout[`level-${this.layoutLevel - 1}`].maxItems) this.layoutLevel -= 1, Y.log(`merger: reduce layout level, current level: ${this.layoutLevel}`, this.layout), this.setLevelLayoutStream(); else for (const r in t.items) { const n = t.items[r]; if (n.trackId === e.trackId) { n.index % 2 == 0 ? (t.items[`item-${n.index + 1}`] ? (n.isExpand = !0, n.trackId = t.items[`item-${n.index + 1}`].trackId, t.items[`item-${n.index + 1}`].isExpanded = !0, t.items[`item-${n.index + 1}`].trackId = void 0) : n.trackId = void 0, this.sendMergeOpt(this.layoutLevel, n.index)) : (n.isExpanded = !0, n.trackId = void 0, t.items[`item-${n.index - 1}`].isExpand = !0, this.sendMergeOpt(this.layoutLevel, n.index - 1)); break } } } handleAddVideoTrack (e) { const t = this.videoTrackInfo.length; if (this.videoTrackInfo.push(e), this.videoTrackInfo = R(this.videoTrackInfo, 'trackId'), this.videoTrackInfo.length === t) return void Y.log('handle add video track ignore', e); const r = this.layout[`level-${this.layoutLevel}`]; if (this.videoTrackInfo.length <= r.maxItems) { for (const t in r.items) { const n = r.items[t]; if (!n.trackId) { n.trackId = e.trackId, n.isExpanded && (n.isExpanded = !1, r.items[`item-${n.index - 1}`].isExpand = !1, this.sendMergeOpt(this.layoutLevel, n.index - 1)), this.sendMergeOpt(this.layoutLevel, n.index); break } } r.currentItems = this.videoTrackInfo.length } else this.updateLayoutLevel(!r.splitWidthFlag), this.setLevelLayoutStream() } release () { this.controller.release() } } class Zt { constructor (e, t, r, n) { this.id = e, this.mid = t, this.kind = r, this.rtpParameters = n, this.track = null } } class Yt { constructor (t, r, n, i, o) { this._connectStatus = e.TrackConnectStatus.Idle, this.track = n, this.trackId = i, this.mid = o, this.transport = t, this.direction = r } get connectStatus () { return this._connectStatus } set connectStatus (e) { if (e !== this._connectStatus) { const t = this._connectStatus; this._connectStatus = e, He(() => { this.onConnectStatusChange && this.onConnectStatusChange(t, this._connectStatus) }) } } startConnect () { return this.connectStatus = e.TrackConnectStatus.Connecting, new Promise((t, r) => { this.onConnectStatusChange = (n, i) => { i === e.TrackConnectStatus.Connect && t(), i === e.TrackConnectStatus.Idle && r() } }) } appendConsumner (e, t) { this.consumer = new Zt(this.trackId, this.mid, t, e), this.transport.appendConsumer(this.consumer) } setMute (e) { this.track && this.track.setMute(e) } addTrackId (e) { this.track && (this.trackId = e, this.track.setInfo({ trackId: e })) } release () { this.consumer && this.transport ? (this.transport.recvHandler.isPcReady && this.transport.removeConsumers([this.consumer]), this.track && this.track.release()) : this.track && this.track.reset() } } class er extends dt { constructor (e, t, r) { super(), this._isRestartingICE = !1, this.isPcReady = !1, this.lastCalculationStatsList = [], this.intervalId = -1, this._direction = e, this._pc = Ye(), this._extendedRtpCapabilities = t, this._remoteSdp = new $t(e, t), this._simulcast = !!r && r.simulcast, this._pc.addEventListener('iceconnectionstatechange', () => { switch (this._pc.iceConnectionState) { case 'checking': this.emit('@connectionstatechange', 'connecting'); break; case 'connected': case 'completed': this.emit('@connectionstatechange', 'connected'), this.registerMediaStatisticStatsReport(); break; case 'failed': this.emit('@connectionstatechange', 'failed'), this.unregisterMediaStatisticStatsReport(); break; case 'disconnected': this.emit('@connectionstatechange', 'disconnected'), this.unregisterMediaStatisticStatsReport(); break; case 'closed': this.emit('@connectionstatechange', 'closed'), this.unregisterMediaStatisticStatsReport() } }) } async getStats (e, t) { return await tt(this._pc, e, this._direction, t) } mediaStatisticsToQosMessage (t) { const r = t.sort((e, t) => t.packet_lost_rate - e.packet_lost_rate)[0].packet_lost_rate; const n = t.sort((e, t) => t.rtt - e.rtt)[0].rtt; let i; i = r > 9 || n > 100 ? e.NetworkGrade.POOR : r > 5 || n > 80 ? e.NetworkGrade.FAIR : r > 1 || n > 40 ? e.NetworkGrade.GOOD : e.NetworkGrade.EXCELLENT; const o = navigator; o.connection && o.connection.effectiveType && ['slow-2g', '2g', '3g'].includes(o.connection.effectiveType) && (i = e.NetworkGrade.POOR); const a = { networkGrade: i, tracks_qos: t.map(e => ({ kind: e.kind, lostRate: e.packet_lost_rate, rtt: e.rtt, track: e.track_id })) }; return { qos: JSON.stringify(a) } } registerMediaStatisticStatsReport () { this.unregisterMediaStatisticStatsReport(), this.intervalId = window.setInterval(async () => { const e = await le(this._pc); e && e.length > 0 && (this.emit('@send-qos-message', this.mediaStatisticsToQosMessage(e)), ye.addMediaStatistics(e, this.lastCalculationStatsList), this.lastCalculationStatsList = (e || []).map(e => r({}, e.calculation_stats))) }, 3e3) } unregisterMediaStatisticStatsReport () { this.intervalId !== -1 && (window.clearInterval(this.intervalId), this.lastCalculationStatsList = [], this.intervalId = -1) } getCurrentIceConnectionState () { return this._pc.iceConnectionState } close () { Y.log('handle', this._direction, 'close'), this.removeEvent(), this.unregisterMediaStatisticStatsReport(), this._pc.close(), this.isPcReady = !1 } } class tr extends er { constructor (e, t, r) { super('send', e, r), Y.log('init send handler'), this._transportReady = !1, this._stream = new MediaStream(), this._signaling = t, t.on('on-pubpc-state', e => { this._remoteSdp.transportRemoteParameters && e.pcid === this._remoteSdp.transportRemoteParameters.pcid && (e.connected || this.emit('@connectionstatechange', 'remote-disconnected')) }) } getReady (e) { return new Promise((t, r) => { const n = r => { if (r.pcid === e.pcid) { if (this._signaling.off('on-pubpc-state', n), !r.connected) return; this.isPcReady = !0, t() } }; this._signaling.on('on-pubpc-state', n) }) } addProducerTracks (e) { Y.debug('add producer', e); const t = e.map(e => e.mediaTrack).filter(e => !this._stream.getTrackById(e.id)); if (t.length === 0) return Promise.reject(new Error('track already added')); let r; const n = []; let i; let o = !0; return Promise.resolve().then(async () => { if (t.forEach(this._stream.addTrack, this._stream), T.unifiedPlan && T.supportTransceivers) for (const e of t) { const t = await et(e, this._pc); Y.debug('add transceiver', t, t.mid), n.push(t) } else Y.debug('add tracks', t), r = t.map(e => this._pc.addTrack(e, this._stream)); return this._simulcast && k.name, nr(this._pc, this._simulcast) }).then(e => { let t; return T.needH264FmtpLine && (e.sdp += `a=fmtp:107 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f${Bt}`), t = { type: 'offer', sdp: e.sdp }, i = t.sdp, Y.log('publish: set local offer', t), this._pc.setLocalDescription(t) }).then(() => { for (const t of n) { if (!t.sender.track) continue; const r = e.find(e => e.mediaTrack === t.sender.track); if (!r || !t.mid) throw Se('can not get transceiver mid!'); r.setInfo({ mid: t.mid }) } if (!this._transportReady) return o = !1, this._setupTransport(e) }).then(() => this._remoteSdp.createRemoteAnswer(i)).then(e => { const t = { type: 'answer', sdp: e }; return Y.debug('addProducer answer', t), this._pc.setRemoteDescription(t) }).then(() => this._pcReady).then(() => o ? this.safeEmitAsPromise('@needpubtracks', e, i) : Promise.resolve(this._remoteSdp.transportRemoteParameters)).catch(e => { Y.log('add producer error', e); try { for (const e of r) this._pc.removeTrack(e); for (const e of n) e.direction = 'inactive' } catch (e) { } for (const e of t) this._stream.removeTrack(e); throw e instanceof _e ? e : Se(e) }) } removeProducerTracks (e) { Y.debug('removeProducerTracks', e); const t = e.filter(e => !!e.track).map(e => e.track.mediaTrack).filter(e => this._stream.getTrackById(e.id)); let r; return Promise.resolve().then(() => { const e = this._pc.getSenders().filter(e => e.track && t.includes(e.track)); if (e.length === 0) return Y.warning('removeProducerTracks [nothing to remove]'), Promise.reject('removeProducerTracks: nothing to remote'); for (const t of e) this._pc.removeTrack(t); for (const e of t) this._stream.removeTrack(e); return this._simulcast && k.name, nr(this._pc, this._simulcast) }).then(e => { const t = new RTCSessionDescription(e); return r = t.sdp, Y.log('unpublish: set local offer', t), this._pc.setLocalDescription(t) }).then(() => { const e = { type: 'answer', sdp: this._remoteSdp.createRemoteAnswer(r) }; return Y.log('unpublish: set remote answer', e), this._pc.setRemoteDescription(e) }).catch(e => { if (this._stream.getTracks().length !== 0) throw e instanceof _e ? e : Se(e); Y.debug('removeProducer() | ignoring expected error due no sending tracks: %s', e.toString()) }).then(() => { this.safeEmitAsPromise('@needunpubtracks', e) }) } restartICE (e, t) { return Y.log('restart send ice'), this._isRestartingICE = !0, Promise.resolve().then(() => this._remoteSdp.updateICEData(e, t)).then(() => nr(this._pc, this._simulcast, { iceRestart: !0 })).then(e => this._pc.setLocalDescription(e)).then(() => { const e = { type: 'answer', sdp: this._remoteSdp.createRemoteAnswer(this._pc.localDescription.sdp) }; return this._pc.setRemoteDescription(e) }) } _setupTransport (e) { const t = Date.now(); return Promise.resolve().then(() => this._pc.localDescription ? this._pc.localDescription : nr(this._pc, this._simulcast)).then(t => this.safeEmitAsPromise('@needpubpc', t.sdp, e)).then(r => (ye.addEvent('PublisherPC', { signal_take_time: Date.now() - t, result_code: r.code, up_stream_ip: (r.iceCandidates || []).map(({ ip: e }) => e).join(','), tracks: r.tracks.map(t => { const r = e.find(e => e.mediaTrack.id === t.localid); if (r) return { local_id: t.localid, track_id: t.trackid, source_type: r.sourceType, kind: r.info.kind, tag: r.info.tag || '', muted: !!r.info.muted, master: !!r.master, kbps: r.info.kbps || -1, encode_video_width: 0, encode_video_height: 0 } }).filter(e => void 0 !== e) }), this.pcid = r.pcid, this._transportReady = !0, this._pcReady = this.getReady(r), this._remoteSdp.setTransportRemoteParameters(r))) } } class rr extends er { constructor (e, t, r) { super('recv', e, r), this._transportCreated = !1, this._consumerInfos = new Map(), this._signaling = t, t.on('on-subpc-state', e => { this._remoteSdp.transportRemoteParameters && e.pcid === this._remoteSdp.transportRemoteParameters.pcid && (e.connected || this.emit('@connectionstatechange', 'remote-disconnected')) }), Y.log('init recvhandler', this) } getReady (e) { return new Promise((t, r) => { const n = r => { if (r.pcid === e.pcid) { if (this._signaling.off('on-subpc-state', n), !r.connected) return; this.isPcReady = !0, t() } }; this._signaling.on('on-subpc-state', n) }) } async addConsumerTracks (e) { if (T.unifiedPlan && g) { const t = []; for (const r of e) { const e = await this.addConsumerTrack(r); t.push(e) } return t } Y.log('add consumers', e); const t = []; const r = Array.from(this._consumerInfos.values()); for (const n of e) { const e = r.find(e => e.consumerId === n.id); if (e && !e.closed) t.push(e); else { const e = this.genNewConsumerInfo(n); if (T.unifiedPlan) { const t = n.mid; e.mid = t, this._consumerInfos.set(t, e) } else this._consumerInfos.set(n.id, e); t.push(e) } } return Promise.resolve().then(() => { const e = { type: 'offer', sdp: this._remoteSdp.createRemoteOffer(Array.from(this._consumerInfos.values())) }; return Y.debug('subscribe: set remote offer', e), this._pc.setRemoteDescription(e) }).then(() => (T.unifiedPlan, this._pc.createAnswer())).then(e => (Y.debug('subscribe, set local answer', e), this._pc.setLocalDescription(e))).then(() => this._pcReady).then(() => { for (let r = 0; r < t.length; r += 1) { const n = t[r]; const i = e[r]; if (!i.track) { if (T.unifiedPlan) { const e = this._pc.getTransceivers().find(e => !!e.receiver.track && (e.receiver.track.id === n.trackId || e.mid === n.mid)); e && (i.track = e.receiver.track) } else if (T.getReceivers) { const e = this._pc.getReceivers().find(e => { const { track: t } = e; return !!t && n.trackId === t.id }); e && (i.track = e.track) } else { const e = this._pc.getRemoteStreams().find(e => e.id === n.streamId); e && (i.track = e.getTrackById(n.trackId)) } if (!i.track) throw Se('remote track not found'); Y.log('subscribe: get new track', i.track) } } return e.map(e => e.track) }) } genNewConsumerInfo (e) { const t = e.rtpParameters.encodings[0]; const r = e.rtpParameters.rtcp.cname; const n = e.mid; return { kind: e.kind, streamId: T.unifiedPlan ? `recv-stream-${n}` : `recv-stream-${t.ssrc}`, trackId: T.unifiedPlan ? `consumer-${e.kind}-${n}` : `consumer-${e.kind}-${t.ssrc}`, ssrc: t.ssrc, rtxSsrc: t.rtx ? t.rtx.ssrc : void 0, cname: r, consumerId: e.id, closed: !1 } } async addConsumerTrack (e) { Y.log('add consumer', e); let t = null; const r = Array.from(this._consumerInfos.values()).find(t => t.consumerId === e.id); if (r && !r.closed) t = r; else { const r = this.genNewConsumerInfo(e); if (T.unifiedPlan) { const t = e.mid; r.mid = t, this._consumerInfos.set(t, r) } else this._consumerInfos.set(e.id, r); t = r } return Promise.resolve().then(() => { const e = { type: 'offer', sdp: this._remoteSdp.createRemoteOffer(Array.from(this._consumerInfos.values())) }; return Y.log('set ontrack'), this._pc.ontrack = e => { Y.log('ontrack', e.receiver.track) }, Y.debug('subscribe: set remote offer', e), this._pc.setRemoteDescription(e) }).then(() => this._pc.createAnswer()).then(e => (Y.debug('subscribe, set local answer', e), this._pc.setLocalDescription(e))).then(() => this._pcReady).then(() => { let r = null; if (T.unifiedPlan && T.supportTransceivers && e && t) { const n = this._pc.getTransceivers().find(r => !!r.receiver.track && ((r.receiver.track.id === t.trackId || r.mid === t.mid) && (e.track = r.receiver.track, !0))); n && (r = n.receiver.track) } else if (e && t) { const n = this._pc.getReceivers().find(r => { const { track: n } = r; return !!n && (t.trackId === n.id && (e.track = n, !0)) }); n && (r = n.track) } if (!r && e) throw Se('remote track not found'); return Y.log('subscribe: get new track', r, r.readyState), r }) } removeConsumerTracks (e) { Y.log('remove consumer', e); let t = !1; for (const r of e) { const e = Array.from(this._consumerInfos.values()).find(e => e.consumerId === r.id && !e.closed); e ? (t = !0, T.unifiedPlan ? (r.track = null, e.closed = !0) : this._consumerInfos.delete(r.id)) : Y.log('can not find unpublish track target, ignore') } return t ? Promise.resolve().then(() => { const e = { type: 'offer', sdp: this._remoteSdp.createRemoteOffer(Array.from(this._consumerInfos.values())) }; return Y.log('unsubscribe set remote offer', e), this._pc.setRemoteDescription(e) }).then(() => this._pc.createAnswer()).then(e => (Y.log('unsubscribe set local answer', e), this._pc.setLocalDescription(e))) : Promise.resolve() } restartICE (e, t) { return Y.log('recv restart ice'), this._isRestartingICE = !0, Promise.resolve().then(() => this._remoteSdp.updateICEData(e, t)).then(() => { const e = { type: 'offer', sdp: this._remoteSdp.createRemoteOffer(Array.from(this._consumerInfos.values())) }; return this._pc.setRemoteDescription(e) }).then(() => this._pc.createAnswer()).then(e => { this._pc.setLocalDescription(e) }) } async setupTransport (e) { if (this._transportCreated) return await this._pcReady; const t = Date.now(); const r = await this.safeEmitAsPromise('@needsubpc', e); return ye.addEvent('SubscriberPC', { signal_take_time: Date.now() - t, result_code: r.code, down_stream_ip: (r.iceCandidates || []).map(({ ip: e }) => e).join(','), tracks: r.tracks.map(e => ({ track_id: e.trackid, status: e.status })) }), this.pcid = r.pcid, this._transportCreated = !0, this._pcReady = this.getReady(r), Y.log('init subscribe, get transport remote', r), await this._remoteSdp.setTransportRemoteParameters(r), r } } function nr (e, t, r) { return t && k.name === 'chrome' ? e.createOffer(r).then(e => { const { type: t, sdp: r } = e; return r ? { type: t, sdp: Vt(r, 3) } : e }) : e.createOffer(r) } function ir (e, t, r, n) { switch (e) { case 'send': return new tr(t, r, n); case 'recv': return new rr(t, r, n) } } !(function (e) { e.SEND_TRACKS = '@transport:send-tracks', e.RESTART_SEND_ICE = '@transport:send-restart-ice', e.REMOVE_TRACKS = '@transport:remove-tracks', e.INIT_RECV = '@transport:init-recv', e.RESTART_RECV_ICE = '@transport:recv-restart-ice', e.ADD_CONUMERS = '@transport:add-consumers', e.REMOVE_CONSUMERS = '@transport:remove-consumers' }(Jt || (Jt = {}))); class or extends dt { constructor (e, t, r) { super(), this.sendCommandQueue = new me('SendQueue'), this.recvCommandQueue = new me('RecvQueue'), this.simulcast = !1, this.recvInitCommandQueue = new me('RecvInitQueue'), this.sendTrackQueue = [], this.consumerQueue = [], this._publishTracks = new Map(), this.extendedRtpCapabilities = e, this.signaling = t, this.simulcast = !!r, this.sendHandler = ir('send', e, t, { simulcast: this.simulcast }), this.recvHandler = ir('recv', e, t, { simulcast: this.simulcast }), this.handleSendHandler(), this.handleRecvHandler(), this.sendCommandQueue.on('exec', this.handleSendCommandTask.bind(this)), this.recvCommandQueue.on('exec', this.handleRecvCommandTask.bind(this)), this.recvInitCommandQueue.on('exec', this.handleRecvInitCommandTask.bind(this)), this.initSubPcPromise = new Promise(e => { this.initSubPcPromiseResolve = e }) } get publishTracks () { return Array.from(this._publishTracks.values()) } resolveInitSubPcPromise () { this.initSubPcPromiseResolve && (this.initSubPcPromiseResolve(), this.initSubPcPromiseResolve = void 0) } handleSendHandler () { this.sendHandler.on('@needpubpc', (e, t, r, n) => { this.safeEmitAsPromise('@needpubpc', e, t).then(r).catch(n) }).on('@connectionstatechange', e => { switch (Y.log('pubpc connectionstatechange', e), ye.addEvent('ICEConnectionState', { pc_type: 0, state: e, id: this.sendHandler.pcid }), e) { case 'remote-disconnected': case 'closed': case 'failed': this.signaling.state === zt.OPEN ? this.reconnectProducer() : this.sendHandler.close(); break; case 'disconnected': if (this.sendHandler._isRestartingICE || !this.sendHandler.pcid) return; this.signaling.state === zt.OPEN ? this.restartSendICE(this.sendHandler.pcid) : this.signaling.once('@signalingauth', e => { this.sendHandler.getCurrentIceConnectionState() === 'disconnected' && (this.extendedRtpCapabilities = e.rtpcaps, this.restartSendICE(this.sendHandler.pcid)) }) } }).on('@needpubtracks', (e, t, r, n) => { const i = e.map(Ct); const o = Date.now(); this.signaling.request('pub-tracks', { tracks: i, sdp: t }).then(t => { switch (ye.addEvent('PublishTracks', { signal_take_time: Date.now() - o, result_code: t.code, tracks: t.tracks.map(t => { const r = e.find(e => e.mediaTrack.id === t.localid); if (r) return { local_id: t.localid, track_id: t.trackid, source_type: r.sourceType, kind: r.info.kind, tag: r.info.tag || '', muted: !!r.info.muted, master: !!r.master, kbps: r.info.kbps || -1, encode_video_width: 0, encode_video_height: 0 } }).filter(e => void 0 !== e) }), t.code) { case 0: break; case 10052: return n(xe()); case 10061: return this.reconnectProducer(), n(we(10061, t.error)); default: return n(we(t.code, t.error)) } for (const e of t.tracks) if (!e.status) return void n(we(t.code, t.error)); r(t) }, n) }).on('@needunpubtracks', (e, t, r) => { ye.addEvent('UnPublishTracks', { tracks: e.map(e => ({ track_id: e.trackId })) }), this.signaling.request('unpub-tracks', { tracks: e.map(e => ({ trackid: e.trackId })) }).then(e => { t(e) }) }).on('@send-qos-message', e => { this.signaling.request('send-qos-message', e) }) } async sendTracks (e) { return e.length === 0 ? Promise.resolve() : this.sendCommandQueue.push(Jt.SEND_TRACKS, e) } removeTracks (e) { return e.length === 0 ? Promise.resolve() : this.sendCommandQueue.push(Jt.REMOVE_TRACKS, e) } async restartSendICE (e) { return T.supportRestartICE ? this.sendCommandQueue.push(Jt.RESTART_SEND_ICE, e) : Promise.resolve(this.reconnectProducer()) } handleSendCommandTask (e, t) { switch (e.method) { case Jt.SEND_TRACKS: return void (t.promise = this._execAddProducerTracks(e.data)); case Jt.REMOVE_TRACKS: return void (t.promise = this._execRemoveTracks(e.data)); case Jt.RESTART_SEND_ICE: return void (t.promise = this._execRestartSendICE(e.data)) } } addTrackToPublishTracks (e) { const t = e.map(e => new Yt(this, 'send', e)); for (const e of t) this._publishTracks.set(e.track.mediaTrack.id, e); return t } removeTrackFromPublishTracks (e) { for (const t of e) this._publishTracks.delete(t.mediaTrack.id) } async _execAddProducerTracks (t) { const r = await this.sendHandler.addProducerTracks(t.map(e => e.track)); for (const e of t) { const t = Ge(r.tracks, 'localid', e.track.mediaTrack.id); t && (e.addTrackId(t.trackid), e.track.setInfo({ versionid: t.versionid }), e.track.resetStats()) } return t.map(t => t.connectStatus = e.TrackConnectStatus.Connect), r } _execRemoveTracks (e) { return this.removeTrackFromPublishTracks(e.map(e => e.track)), e.map(e => e.release()), this.sendHandler.removeProducerTracks(e) } async _execRestartSendICE (e) { this.sendHandler._isRestartingICE = !0; const t = await this.signaling.request('pubpc-restart', { pcid: e }); if (t.code !== 0) return this.sendHandler._isRestartingICE = !1, Y.debug('restart ice faild', t.code, t.error), void this.reconnectProducer(); try { await this.sendHandler.restartICE(t.iceParameters, t.iceCandidates), this.sendHandler._isRestartingICE = !1 } catch (e) { Y.debug('restart ice faild', t.code, t.error), this.sendHandler._isRestartingICE = !1, this.reconnectProducer() } } reconnectProducer () { this.resetSendCommandQueue(), this.sendHandler.close(); const t = this.publishTracks; this.sendHandler = ir('send', this.extendedRtpCapabilities, this.signaling, { simulcast: this.simulcast }), this.handleSendHandler(), t.forEach(t => { t.connectStatus = e.TrackConnectStatus.Connecting }), this.emit('@needrepub', t) } handleRecvHandler () { this.recvHandler.on('@needsubpc', (e, t, r) => { this.safeEmitAsPromise('@needsubpc', e).then(t, r) }).on('@connectionstatechange', e => { switch (Y.log('sub pc connection state change', e), ye.addEvent('ICEConnectionState', { pc_type: 1, state: e, id: this.recvHandler.pcid }), e) { case 'remote-disconnected': case 'closed': case 'failed': this.signaling.state === zt.OPEN ? this.resetRecvHandler() : this.recvHandler.close(); break; case 'disconnected': if (this.recvHandler._isRestartingICE || !this.recvHandler.pcid) return; this.signaling.state === zt.OPEN ? this.restartRecvICE(this.recvHandler.pcid) : this.signaling.once('@signalingauth', e => { this.recvHandler.getCurrentIceConnectionState() === 'disconnected' && (this.extendedRtpCapabilities = e.rtpcaps, this.restartRecvICE(this.recvHandler.pcid)) }) } }) } appendConsumer (e) { this.consumerQueue.push(e) } async addConsumers () { const e = this.consumerQueue; return this.consumerQueue = [], this.recvCommandQueue.push(Jt.ADD_CONUMERS, e) } initRecvHandler (e) { return this.recvInitCommandQueue.push(Jt.INIT_RECV, e) } async removeConsumers (e) { await this.recvCommandQueue.push(Jt.REMOVE_CONSUMERS, e) } async restartRecvICE (e) { return T.supportRestartICE ? this.recvCommandQueue.push(Jt.RESTART_RECV_ICE, e) : this.resetRecvHandler() } async _removeConsumers (e) { await this.recvHandler.removeConsumerTracks(e) } async _initRecvHandler (e) { return this.recvHandler.isPcReady ? (await this.initSubPcPromise, null) : await this.recvHandler.setupTransport(e) } async _addConsumers (e) { if (e.length === 0) return Promise.resolve([]); return await this.recvHandler.addConsumerTracks(e) } async _execRestartRecvICE (e) { this.recvHandler._isRestartingICE = !0; const t = await this.signaling.request('subpc-restart', { pcid: e }); if (t.code !== 0) return this.recvHandler._isRestartingICE = !1, Y.debug('restart ice faild', t.code, t.error), void this.resetRecvHandler(); try { await this.recvHandler.restartICE(t.iceParameters, t.iceCandidates), this.recvHandler._isRestartingICE = !1 } catch (e) { this.recvHandler._isRestartingICE = !1, Y.debug('restart ice faild', t.code, t.error), this.resetRecvHandler() } } handleRecvCommandTask (e, t) { switch (e.method) { case Jt.ADD_CONUMERS: return void (t.promise = this._addConsumers(e.data)); case Jt.REMOVE_CONSUMERS: return void (t.promise = this._removeConsumers(e.data)); case Jt.RESTART_RECV_ICE: return void (t.promise = this._execRestartRecvICE(e.data)) } } handleRecvInitCommandTask (e, t) { switch (e.method) { case Jt.INIT_RECV: return void (t.promise = this._initRecvHandler(e.data)) } } resetSendCommandQueue () { Y.log('reset send queue'), this.sendCommandQueue = new me('SendQueue'), this.sendCommandQueue.on('exec', this.handleSendCommandTask.bind(this)) } resetRecvCommandQueue () { Y.log('reset recv queue'), this.recvCommandQueue = new me('RecvQueue'), this.recvInitCommandQueue = new me('RecvInitQueue'), this.recvCommandQueue.on('exec', this.handleRecvCommandTask.bind(this)), this.recvInitCommandQueue.on('exec', this.handleRecvInitCommandTask.bind(this)) } resetRecvHandler () { this.resetRecvCommandQueue(), this.emit('@needresetrecv'), this.recvHandler.close(), this.recvHandler = ir('recv', this.extendedRtpCapabilities, this.signaling, { simulcast: this.simulcast }), this.initSubPcPromise = new Promise(e => { this.initSubPcPromiseResolve = e }), this.handleRecvHandler(), this.emit('@needresub') } release () { this.recvHandler.close(), this.sendHandler.close(), this.publishTracks.forEach(e => e.release()) } } (qt = e.RoomState || (e.RoomState = {}))[qt.Idle = 0] = 'Idle', qt[qt.Connecting = 1] = 'Connecting', qt[qt.Connected = 2] = 'Connected', qt[qt.Reconnecting = 3] = 'Reconnecting'; const ar = { transportPolicy: 'preferUdp', simulcast: !1, reconnectTimes: 3 }; class sr extends E { constructor (t = ar) { super(), this._trackInfo = [], this.subscribeTracks = [], this._users = new Map(), this._roomState = e.RoomState.Idle, this.mergeJobMerger = {}, this.defaultMergeJobTracks = [], this.mergeJobTracks = {}, this._publish = (t, r) => new Promise(async (n, i) => { if (this.roomState !== e.RoomState.Connected) return void i(Se('not connected to the room, please run joinRoom first')); t.length === 0 && n(), t.forEach(e => e.userId = this.userId); const o = this.connectionTransport; const a = this.signaling; let s; if (r) { const e = t.map(e => e.mediaTrack.id); s = o.publishTracks.filter(t => e.indexOf(t.track.mediaTrack.id) !== -1) } else { const e = o.publishTracks.map(e => e.track.mediaTrack.id); if (t.filter(t => e.indexOf(t.mediaTrack.id) === -1).length !== t.length) return void i(Se('there are already published tracks in the provided tracks')); s = o.addTrackToPublishTracks(t) } if (Y.debug('start publish', s, r), !r) { const e = s.map(e => e.startConnect()); Promise.all(e).then(() => n()).catch(() => { i(Ne()) }) } try { await o.sendTracks(s), a.sendWsMsg('mute-tracks', { tracks: s.map(e => ({ trackid: e.trackId, muted: !!e.track.info.muted })) }); const e = Ge(this.users, 'userId', this.userId); if (e) { e.addTracks(s.map(e => e.track)); let t = []; !0 === this.config.simulcast && (t = ['high', 'medium', 'low']), e.addPublishedTrackInfo(s.map(e => ({ trackId: e.trackId, muted: !!e.track.info.muted, kind: e.track.info.kind, tag: e.track.info.tag, userId: this.userId, versionid: e.track.info.versionid, profiles: t }))) } t.forEach(e => { e.on('@get-stats', (t, r, n) => { if (!this.connectionTransport) return r([]); this.connectionTransport.sendHandler.getStats(e.mediaTrack, t).then(r, n) }) }), this.getAllMerger().forEach(e => e.controller.onAddTracks(t.map(e => e.info))) } catch (e) { if (e instanceof _e) switch (e.code) { case 10061: case 30001: return; case 10052: return Y.warning(e, 'republish'), void setTimeout(() => this._publish(t, !0), 1e3); default: o.removeTrackFromPublishTracks(t), i(e) } else Y.warning(e, 'republish'), setTimeout(() => this._publish(t, !0), 1e3) } }), this._subscribe = (t, r, n = !1, i) => new Promise(async (o, a) => { if (this.roomState !== e.RoomState.Connected) return void a(Se('can not connected to the room, please joinRoom first')); if (t.length === 0) return void o([]); Y.debug('subscribe', t, r); const s = this._trackInfo.filter(e => t.includes(e.trackid)); if (s.length !== t.length) return void a(Pe(10041, `can not find track in room ${t}`)); let c; const u = this.connectionTransport; const d = this.signaling; if (r) c = this.subscribeTracks.filter(e => t.indexOf(e.trackId) !== -1); else { const e = this.subscribeTracks.map(e => e.trackId); const t = s.filter(t => !e.includes(t.trackid)); c = t.map(e => new Yt(u, 'recv', void 0, e.trackid, e.mid)), this.subscribeTracks = this.subscribeTracks.concat(c) } Y.log('sub tracks', c, i); try { if (!r) { const e = c.map(e => e.startConnect()); Promise.all(e).then(() => o(c.map(e => e.track))).catch(() => { a(Ne()) }) } let l = await u.initRecvHandler(c.map(e => e.trackId)); if (!l) { const e = Date.now(); l = await d.request('sub-tracks', { tracks: c.map(e => { const t = i && i[e.trackId]; return t ? { trackid: e.trackId, profile: t } : { trackid: e.trackId } }) }), ye.addEvent('SubscribeTracks', { result_code: l.code, signal_take_time: Date.now() - e, tracks: l.tracks.map(e => ({ track_id: e.trackid, status: e.status })) }) } switch (Y.log('get sub res data', l), l.code) { case 0: break; case 10052: throw xe(); case 10062: throw u.resetRecvHandler(), Pe(10062, l.error); default: throw Pe(l.code, l.error) } const h = l.tracks.filter(e => !!e.status); const f = l.tracks.filter(e => !e.status).map(e => e.trackid); if (h.length < l.tracks.length && n) throw Pe(10041, `can not find target track id: ${f.join(' ')}`); if (h && !n) { Y.debug(`can not find target track id: ${f.join('')}, continue`); const e = I(c, e => f.indexOf(e.trackId) !== -1); I(this.subscribeTracks, e => f.indexOf(e.trackId) !== -1), e.map(e => e.release()) } l.tracks = h; for (const e of l.tracks || []) { const t = c.find(t => t.trackId === e.trackid); const r = s.find(t => t.trackid === e.trackid); if (!t || !r) continue; const n = e.rtpparams; t.appendConsumner(n, r.kind) } await u.addConsumers(), u.resolveInitSubPcPromise(); for (const e of c) { const { consumer: t } = e; if (!t || !t.track) continue; const r = t.track; let n = e.track; const i = s.find(e => e.trackid === t.id); if (!i) continue; n ? n.resume(r) : r.kind === 'audio' ? (n = new bt(r, i.playerid, 'remote')).initAudioManager() : n = new lt(r, i.playerid, 'remote', i.profiles || []), n.setInfo({ trackId: i.trackid, userId: i.playerid, tag: i.tag, kind: i.kind, muted: i.muted, versionid: i.versionid }), n.setMaster(i.master), n.removeAllListeners('@get-stats'), n.removeAllListeners('@ended'), n.on('@get-stats', (e, t, r) => { if (!this.connectionTransport) return t([]); this.connectionTransport.recvHandler.getStats(n.mediaTrack, e).then(t, r) }), n.once('@ended', async () => { if (n && n.info.trackId) { Y.warning('remote track ended, try to resubscribe'); try { await this._unsubscribe([n.info.trackId], !0) } catch (e) { } await this._subscribe([n.info.trackId], !0) } }), e.track = n; const o = this.users.find(e => e.userId === i.playerid); o && o.addTracks([n]) } c.forEach(t => t.connectStatus = e.TrackConnectStatus.Connect); const p = l.tracks.map(e => { if (void 0 === e.muted) for (let t = 0; t < this._trackInfo.length; t++)e.trackid === this._trackInfo[t].trackid && (e.muted = this._trackInfo[t].muted); return e }); this.handleMute({ tracks: p }) } catch (e) { Y.log(e); const r = []; if (c.forEach(e => { e.consumer && r.push(e.consumer) }), await u.removeConsumers(r), !(e instanceof _e)) return Y.warning(e, 'resubscribe'), void setTimeout(() => this._subscribe(t, !0), 1e3); switch (e.code) { case 10062: case 30001: return; case 10052: return Y.warning(e, 'resubscribe'), void setTimeout(() => this._subscribe(t, !0), 1e3); default: I(this.subscribeTracks, e => t.indexOf(e.trackId) !== -1), a(e) } } o(c.map(e => e.track)) }), t = r({}, ar, t), this.config = t, Y.log('config', t), Y.log('version', K), Y.log('browser report', T, k) } get users () { return Array.from(this._users.values()) } get trackInfoList () { return this._trackInfo.map(Tt) } get roomState () { return this._roomState } set roomState (e) { this._roomState !== e && (this._roomState = e, Y.debug('roomState change', this._roomState), this.emit('room-state-change', this._roomState), ye.addEvent('RoomStateChanged', { room_state: e })) } _setReconnectTimes (e) { this.config.reconnectTimes = e, this.signaling && (this.signaling.reconnectTimes = e) } _getReconnectTimes () { return this.config.reconnectTimes || ar.reconnectTimes } _setProfile (e, t) { if (this.profile = t, !this.subscribeTracks.some(t => t.trackId === e)) return; this.signaling.sendWsMsg('set-sub-profile', { tracks: [{ trackid: e, profile: this.profile }] }) } async joinRoomWithToken (t, r) { if (this.roomState !== e.RoomState.Reconnecting) { if (this.roomState !== e.RoomState.Idle) throw Se('roomState is not idle! Do not repeat join room, please run leaveRoom first'); this.roomState = e.RoomState.Connecting } ye.addEvent('JoinRoom', { room_token: t, user_data: r }); try { this.roomToken = t, this.userData = r; const n = Ve(t); if (this.userId = n.userId, this.roomName = n.roomName, this.appId = n.appId, Y.log('join room, token:', t), Y.debug(`join room, roomName: ${this.roomName}, userId: ${this.userId}`), !this.roomName.match(/^[a-zA-Z0-9_-]{3,64}$/)) throw this.roomState = e.RoomState.Idle, Se('invalid roomname. roomname must match /^[a-zA-Z0-9_-]{3,64}$/'); if (!this.userId.match(/^[a-zA-Z0-9_-]{3,50}$/)) throw this.roomState = e.RoomState.Idle, Se('invalid userId. userId must match /^[a-zA-Z0-9_-]{3,50}$/'); try { const e = await Wt(n, t); this.accessToken = e.accessToken, ye.setSessionId(e.sessionId), ye.setUserBase(this.userId, this.roomName, this.appId) } catch (e) { throw e } return await this.joinRoomWithAccess(this.accessToken) } catch (t) { throw this.roomState = e.RoomState.Idle, t } } async joinRoomWithAccess (t) { const r = (function (e) { const t = e.split('.')[1]; if (!t) throw new Error('parse jwt error, can not find payload string.'); const r = atob(t); return JSON.parse(r) }(t)); const { capsdp: n } = await (async function () { const e = Ye(); const t = await e.createOffer({ offerToReceiveAudio: !0, offerToReceiveVideo: !0 }); T.needH264FmtpLine && (t.sdp += `a=fmtp:107 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f${Bt}`); const r = { capsdp: t.sdp, agent: navigator.userAgent }; return e.close(), r }()); if (this._roomState === e.RoomState.Idle) throw Se('roomState is idle, maybe because you left the room.'); const i = new Xt(r.signalingurl2, t, n, this._getReconnectTimes(), this.userData); i.on('@error', this.handleDisconnect.bind(this)).on('@ws-state-change', (t, r) => { switch (r) { case zt.CONNECTING: this.roomState === e.RoomState.Connected ? this.roomState = e.RoomState.Reconnecting : this.roomState !== e.RoomState.Reconnecting && (this.roomState = e.RoomState.Connecting) } }).on('@needupdateaccesstoken', (e, t) => { this.updateAccessToken().then(e).catch(t) }).on('on-player-in', this.handlePlayerIn.bind(this)).on('on-player-out', this.handlePlayerOut.bind(this)).on('on-add-tracks', e => { this.filterSignalTracks(e), this.handleAddTracks(e) }).on('on-remove-tracks', e => { this.filterSignalTracks(e), this.handleRemoveTracks(e) }).on('mute-tracks', e => { this.filterSignalTracks(e), this.handleMute(e) }).on('on-messages', this.handleCustomMessages.bind(this)).on('on-qos-messages', this.handleQosMessages.bind(this)).on('on-pubpc-restart-notify', e => { const t = this.connectionTransport; ye.addEvent('AbnormalDisconnect', { event_reason: 'on-pubpc-restart-notify', event_description: e.error }), t && T.supportRestartICE && t.restartSendICE(e.pcid).catch(Y.debug) }).on('on-subpc-restart-notify', e => { const t = this.connectionTransport; ye.addEvent('AbnormalDisconnect', { event_reason: 'on-subpc-restart-notify', event_description: e.error }), t && T.supportRestartICE && t.restartRecvICE(e.pcid).catch(Y.debug) }).on('on-sub-profile-changed', e => { this.emit('on-sub-profile-changed', e) }).on('disconnect', this.handleDisconnect.bind(this)).on('on-player-reconnect', this.handleRemoteUserReconnecting.bind(this)).on('on-player-reconnect-in', this.handleRemoteUserReconnected.bind(this)), Y.log('init signaling websocket'), this.signaling = i; try { const e = await i.initWs(!0); i.on('@signalingauth', this.handleAuth.bind(this)), await this.handleAuth(e) } catch (e) { if (this.signaling && (this.signaling.release(), this.signaling = void 0), e.code === 10052) return await qe(1e3), this.joinRoomWithToken(this.roomToken, this.userData); throw e } return this.users } async _unpublish (t) { if (this.roomState !== e.RoomState.Connected) throw Se('not connected to the room'); if (t.length === 0) return; Y.debug('unpublish', t); const r = this.connectionTransport; const n = r.publishTracks.filter(e => t.indexOf(e.trackId) !== -1); if (n.length !== t.length) throw Se('can not find target trackid to unpublish'); await r.removeTracks(n), this.getAllMerger().forEach(e => e.controller.onRemoveTracks(n.map(e => e.track.info))); const i = Ge(this.users, 'userId', this.userId); i && (i.removeTracksByTrackId(t), i.removePublishedTrackInfo(t)), this.cleanTrackIdsFromMergeJobs(t) } async createMergeJob (t, n) { if (this.roomState !== e.RoomState.Connected) throw Se('can not createMergeJob, room state is not connected'); const i = r({}, F, n, { id: t }); Y.debug('send create merge job', i, t); const o = Date.now(); const a = await this.signaling.request('create-merge-job', i); if (ye.addEvent('CreateMergeJob', { signal_take_time: Date.now() - o, id: t, result_code: a.code }), a.code !== 0) throw Ce(a.code, a.error); this.mergeJobTracks[t] ? Y.warning('merge job id already exist', t) : this.mergeJobTracks[t] = [] } setDefaultMergeStream (e, t, r) { if (r && !this.mergeJobTracks[r]) throw Le(r); this.merger && !r && (this.merger.release(), this.merger = void 0), r && this.mergeJobMerger[r] && (this.mergeJobMerger[r].release(), delete this.mergeJobMerger[r]); const n = this.CreateMergerSessionController(); r ? this.mergeJobMerger[r] = new Kt(e, t, n, r) : this.merger = new Kt(e, t, n, r) } _stopMerge (t) { if (this.roomState !== e.RoomState.Connected) throw Se('can not addMergeTracks, room state is not connected'); if (t && !this.mergeJobTracks[t]) throw Le(t); ye.addEvent('StopMerge', { id: t || '' }), this.signaling.sendWsMsg('stop-merge', { id: t }), t ? (delete this.mergeJobTracks[t], this.mergeJobMerger[t] && (this.mergeJobMerger[t].release(), delete this.mergeJobMerger[t])) : (this.defaultMergeJobTracks = [], this.merger && (this.merger.release(), this.merger = void 0)) } async _addMergeTracks (t, r) { if (this.roomState !== e.RoomState.Connected) throw Se('can not addMergeTracks, room state is not connected'); if (r && !this.mergeJobTracks[r]) throw Le(r); const n = t.map(e => ({ trackid: e.trackId, x: e.x, y: e.y, w: e.w, h: e.h, z: e.z, stretchMode: e.stretchMode })); const i = { id: r, add: n }; Y.debug('addMergeTracks', i), r ? (this.mergeJobTracks[r] = this.mergeJobTracks[r].concat(t.map(e => e.trackId)), this.mergeJobTracks[r] = R(this.mergeJobTracks[r], e => e)) : (this.defaultMergeJobTracks = this.defaultMergeJobTracks.concat(t.map(e => e.trackId)), this.defaultMergeJobTracks = R(this.defaultMergeJobTracks, e => e)), ye.addEvent('UpdateMergeTracks', { id: r || '', add: n.map(e => ({ track_id: e.trackid, x: e.x || 0, y: e.y || 0, w: e.w || 0, h: e.h || 0, z: e.z || 0 })) }), await this.signaling.request('update-merge-tracks', i) } async _removeMergeTracks (t, r) { if (this.roomState !== e.RoomState.Connected) throw Se('can not addMergeTracks, room state is not connected'); if (r && !this.mergeJobTracks[r]) throw Le(r); const n = { id: r, remove: t.map(e => ({ trackid: e })) }; Y.debug('removeMergeTracks', n), I(r ? this.mergeJobTracks[r] : this.defaultMergeJobTracks, e => t.indexOf(e) !== -1), ye.addEvent('UpdateMergeTracks', { id: r || '', remove: n.remove.map(e => ({ track_id: e.trackid })) }), await this.signaling.request('update-merge-tracks', n) } async _unsubscribe (t, r) { if (this.roomState !== e.RoomState.Connected) throw Se('no signaling model, please run joinRoomWithToken first'); const n = this.subscribeTracks.filter(e => t.indexOf(e.trackId) !== -1); Y.debug('unsubscribe', n), n.length !== 0 && (ye.addEvent('UnSubscribeTracks', { tracks: t.map(e => ({ track_id: e })) }), this.signaling.request('unsub-tracks', { tracks: n.map(e => ({ trackid: e.trackId })) }), r || (n.forEach(e => e.release()), I(this.subscribeTracks, e => t.indexOf(e.trackId) !== -1)), await this.connectionTransport.removeConsumers(n.map(e => e.consumer))) } _muteTracks (t) { if (this.roomState !== e.RoomState.Connected) throw Se('no signaling model, please run joinRoomWithToken first'); const r = this.connectionTransport; const n = {}; t.forEach(e => { n[e.trackId] = e.muted }); const i = r.publishTracks.filter(e => void 0 !== n[e.trackId]); i.forEach(e => { e.setMute(n[e.trackId]) }), ye.addEvent('MuteTracks', { tracks: i.map(e => ({ track_id: e.trackId, muted: e.track.info.muted, kind: e.track.info.kind })) }), this.signaling.sendWsMsg('mute-tracks', { tracks: t.map(e => ({ trackid: e.trackId, muted: e.muted })) }) } async kickoutUser (e) { Y.log('kickoutUser', e), await this.control('kickplayer', e) } sendCustomMessage (t, r, n) { if (this.roomState !== e.RoomState.Connected) throw Se('room state is not connected, can not send message'); const i = n || Je(8); const o = r && r.length !== 0 ? r : void 0; this.signaling.sendWsMsg('send-message', { msgid: i, target: o, type: 'normal', text: t }), Y.debug('send custom message', t, o, i) } leaveRoom () { this.roomState !== e.RoomState.Idle ? (Y.log('leave room'), ye.addEvent('LeaveRoom', { leave_reason_code: 0 }), this.signaling && this.signaling.sendDisconnect(), this.releaseRoom()) : Y.log('can not leave room, please join room first') } _releasePublishTracks () { } async control (t, r) { if (this.roomState !== e.RoomState.Connected) throw Se('can not connected to the room, please run joinRoom first'); const n = Date.now(); const i = await this.signaling.request('control', { command: t, playerid: r }); if (t === 'kickplayer' && ye.addEvent('KickoutUser', { signal_take_time: Date.now() - n, user_id: r, result_code: i.code }), i.error) throw Ae(i.code, i.error) } handlePlayerOut (e) { const t = this._users.get(e.playerid); if (t) { this._users.delete(e.playerid), I(this._trackInfo, t => t.playerid === e.playerid), I(this.subscribeTracks, e => e.track.userId === t.userId).forEach(e => e.release()), He(() => { Y.debug('user-leave', t), this.emit('user-leave', t) }) } } handlePlayerIn (e) { const t = Et(e); this._users.set(t.userId, t), He(() => { Y.debug('user-join', t), this.emit('user-join', t) }) } handleAddTracks ({ tracks: e }) { Y.log('receive track-add', e, r({}, this._trackInfo)); const t = new Set(); for (const r of e) { const e = Ge(this.users, 'userId', r.playerid); if (e) if (e.published && !t.has(e.userId) && this.sessionMode === 'stream') { const t = e.publishedTrackInfo.map(e => wt(e, !0)); this.handleRemoveTracks({ tracks: t }), t.push(r), this.handleAddTracks({ tracks: t }) } else this._trackInfo.push(r), e.addPublishedTrackInfo([Tt(r)]), t.add(e.userId) } if (this.sessionMode === 'stream') for (const e of Array.from(t)) He(() => { Y.debug('user-publish', this._users.get(e)), this.emit('user-publish', this._users.get(e)) }); He(() => { Y.debug('track-add', e.map(Tt)), this.emit('track-add', e.map(Tt)) }) } handleRemoveTracks ({ tracks: e }) { Y.log('receive track-remove', e, r({}, this._trackInfo)); const t = I(this._trackInfo, t => e.map(e => e.trackid).includes(t.trackid)); const n = new Set(); for (const e of t) { const t = this._users.get(e.playerid); if (!t) continue; t.removePublishedTrackInfo([e.trackid]), t.removeTracksByTrackId([e.trackid]), n.add(t.userId); const r = I(this.subscribeTracks, t => t.trackId === e.trackid)[0]; r && r.release() } if (this.cleanTrackIdsFromMergeJobs(e.map(e => e.trackid)), this.sessionMode === 'stream') for (const e of Array.from(n)) { const t = this._users.get(e); if (t.published) { const e = t.publishedTrackInfo.map(e => wt(e, !0)); this.handleRemoveTracks({ tracks: e }), this.handleAddTracks({ tracks: e }) } else He(() => { Y.debug('user-unpublish', t), this.emit('user-unpublish', t) }) } He(() => { Y.debug('track-remove', t.map(Tt)), this.emit('track-remove', t.map(Tt)) }) } handleMute ({ tracks: e }) { for (const t of e) { const e = t.trackid; const r = t.muted; const n = Ge(this._trackInfo, 'trackid', e); if (!n) return; const i = this._users.get(n.playerid); if (!i) return; const o = i.publishedTrackInfo.find(t => t.trackId === e); o && (o.muted = r); const a = i.tracks.find(t => t.info.trackId === e); a && (a.info.muted = r, a.setMute(r)), n.muted = r; const s = this.subscribeTracks.filter(t => t.trackId === e)[0]; s && s.setMute(r); let c = void 0; for (let e = 0; e < this._trackInfo.length; e += 1) this._trackInfo[e].playerid === n.playerid && this._trackInfo[e].kind !== n.kind && (c = this._trackInfo[e]); const u = { userId: n.playerid, muteAudio: !1, muteVideo: !1 }; n.kind === 'audio' ? (u.muteAudio = r, u.muteVideo = !!c && c.muted) : (u.muteVideo = r, u.muteAudio = !!c && c.muted), this.sessionMode === 'stream' && He(() => { Y.log('user-mute', u), this.emit('user-mute', u) }) } He(() => { Y.log('mute-tracks', e.map(e => ({ trackId: e.trackid, muted: e.muted }))), this.emit('mute-tracks', e.map(e => ({ trackId: e.trackid, muted: e.muted }))) }) } handleCustomMessages ({ messages: e }) { this.emit('messages-received', e.map(St)) } handleQosMessages ({ messages: e }) { const t = []; e.forEach(e => { try { const r = JSON.parse(e.qos); r.tracks_qos.forEach(n => { t.push({ userId: e.playerid, networkGrade: r.networkGrade, kind: n.kind, trackId: n.track, packetLossRate: n.lostRate, rtt: n.rtt }) }) } catch (e) { Y.warning('parse SignalingQosMessage error: ', e) } }), this.emit('remote-track-stats', t) } handleDisconnect (t) { if (Y.log('handle disconnect', t), [0, 10005, 10006].indexOf(t.code) === -1 && ye.addEvent('AbnormalDisconnect', { event_reason: 'websocket_error', event_description: t.error }), ye.addEvent('LeaveRoom', { leave_reason_code: t.code }), t.code === 10052 && this.roomToken) return this.roomState = e.RoomState.Reconnecting, void setTimeout(() => this.signaling.initWs(), 1e3); switch (this.releaseRoom(), t.code) { case 10006: this.emit('disconnect', { code: t.code, data: { userId: t.kickedid } }); break; default: this.emit('disconnect', { code: t.code }) } } handleRemoteUserReconnecting (e) { this.emit('remote-user-reconnecting', e) } handleRemoteUserReconnected (e) { this.emit('remote-user-reconnected', e) } async updateAccessToken () { const e = Ve(this.roomToken); const t = await Wt(e, this.roomToken); if (ye.setSessionId(t.sessionId), this.accessToken = t.accessToken, !this.signaling) throw Se('room state is idle'); this.signaling.accessToken = this.accessToken } async handleAuth (t) { if (this.filterSignalTracks(t), Y.debug('handleAuth', t), t.error) return void await this.joinRoomWithToken(this.roomToken, this.userData); t.tracks = t.tracks || [], t.tracks = t.tracks.filter(e => e.playerid !== this.userId), t.players = t.players || []; const r = this.roomState === e.RoomState.Reconnecting; let n = { join: [], leave: [], add: [], remove: [], mute: [] }; const i = Array.from(this._users.keys()); const o = t.players.map(e => e.playerid); if (n = (function (e, t, r, n, i) { const o = { join: [], leave: [], add: [], remove: [], mute: [] }; const a = t.map(e => e.trackid); const s = r.map(e => e.trackid); return a.forEach((n, i) => { if (t[i].playerid !== e) if (s.indexOf(n) === -1) o.remove.push(t[i]); else { const e = r.find(e => e.trackid === n); const a = t[i]; e.versionid !== a.versionid && (o.remove.push(a), o.add.push(e)) } }), s.forEach((n, i) => { if (r[i].playerid === e) return; const s = a.indexOf(n); s === -1 ? (o.add.push(r[i]), o.mute.push({ trackid: n, muted: r[i].muted })) : r[i].muted !== t[s].muted && o.mute.push({ trackid: n, muted: r[i].muted }) }), n.forEach(t => { t !== e && i.indexOf(t) === -1 && o.leave.push({ playerid: t }) }), i.forEach(t => { t !== e && n.indexOf(t) === -1 && o.join.push({ playerid: t }) }), o }(this.userId, this._trackInfo, t.tracks, i, o)), this.roomState = e.RoomState.Connected, r) Y.debug('get missing events', n), n.remove.length > 0 && this.handleRemoveTracks({ tracks: n.remove }), n.leave.length > 0 && n.leave.forEach(this.handlePlayerOut.bind(this)), n.join.length > 0 && n.join.forEach(this.handlePlayerIn.bind(this)), n.add.length > 0 && this.handleAddTracks({ tracks: n.add }), n.mute.length > 0 && this.handleMute({ tracks: n.mute }); else { this._trackInfo = t.tracks, this._users.clear(); for (const e of t.players || []) { const t = Et(e); const r = this._trackInfo.filter(e => e.playerid === t.userId); t.addPublishedTrackInfo(r.map(Tt)), this._users.set(t.userId, t) } } if (this.connectionTransport) { const r = this.connectionTransport.publishTracks.filter(t => t.connectStatus === e.TrackConnectStatus.Connecting); const n = this.subscribeTracks.filter(t => t.connectStatus === e.TrackConnectStatus.Connecting); this.connectionTransport.extendedRtpCapabilities = t.rtpcaps, (!this.connectionTransport.sendHandler.isPcReady || this.connectionTransport.sendHandler._isRestartingICE || r.length > 0) && this.connectionTransport.reconnectProducer(), (!this.connectionTransport.recvHandler.isPcReady || this.connectionTransport.recvHandler._isRestartingICE || n.length > 0) && this.connectionTransport.resetRecvHandler() } else this.connectionTransport = this.createConnectionTransport(t.rtpcaps) } createConnectionTransport (t) { const r = this.signaling; const n = new or(t, r, this.config.simulcast); return n.on('@needpubpc', (e, t, n, i) => { r.request('pubpc', { sdp: e, tracks: t.map(Ct), policy: this.config.transportPolicy }).then(e => { switch (e.code) { case 0: return void n(e); case 10052: throw xe(); default: throw Re(e.error) } }).catch(i) }), n.on('@needsubpc', (e, t, n) => { r.request('subpc', { tracks: e.map(e => this.profile ? { trackid: e, profile: this.profile } : { trackid: e }), policy: this.config.transportPolicy }).then(e => { switch (e.code) { case 0: return void t(e); case 10052: throw xe(); default: throw Ee(e.error) } }).catch(n) }).on('@needresub', () => { const t = this.subscribeTracks.map(e => e.trackId); this.subscribeTracks.forEach(t => t.connectStatus = e.TrackConnectStatus.Connecting), this._subscribe(t, !0) }).on('@needrepub', e => { this._publish(e.map(e => e.track), !0) }).on('@needresetrecv', () => { this.subscribeTracks.filter(e => !!e.track).forEach(e => { e.track.removeAllListeners('@ended') }) }), n } cleanTrackIdsFromMergeJobs (e) { I(this.defaultMergeJobTracks, t => e.indexOf(t) !== -1); for (const t in this.mergeJobTracks) I(t, t => e.indexOf(t) !== -1) } CreateMergerSessionController () { const e = new Qt(); const t = t => { e.onAddTracks(t) }; const r = t => { e.onRemoveTracks(t) }; return this.on('track-add', t), this.on('track-remove', r), e.getCurrentTracks = () => { if (!this.connectionTransport) return []; const e = this._trackInfo.map(Tt); const t = this.connectionTransport.publishTracks.map(e => e.track.info); return e.concat(t) }, e.addMergeTrack = (e, t) => { this._addMergeTracks(e, t) }, e.release = () => { this.off('track-add', t), this.off('track-remove', r) }, e } getAllMerger () { const e = []; this.merger && e.push(this.merger); for (const t in this.mergeJobMerger) e.push(this.mergeJobMerger[t]); return e } releaseRoom () { this.releaseSession(), this.signaling && (this.signaling.release(), this.signaling = void 0), ye.addEvent('UnInit', { id: `${this.sessionMode}_${Date.now()}` }, !0), this.connectionTransport && (this.connectionTransport.release(), this.connectionTransport = void 0), this.getAllMerger().map(e => { e.release() }), this.defaultMergeJobTracks = [], this.mergeJobTracks = {}, this.merger = void 0, this.mergeJobMerger = {}, this.roomState = e.RoomState.Idle, this._trackInfo = [], this._users.clear(), this.userId = void 0, this.subscribeTracks.forEach(e => { e.release() }), this.subscribeTracks = [] } } class cr extends bt { constructor (t) { const r = ft.createMediaStreamDestination(); super(r.stream.getAudioTracks()[0], t, 'local'), this.sourceType = e.TrackSourceType.MIXING, this.initAudioManager(!0), this.destination = r, this.inputList = [] } appendAudioSource (e) { this.inputList.find(t => t.track === e) ? Y.warning('track is already in the track list') : (this.inputList.push({ track: e }), e.audioManager.gainNode.connect(this.destination)) } removeAudioSource (e) { const t = this.inputList.find(t => t.track === e); t && (t.track.audioManager.gainNode.disconnect(this.destination), I(this.inputList, e => e === t)) } release () { for (const e of this.inputList) this.removeAudioSource(e.track); super.release() } } class ur { constructor (e, t) { this.effectSourceMap = new Map(), this.playback = !0, this.output = e, this.playbackEngine = t } get effectList () { return Array.from(this.effectSourceMap.keys()) } getEffectTrack (e) { return this.effectSourceMap.get(e) } playEffect (e, t) { const r = this.effectSourceMap.get(e); r ? (t && r.setVolume(t), this.playback && r.audioManager.audioSource && this.playbackEngine.addAudioNode(r.audioManager.gainNode), r.startAudioSource()) : Y.warning('can not find target effect', e) } async addEffectSource (t, r) { if (this.effectSourceMap.has(r)) return void Y.warning('duplicate effect key!', r); const n = await e.AudioUtils.createAudioTrackFromSource(t); this.effectSourceMap.set(r, n), this.output.appendAudioSource(n) } removeEffectSource (e) { let t = []; t = e ? [e] : Array.from(this.effectSourceMap.keys()); for (const e of t) { const t = this.effectSourceMap.get(e); if (!t) return; this.output.removeAudioSource(t), t.release(), this.effectSourceMap.delete(e) } } } class dr extends E { constructor (e, t) { super(), this.musicOption = { loop: !1, volume: 1 }, this.playback = !0, this.output = e, this.playbackEngine = t } get audioNode () { return this.musicTrack ? this.musicTrack.audioManager.gainNode : null } setMusicOption (e) { this.musicOption = Object.assign(this.musicOption, e), this.musicTrack && (this.musicTrack.setVolume(this.musicOption.volume), this.musicTrack.setLoop(this.musicOption.loop)) } async startMusicMixing (t) { if (this.musicTrack) return this.stopMusicMixing(), await this.startMusicMixing(t); if (this.musicTrack = await e.AudioUtils.createAudioTrackFromSource(t), this.output.appendAudioSource(this.musicTrack), this.setMusicOption({}), !this.musicTrack.audioManager.audioSource) throw Se('can not find audio source'); this.playback && this.audioNode && this.playbackEngine.addAudioNode(this.audioNode), this.musicTrack.on('audio-state-change', (e, t) => { this.emit('music-state-change', e, t) }), this.musicTrack.startAudioSource() } pauseMusicMixing () { this.musicTrack ? this.musicTrack.pauseAudioSource() : Y.warning('can not find target music, please run startAudioMixing') } resumeMusicMixing () { this.musicTrack ? this.musicTrack.resumeAudioSource() : Y.warning('can not find target music, please run startAudioMixing') } stopMusicMixing () { this.musicTrack && (this.musicTrack.stopAudioSource(), this.output.removeAudioSource(this.musicTrack), this.musicTrack.release(), this.musicTrack = void 0) } getMusicDuration () { return this.musicTrack ? this.musicTrack.getDuration() : 0 } getMusicCurrentTime () { return this.musicTrack ? this.musicTrack.getCurrentTime() : 0 } setMusicCurrentTime (e) { if (this.musicTrack && (this.musicTrack.setCurrentTime(e), !this.musicTrack.audioManager.audioSource)) throw Se('can not find audio source') } } class lr { constructor () { this.volume = 1, this.gainNode = ft.createGain(), this.gainNode.connect(ft.destination) } addAudioNode (e) { e.connect(this.gainNode) } removeAudioNode (e) { e.disconnect(this.gainNode) } release () { this.gainNode.disconnect() } } class hr { constructor (e) { if (this.playbackEngine = new lr(), this.sourcePlayebackState = !1, !(e instanceof bt)) throw Se('audio mixing manager: origin track is not audio track'); this.outputTrack = new cr(), this.outputTrack.appendAudioSource(e), this.source = e, this.effectManager = new ur(this.outputTrack, this.playbackEngine), this.musicManager = new dr(this.outputTrack, this.playbackEngine) } getMusicPlaybackState () { return this.musicManager.playback } setMusicPlaybackState (e) { this.musicManager.playback !== e && (this.musicManager.playback = e, this.musicManager.audioNode && (e ? this.playbackEngine.addAudioNode(this.musicManager.audioNode) : this.playbackEngine.removeAudioNode(this.musicManager.audioNode))) } getSourcePlaybackState () { return this.sourcePlayebackState } setSourcePlaybackState (e) { this.sourcePlayebackState !== e && (this.sourcePlayebackState = e, this.source.audioManager.audioSource && (e ? this.playbackEngine.addAudioNode(this.source.audioManager.gainNode) : this.playbackEngine.removeAudioNode(this.source.audioManager.gainNode))) } getEffectPlaybackState () { return this.effectManager.playback } setEffectPlaybackState (e) { this.effectManager.playback !== e && (this.effectManager.playback = e, this.effectManager.effectSourceMap.forEach((t, r) => { t.audioManager.audioSource && (e ? this.playbackEngine.addAudioNode(t.audioManager.gainNode) : this.playbackEngine.removeAudioNode(t.audioManager.gainNode)) })) } setBitrate (e) { this.outputTrack.setInfo({ kbps: e }) } setTag (e) { this.outputTrack.setInfo({ tag: e }) } release () { this.effectManager.removeEffectSource(), this.musicManager.stopMusicMixing(), this.outputTrack.removeAudioSource(this.source), this.outputTrack.release(), this.playbackEngine.release() } } class fr extends hr { constructor (e) { if (!e._audioTrack) throw Se('input stream do not have audio track'); super(e._audioTrack), this.input = e; const t = [this.outputTrack]; this.input._videoTrack && t.push(this.input._videoTrack), this.outputStream = new _t(t, 'send', this.input.userId) } setBitrate (e, t) { e && this.outputStream._audioTrack && this.outputStream._audioTrack.setKbps(e), t && this.outputStream._videoTrack && this.outputStream._videoTrack.setKbps(t) } } !(function (e) { function t (e, t = 'anonymous', r, n) { const i = document.createElement('audio'); i.preload = 'auto', i.src = e, i.crossOrigin = t; const o = new kt(i); return n && o.setKbps(n), o.setInfo({ tag: r }), o } function r (e, t, r) { return new Promise((n, o) => { const a = new FileReader(); a.onload = e => { i(e.target.result).then(e => { const i = new kt(e); r && i.setKbps(r), i.setInfo({ tag: t }), n(i) }).catch(o) }, a.readAsArrayBuffer(e) }) } function n (e, t, r) { const n = new kt(e); return r && n.setKbps(r), n.setInfo({ tag: t }), n } async function i (e) { ft.state === 'suspended' && await ft.resume(); return await (() => new Promise((t, r) => { ft.decodeAudioData(e, e => { t(e) }, e => { r(Be(e)) }) }))() } e.createAudioTrackFromURL = t, e.createAudioTrackFromFile = r, e.createAudioTrackFromBuffer = n, e.createAudioTrackFromSource = async function (e, i, o) { return e instanceof File ? await r(e, i, o) : e instanceof AudioBuffer ? n(e, i, o) : t(e, 'anonymous', i, o) }, e.decodeAudioData = i, e.createAudioMixingManagerFromTrack = function (e) { return new hr(e) }, e.createAudioMixingManagerFromStream = function (e) { return new fr(e) } }(e.AudioUtils || (e.AudioUtils = {}))); const pr = { audio: { enabled: !0 }, video: { enabled: !0, bitrate: 600 } }; class mr extends E { constructor () { super(), this.deviceMap = {}, T.support && (this.updateDeivceInfo(), T.ondevicechange || window.setInterval(this.updateDeivceInfo.bind(this), 1e3), T.ondevicechange && (navigator.mediaDevices.ondevicechange = this.updateDeivceInfo.bind(this))) } async getLocalTracks (t = pr) { if (Y.debug('get local tracks', t), O(t) && x(t)) { const e = { screen: t.screen }; const r = { video: t.video, audio: t.audio }; const n = await Promise.all([this.getLocalTracks(e), this.getLocalTracks(r)]); return n[0].concat(n[1]) } const r = await (async function (e) { if (!e) return { audio: !0, video: !0 }; if (O(e)) { if (x(e)) throw Se('can not get mediaStream with video and screen are all enabled'); if (!T.screenSharing) throw Me('your browser can not share screen'); const t = e.screen; if (y && (t.forceChromePlugin || !T.getDisplayMedia) && !await ot()) throw Oe('') } const t = !(!e.audio || !e.audio.enabled || e.audio.source) && { deviceId: e.audio.deviceId, sampleRate: e.audio.sampleRate, sampleSize: e.audio.sampleSize, channelCount: e.audio.channelCount, autoGainControl: e.audio.autoGainControl, echoCancellation: e.audio.echoCancellation, noiseSuppression: e.audio.noiseSuppression }; const r = !(!e.video || !e.video.enabled) && { frameRate: e.video.frameRate, height: e.video.height, width: e.video.width, deviceId: e.video.deviceId }; if (O(e) && e.screen) { if (T.getDisplayMedia && !e.screen.forceChromePlugin) return Pt({ audio: t, video: { displaySurface: It(e.screen.source), width: e.screen.width, height: e.screen.height, frameRate: e.screen.frameRate } }); const r = await at(!1, e.screen); return Pt({ audio: t, video: r }) } return Pt({ audio: t, video: r }) }(t)); let n; r.video && typeof r.video === 'object' && r.video.deviceId && ye.addEvent('DeviceChanged', { type: 0, desc: r.video.deviceId }), r.audio && typeof r.audio === 'object' && r.audio.deviceId && ye.addEvent('DeviceChanged', { type: 1, desc: r.audio.deviceId }); try { n = await this.getUserMedia(t, r, !0) } catch (e) { throw e.name === 'NotAllowedError' ? De('') : e } let i = void 0; let o = void 0; let a = void 0; let s = void 0; M(t) && (o = t.audio.bitrate, s = t.audio.tag), O(t) && (i = t.screen.bitrate, a = t.screen.tag), x(t) && (i = t.video.bitrate, a = t.video.tag); const c = n ? n.getTracks() : []; const u = []; for (const e of c) { let t; t = e.kind === 'audio' ? Rt(e, s, o) : Rt(e, a, i), u.push(t) } if (t.audio && t.audio.source) { const r = await e.AudioUtils.createAudioTrackFromSource(t.audio.source, s, o); u.push(r) } return u } async getLocalStream (e) { if (e && O(e) && x(e)) throw Se('can not get local stream with video and screen'); const t = await this.getLocalTracks(e); return new _t(t, 'send') } async getUserMedia (e, t, n) { if (Y.debug('request to get user media', t, e), !t.audio && !t.video) return null; let i; if (O(e)) i = await this.getDisplayMedia(t, e); else { i = await navigator.mediaDevices.getUserMedia(t); const n = t.video; if (n && typeof n !== 'boolean') { const o = n.width; const a = n.height; if (typeof o === 'number' && typeof a === 'number') { const s = i.getVideoTracks(); const c = s && s[0]; const { height: u = a, width: d = o } = c.getSettings(); if (d && u) { const i = (a - u) * (o - d); if (i * i > 10) { const i = a / o; return u / d < i ? (n.height = u, n.width = u / i) : (n.width = d, n.height = d * i), Y.debug('justified constraint constraintHeight, contraintWidth, constraintRatio, screenHeight, screenWidth:', a, o, i, u, d, n), this.getUserMedia(e, r({}, t, { video: n })) } } } } } return i } async getDisplayMedia (e, t) { let r, n; e.audio && (r = await navigator.mediaDevices.getUserMedia({ audio: e.audio })); const i = t.screen && t.screen.audio && !e.audio ? { video: e.video, audio: t.screen.audio } : { video: e.video }; return n = T.getDisplayMedia && t.screen && !t.screen.forceChromePlugin ? await navigator.mediaDevices.getDisplayMedia(i) : await navigator.mediaDevices.getUserMedia(i), r && n.addTrack(r.getAudioTracks()[0]), n } async updateDeivceInfo () { this.deviceInfo = await navigator.mediaDevices.enumerateDevices(); const e = this.deviceInfo.map(e => e.deviceId); const t = Object.keys(this.deviceMap); let r = !1; t.forEach(t => { if (e.indexOf(t) === -1 && t !== '@default') { this.emit('device-remove', this.deviceMap[t].device); const e = this.deviceMap[t].device; ye.addEvent(e.kind === 'audioinput' || e.kind === 'audiooutput' ? 'AudioDeviceInOut' : 'VideoDeviceInOut', { device_type: e.kind === 'audiooutput' ? 1 : 0, device_state: 0, device_label: e.label, device_id: e.deviceId, device_info: e.label }), delete this.deviceMap[t], r = !0 } else this.deviceMap[t].tick += 1 }), e.forEach((e, n) => { if (t.indexOf(e) === -1 && e !== '@default') { this.deviceMap[e] = { device: this.deviceInfo[n], tick: 0 }; const t = this.deviceMap[e].device; this.emit('device-add', t), ye.addEvent(t.kind === 'audioinput' || t.kind === 'audiooutput' ? 'AudioDeviceInOut' : 'VideoDeviceInOut', { device_type: t.kind === 'audiooutput' ? 1 : 0, device_state: 1, device_label: t.label, device_id: t.deviceId }), r = !0 } }), r && this.emit('device-update', this.deviceInfo) } } const vr = new mr(); e.StreamModeSession = class extends sr { constructor (e) { super(e), this.subscribedUsers = {}, this.sessionMode = 'stream', ye.addEvent('Init', { id: `${this.sessionMode}_${Date.now()}` }) } async publish (e) { if (!this.stream) return e.userId = this.userId, this.stream = e, await this._publish(e.trackList); Y.warning('repeat publish, please unpublish first!') } async unpublish () { if (!this.connectionTransport) return; const e = this.connectionTransport.publishTracks.map(e => e.trackId); await this._unpublish(e), this.stream = void 0 } async setMergeStreamLayout (e, t) { let n = void 0; if (!(n = t.id ? this.mergeJobTracks[t.id] : this.defaultMergeJobTracks)) throw Le(t.id); const i = Ge(this.users, 'userId', e); if (!i || !i.published) return void Y.warning(`can not setMergeOption, user ${e} is published ?`); const o = t; !1 === t.visible && (o.hidden = !0); const a = o.id; const s = !!o.hidden; const c = !!o.muted; delete o.id, delete o.hidden, delete o.muted; const u = []; const d = []; for (const e of i.publishedTrackInfo) e.kind === 'audio' && c ? d.push(e.trackId) : e.kind === 'audio' && u.push({ trackId: e.trackId }), e.kind === 'video' && s ? d.push(e.trackId) : e.kind === 'video' && u.push(r({}, o, { trackId: e.trackId })); await this._addMergeTracks(u, a), await this._removeMergeTracks(d, a) } stopMergeStream (e) { this._stopMerge(e) } async subscribe (e) { if (e === this.userId) throw Pe(10044, 'can not subscribe yourself'); const t = this._trackInfo.filter(t => t.playerid === e && t.master); if (t.length === 0) throw Pe(10041, `subscribe user ${e} is not published`); const r = t.map(e => e.trackid); const n = await this._subscribe(r, !1, !0); return this.subscribedUsers[e] = new _t(n, 'recv', e), this.subscribedUsers[e].once('release', () => { delete this.subscribedUsers[e] }), this.subscribedUsers[e] } async unsubscribe (e) { this.subscribedUsers[e] ? (await this._unsubscribe(this.subscribedUsers[e].trackList.map(e => e.info.trackId)), delete this.subscribedUsers[e]) : Y.warning('user', e, 'is not in subscribedUsers') } mute (e, t = !1) { if (!this.stream) return void Y.warning('can not mute, please run publish first'); const r = []; this.stream._audioTrack && this.stream._audioTrack.info.muted !== e && r.push({ trackId: this.stream._audioTrack.info.trackId, muted: e }), this.stream._videoTrack && this.stream._videoTrack.info.muted !== t && r.push({ trackId: this.stream._videoTrack.info.trackId, muted: t }), this._muteTracks(r) } filterSignalTracks (e) { e.tracks && (e.tracks = e.tracks.filter(e => { if (void 0 !== e.master && e.master !== null) return e.master; const t = this._trackInfo.find(t => t.trackid === e.trackid); return !!t && t.master })) } releaseSession () { this.stream && (this.stream.release(), this.stream = void 0); for (const e in this.subscribedUsers) this.subscribedUsers[e].release(); this.subscribedUsers = {} } }, e.TrackModeSession = class extends sr { get publishedTracks () { return this.connectionTransport ? this.connectionTransport.publishTracks.filter(t => t.connectStatus === e.TrackConnectStatus.Connect).map(e => e.track) : [] } get subscribedTracks () { return this.subscribeTracks.filter(t => t.connectStatus === e.TrackConnectStatus.Connect).map(e => e.track) } get mergeStreamTracks () { return this.defaultMergeJobTracks } get mergeStreamJobTracks () { return this.mergeJobTracks } constructor (e) { super(e), this.sessionMode = 'track', ye.addEvent('Init', { id: `${this.sessionMode}_${Date.now()}` }) } async publish (e) { return await this._publish(e) } async unpublish (e) { return await this._unpublish(e) } async subscribe (e, t = !1, r) { return await this._subscribe(e, !1, t, r) } async unsubscribe (e) { return await this._unsubscribe(e) } setProfile (e, t) { this._setProfile(e, t) } setReconnectTimes (e) { this._setReconnectTimes(e) } getReconnectTimes () { return this._getReconnectTimes() } muteTracks (e) { this._muteTracks(e) } async addMergeStreamTracks (e, t) { await this._addMergeTracks(e, t) } async removeMergeStreamTracks (e, t) { await this._removeMergeTracks(e, t) } stopMergeStream (e) { this._stopMerge(e) } filterSignalTracks () { } releaseSession () { } }, e.version = K, e.log = Y, e.User = st, e.Stream = _t, e.Track = lt, e.AudioTrack = bt, e.browserReport = T, e.isChromeExtensionAvailable = ot, e.createCustomTrack = Rt, e.REC_AUDIO_ENABLE = M, e.REC_VIDEO_ENABLE = x, e.REC_SCREEN_ENABLE = O, e.defaultMergeJob = F, e.QosEventType = $, e.DeviceManager = mr, e.deviceManager = vr, e.AudioSourceTrack = kt, e.TrackMixingManager = hr, e.StreamMixingManager = fr, e.AudioEffectManager = ur, e.AudioMusicManager = dr, Object.defineProperty(e, '__esModule', { value: !0 }) }))
